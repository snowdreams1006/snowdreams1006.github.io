{"./":{"url":"./","title":"简介","keywords":"","body":"简介 教程分享均是笔者亲身学习经验总结,涉及到的知识点均亲身试验,但有时为了知识完整性,可能并未亲自确认,对于这部分内容会明确指出,到时由读者确认试验. 如果读者实际运行效果和教程演示效果有出入,很可能是版本问题,系统环境等原因,希望能及时反馈,避免更多人踩坑,谢谢! 国内用户推荐访问 blob.snowdreams1006.cn ,速度非常快并且和 snowdreams1006.github.io 保持同步更新. 教程特点 面向初学者,适合零基础入门; 面向常用操作,技能实用性强; 情景教学,理清事情来龙去脉; 章节重点知识小结,精华集锦; 学习要求 保持哲学三问,是什么,为什么,怎么样?希望最终能有你自己的答案; 好记性不如烂笔头,亲自动手操作一遍,你会发现你的理解更上一层楼; 授人以鱼不如授人以渔,希望带给你不仅仅是知识更多的是学习的方法; 知识重在分享才有价值,鼓励知识传播与分享,创造收益更有价值; 因本人能力有限,如有出入,敬请指正,请联系我 snowdreams1006 怎么联系 第三方平台 微信公众号 名称 : 雪之梦技术驿站,微信号 : snowdreams1006 关注理由: 开源的不开源的都会发布到微信公众号,不再局限于系列教程而是随性而为,展示真实的技术人生. 个人微信号 名称 : 雪之梦技术驿站,微信号 : snowdreams1109 适用场景: 如果三言两语很难阐释你遇到的问题,如果你是人见人爱的妹子,那么欢迎加我私人微信一起畅谈人生. 相关说明 本教程源码托管在 snowdreams1006.github.io ,在线阅读请访问 snowdreams1006.github.io. 如果你觉得本教程对你有所帮助,请不吝 Star. 如果你想贡献一份力量,欢迎提交 Pull Request. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-20 10:37:07 "},"markdown/":{"url":"markdown/","title":"markdown 入门教程","keywords":"","body":"markdown 入门教程 markdown 不止是 HTML 的简化版,更重要的是 txt 的升级版,word 的轻量版,是笔记的最佳载体. markdown 作为一种简单的格式标记语言,不同于 txt 的无格式,不同于 HTML 的复杂标记,也不同于 word 的鼠标调整样式. markdown 通过简单的几个字符键入,就可以快捷的定义文档的样式. 掌握 markdown,你可以完全抛弃 txt 和笔记软件的编辑器,并且在大多数场景下替代掉复杂臃肿的 word.享受简洁之美、享受效率提升. 下面列举了 markdown 语法及对应的示例： 标题 在标题文字前面加#,并且加上空格分割. 一个#是一级标题,两个#是两级标题,以此类推,最多支持六级标题. 示例: # 标题1 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 ###### 标题6 效果: 标题1 标题2 标题3 标题4 标题5 标题6 列表 包括有序列表和无序列表,支持列表嵌套. 有序列表 有序列表就是有顺序的列表,依靠行前的数字加.标记顺序,序号和内容之间以空格 分开. 示例: 1. 有序列表1 2. 有序列表2 3. 有序列表3 效果: 有序列表1 有序列表2 有序列表3 无序列表 无序列表就是列表不排序,支持- * + 3种前缀,可用于表示1级列表,2级列表,3级列表. 示例: - 无序列表1 * 无序列表2 + 无序列表3 效果: 无序列表1 无序列表2 无序列表3 列表嵌套 上一级和下一级列表之间空两个空格 即可表示列表嵌套. 示例: - 无序列表1 * 无序列表11 * 无序列表12 * 无序列表13 + 无序列表131 + 无序列表132 + 无序列表133 - 无序列表2 - 无序列表3 效果: 无序列表1 无序列表11 无序列表12 无序列表13 无序列表131 无序列表132 无序列表133 无序列表2 无序列表3 引用 在引用文字前加一个>即可,支持引用嵌套. 示例: > 引用1 >> 引用11 >>> 引用111 效果: 引用1 引用11 引用111 字体 粗体 要加粗的文字左右两边分别用两个 * 号或者 _ 号包围起来 斜体 要倾斜的文字左右两边分别用一个 * 号或者 _ 号包围起来 粗体+斜体 要加粗并倾斜的文字左右两边分别用三个 * 号或者 _ 号包围起来 删除线 要删除的文字左右两边分别用两个 ~ 号包围起来 示例: **粗体1** __粗体2__ *斜体1* _斜体2_ ***粗体+斜体1*** ___粗体+斜体2___ ~~删除线~~ 效果: 粗体1 粗体2 斜体1 斜体2 粗体+斜体1 粗体+斜体2 删除线 分割线 三个或三个以上的- *即可表示分割线 示例: --- *** 效果: 图片 其中,图片alt表示图片的解释文字,图片src是图片地址,支持本地路径和网络路径,图片title是图片的标题,可选. 示例: ![preview.png](images/preview.png \"preview.png\") 效果: 超链接 超链接text 其中,超链接text表示超链接的解释文字,超链接url支持本地路径和网络路径,超链接title是超链接的标题,可选. 示例: [https://snowdreams1006.github.io](https://snowdreams1006.github.io \"snowdreams1006\") 效果: https://snowdreams1006.github.io 表格 第一行定义表头,单元格内定义标题; 第二行定义样式,单元格内部至少一个-,文字默认居左对齐,单元格内部-两侧均加:表示居中,只有右侧加:表示居右对齐; 第三行定义数据; 示例: |默认居左|文字居中|文字居右| |-|:-:|-:| |居左对齐1|居中对齐1|居右对齐1| |居左对齐2|居中对齐2|居右对齐2| |居左对齐3|居中对齐3|居右对齐3| 效果: 默认居左 文字居中 文字居右 居左对齐1 居中对齐1 居右对齐1 居左对齐2 居中对齐2 居右对齐2 居左对齐3 居中对齐3 居右对齐3 代码 单行代码 代码两侧分别用一个反引号包围起来 示例: `code` 效果: code 多行代码 代码块首尾分别用三个反引号包围起来,且两边的反引号独占一行 示例: (```) function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); (```) 注：为了防止转译,前后三个反引号处加了小括号,实际是没有的. 效果: function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); 注释 示例: 效果: 看不到注释就对了! 都学会了吗? 那考考你,你猜当前文档是如何书写的,看看你的答案和我实际书写规则是否一致呢! 答案请参考snowdreams1006.github.io 参考文献 https://daringfireball.net/projects/markdown/syntax http://www.markdown.cn/ https://www.appinn.com/markdown/index.html var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/markdown/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"git/":{"url":"git/","title":"git 入门教程","keywords":"","body":"git 入门教程 git 是分布式版本控制系统,是文本文档管理的利器,是帮助你管理文件动态的好帮手. 如果你曾经手动管理过文档,一定有这样的经历,比如你正在编辑文档,想删除某段落,又担心不久后可能会恢复,此时你可能会先备份然后再删除,或者想要修改某段落,几经修改后发现还是最初的比较好,这是就哭笑不得了... 从最初的新建文档,经过反反复复的修改,最终定稿文档的过程极其繁琐冗长,这就是手动式管理文档的痛点. 如果有这么一种工具,能帮我自动记录每次文档的改动,想要查看文档变更详情只需要打开软件就能一目了然告诉我发生了哪些改变?岂不美哉! 版本 文件 用户 说明 时间 1 README.md snowdreams1006 初始化简介文档 2019-03-01 08:00 2 README.md snowdreams1006 增加特点说明 2019-03-01 10:00 3 README.md snowdreams1006 增加要求说明 2019-03-01 12:00 事实上,还真有这样的软件,专业术语称为版本控制系统,而git就是最先进的分布式版本控制系统; 特点: 文件的变更从此有迹可循,再也不怕丢失文件; 有网无网均可工作,数据交换不需再相互拷贝; 人人平等的开放环境,有机会贡献自己的智慧; 本书发表在 https://snowdreams1006.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/base/about.html":{"url":"git/base/about.html","title":"初识 git","keywords":"","body":"初识 git git 是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目. 背景 我们都知道,Linus 在1991年创建了开源的linux系统,随着不断发展壮大,目前已发展成为最大的服务器系统软件. Linus 虽然创建了 linux,但 linux 的发展壮大是靠全世界热心的志愿者参与贡献的,这么多人在世界各地为linux系统编写代码,那么linux的代码是如何管理呢? 事实上,在2002年以前,世界各地的志愿者直接将源代码通过 diff 的方式发送给Linus,然后由Linus本人通过手动方式合并代码! ... Linus花了两周时间自己用 C语言 写了一个分布式版本控制系统，这就是Git！ 一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下. 分布式 和 集中式 先说集中式版本控制系统,版本库是集中存放在专门的中央服务器中,而平时使用过程中需要时刻处于联网状态才能和中央服务器保持联系.日常工作流程是这样的,上班前先从中央服务器拉取最新工作内容,本地修改完毕后推送到中央服务器,第二天上班再拉取最新内容,修改后再推送给中央服务器... 集中式版本控制系统的特点就是必须要有一个专门的中央服务器,工作中必须联网才能进行版本控制,试想一下如果正在在外地出差或者没有网络条件下,还怎么进行版本控制,岂不是又重新回到原始时代了吗? 那再说说分布式版本控制系统,版本库是存放在各自使用者的电脑的,不需要专门的中央服务器,每个人电脑中就是一份完整的版本库,因此不需要联网也能工作,工作流程和其他的版本控制系统大致相同. 由此可见,集中式的版本控制系统依赖于中央服务器,要求使用者一直保持通信,而分布式的版本控制系统并不依赖中央服务器,不必强制联网. 万一出现意外,集中式版本控制系统中充当中央服务器的电脑宕机了,那么所有人就没法工作了,再也不能享受版本控制带来的便利了! 同样的情况发生在分布式版本控制系统身上会如何呢?一台电脑宕机没关系,所有人的电脑不可能同时都宕机吧,因为每个人电脑中都是一份完整的版本控制,那么找到其中一个人的版本手动复制到宕机电脑中瞬间不久恢复运行了么?所以说分布式比集中式更安全! 可能会有疑问了,既然分布式版本控制系统中每个人都拥有完整的版本库,那么两个人到底如何交流以谁的版本为准呢?一个版本,两个版本还好,假设有100个版本库呢? 实际上,这并不重要,假设有100个人在合作开发一个项目,而你作为项目负责人,你可能并不关心100人的全部工作细节,在乎的只是最终成果,而这些成果是由10个项目组长提交维护的,所以你关心的只是10个版本,假设没有集中式的中央服务器角色,那么你需要手动合并10个版本库,最终完成项目. 这样看起来中央服务器确实还是有存在的必要,为了方便不同版本库之间进行交流,通常分布式版本控制系统也有一台充当中央服务器角色的电脑,需要理解的是,此时中央服务器的作用仅仅是方便大家交换各自的修改而已,没有它,大家还是可以照常工作的,只是彼此间交换修改不太方便而已! 不论是分布式还是集中式,存在即合理,如何取舍有着各自应用场景,分别代表民主和专制. git 和 svn git 是分布式版本控制系统的代表,除此之外还有BitKeeper,Mercurial,Bazaar 等分布式控制系统,每种分布式控制系统均有自身特点,毋容置疑的是git是最简单最流行! svn 是集中式版本控制系统的代表,是目前使用最广泛的集中式版本控制系统,cvs ClearCase等均属于集中式. 不论是分布式还是集中式,不论是免费还是收费,不一昧追求最好的,只需要最适合自己的即可. git 是分布式控制系统,svn 是集中式版本控制系统 git 将内容按元数据方式存储,svn 是按文件方式存储 git 的内容完整性优于svn,因为 git 内容存储基于sha-1哈希算法,确保内容的完整性. 小结 git 是Linus为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/base/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/base/install.html":{"url":"git/base/install.html","title":"安装 git","keywords":"","body":"安装 git git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行,根据自身环境选择安装. Linux 系统 linux 系统安装软件大致有两种途径,一种是利用安装包管理工具安装,另一种采用源码包安装方式. 安装前先确认下是否之前已安装过,在命令行窗口输入git --version ,如果打印出版本号则表示已安装,否则参考一下内容进行安装. 查看 git 版本 git --version Debian/Ubuntu # 安装 git 依赖 apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev # 安装 git apt-get install git # 查看 git 版本 git --version Centos/RedHat # 安装 git 依赖 yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel # 安装 git yum -y install git # 查看 git 版本 git --version git-core 和 git 历史渊源: 以前有个软件也叫GIT(GNU Interactive Tools),所以git只能叫git-core了,后来由于git名气实在太大以至于GNU Interactive Tools改名成gnuit,而git-core正式改为git. 源码安装 先从git 官网下载指定版本源码,然后解压,依次输入：./config,make, sudo make install 这几个命令安装到指定目录即可. Debian/Ubuntu # 安装 git 相关依赖 apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev # 下载指定版本源码包 wget https://github.com/git/git/archive/v2.21.0.tar.gz # 解压 tar -zxf v2.21.0.tar.gz # 切换到 git目录 cd git-2.21.0 # 安装 make prefix=/usr/local all # 安装 sudo make prefix=/usr/local install Centos/RedHat # 安装 git 相关依赖 yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel # 解压 tar -zxf v2.21.0.tar.gz # 切换到 git目录 cd git-2.21.0 # 安装 make prefix=/usr/local all # 安装 sudo make prefix=/usr/local install Windows 系统 直接从git 官网下载安装程序,然后按默认选项安装即可. 安装完成后,在开始菜单里找到Git->Git Bash,弹出命令行窗口,则说明安装成功！ Mac 系统 一般有两种安装方式,一种是利用 mac 的homebrew管理工具安装git,具体安装方法参考homebrew官方文档 另一种方法安装xcode默认集成git,首先从 App Store下载 xcode ,下载完成后运行Xcode，选择菜单Xcode->Preferences，在弹出窗口中找到Downloads，选择Command Line Tools，点Install就可以完成安装了 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/base/install.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/base/config.html":{"url":"git/base/config.html","title":"配置 git","keywords":"","body":"配置 git 安装完成后,还需要最后一步配置就可以愉快使用了,在命令行输入： git config --global user.name \"your username\" git config --global user.email \"example@example.com\" 因为Git是分布式版本控制系统,所以每个机器都必须自报家门:你的名字和Email地址. 配置文件 git 提供git config工具,专门用来配置相应的工作环境变量,支持三种不同的位置. /etc/gitconfig 配置文件 (优先级最低) 系统中对所有用户都生效的配置,效果等同于git config --system ~/.gitconfig 配置文件 (优先级其次) 系统中仅仅对当前登录用户生效的配置,效果等同于git config --global $(pwd)/.git/config 配置文件 (优先级最高) 仅仅对当前项目生效,效果等同于git config 每一级别的配置都会自动覆盖上级相同配置,当前项目配置优先于其余配置 查看配置 如果要查看已有的配置信息,可以输入 git config --list 命令,如果看到重复变量名,表示来自不同配置文件(比如/etc/gitconfig 和 ~/.gitconfig),实际上git会采用最后一个! # 查看已有配置信息 git config --list # 查看当前用户配置信息 cat ~/.gitconfig # 查看系统级别配置信息 cat /etc/gitconfig 也可以直接查看某项环境变量值,比如 # 查看用户名称变量 git config user.name var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/base/config.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/about.html":{"url":"git/usage/about.html","title":"实战 git","keywords":"","body":"实战 git git 是一款分布式版本控制系统,可以简单概括: 不要把鸡蛋放在一个篮子里,你的一举一动都在监视中. 实战场景 你作为某项目的其中一员或者负责人,和小伙伴们一起开发,大家既有着各自分工互不干扰,也有着相互合作,最终每个人的劳动成果汇聚成最后的项目,愉快完成项目! 要求 理解 git 的工作流程,懂得实际工作中如何交流合作 掌握 git 常用操作,工具为我所有,进而提高工作效率 独当一面,最好能够独自解决使用git 过程中遇到的问题 主动分享经验,能够教会别人如何使用 git 更上一层楼 推荐 最好的教程在官网 git 官网 在线练习常用操作 Learning Git Branching 廖雪峰的官方网站 git教程 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/local-repository.html":{"url":"git/usage/local-repository.html","title":"本地仓库","keywords":"","body":"本地仓库 背景 创建工作目录 平时工作时我们习惯对文档分门别类进行管理,.doc .txt 等文本类型的文件习惯存在 doc文件下,开发java js 等源代码文件存在在 src 目录下,这一点很好理解,那么讲解 git的项目我们也要创建一个文件夹,姑且新建一个demo的文件夹吧! # 在工作空间创建指定目录 mkdir demo # 切换至工作目录 cd demo 创建本地仓库 既然已经创建了工作文件夹,那么我们自然是希望该文件下的所有文件都能被 git 管理,也就是说在当前文件下的创建新文件,修改原文件内容或者删除文件等操作都能纳入版本控制中,不然为什么要用git 呢? 下面这个命令就是告诉git 这个 demo 目录要纳入版本控制了. # 初始化本地仓库 git init 一旦运行git init 命令,细心的读者可能会发现在原来的 demo 目录下多了.git隐藏文件,正因如此,原来被我们称为工作目录的 demo 才能纳入版本控制,我们将.git目录称之为版本库. 由于当前项目 demo 只在我们自己电脑上,其他人无法访问,所以我们称这种形式的版本库为本地仓库. 添加文件到版本库 首先明确的是,所有的版本控制系统只能追踪文本文件的改动,文本文件就是平常熟悉的.txt .html .js .css .java .xml等等文件,非文本文件的其他格式有哪些? 例如二进制文件,像我们平时听音乐的.mp3,看视频的.mp4,浏览图片的.png等这些都是二进制文件,需要专门的软件才能正常打开,不信的话,你用记事本看看能不能打开视频? 了解文本文件和二进制文件的区别,那是不是说二进制文件没法进行版本控制了,刚才你不是还说demo 目录下的所有文件吗?这不是自相矛盾吗! 非也非也,git 当然也能够管理二进制文件,对于文本文件的追踪,可以细粒度到哪个文件在哪一行发生了哪些变化,而二进制文件只能粗粒度知道哪个文件变化了,并不知道具体变化. 不幸的是,Microsoft 的Word格式是二进制格式,因此,版本控制系统是没法跟踪Word文件的改动的,前面我们举的例子只是为了演示,如果要真正使用版本控制系统,就要以纯文本方式编写文件. 因为文本是有编码的,比如中文有常用的GBK编码,日文有Shift_JIS编码,如果没有历史遗留问题,强烈建议使用标准的UTF-8编码,所有语言使用同一种编码,既没有冲突,又被所有平台所支持. 言归正传,现在我们在demo 目录下创建一个test.txt 演示文件,内容如下git test # 创建新文件 touch test.txt # 编辑新文件,输入 git test echo \"git test\" > test.txt 接下来我们还需要两步操作才能将test.txt纳入git管理: 第一步,使用git add 命令将文件添加到本地仓库: # 添加到本地仓库: 第一步指定要添加的文件 git add test.txt 第二步,使用git commit -m 命令将文件提交到本地仓库: # 添加到本地仓库: 第二步指定添加文件备注 git commit -m \"add test.txt\" 经过上述两步操作,test.txt 文件已经纳入到版本控制中了,这里你可能会有疑问了为什么需要add commit两步呢? 因为commit 可以一次性提交很多文件,所以你可以多次add不同的文件,比如: # 创建三个文件file1.txt file2.txt file3.txt touch file1.txt file2.txt file3.txt # 添加一个文件file1.txt git add file1.txt # 添加两个文件file2.txt file3.txt git add file2.txt file3.txt # 一次性提交全部文件 git commit -m \"add 3 files.\" 小结 初始化本地仓库 git init 添加文件到本地仓库分两步 git add 和 git commit -m 实际工作中,大致以下流程 # 在工作空间创建指定目录 mkdir demo # 切换至工作目录 cd demo # 初始化本地仓库 git init # 创建新文件 touch test.txt # 编辑新文件,输入 git test echo \"git test\" > test.txt # 添加到本地仓库: 第一步指定要添加的文件 git add test.txt # 添加到本地仓库: 第二步指定添加文件备注 git commit -m \"add test.txt\" ... # 继续编辑目标文件,追加 git init echo \"git init\" >> test.txt # 将目标文件添加到本地仓库 git add test.txt # 添加本次新增文件的备注 git commit -m \"add git init\" var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/local-repository.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/version-manage.html":{"url":"git/usage/version-manage.html","title":"版本管理","keywords":"","body":"版本管理 背景 在上一节中我们已经成功创建版本库并且已经添加test.txt等文件,这一节我们继续讲解如何进行版本控制. 首先我们先查看test.txt 文件有什么内容吧! # 查看文件内容 $ cat test.txt git test git init git diff $ 接下来模拟正常工作,接着输入一下内容: # 追加新内容到 test.txt 文件 echo \"understand how git control version\" >> test.txt # 查看当前文件内容 $ cat test.txt git test git init git diff understand how git control version $ 紧接着运行 git status 看一下输出结果: # 查看文件状态 $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt $ 从上述 git status 命令输出的结果可以看出,test.txt 已经被修改但还没提交,但是具体发生了什么变化却没能告诉我们,如果能够告诉我们具体修改细节那就好了! 运行git diff命令可以实现上述需求 $ git diff diff --git a/test.txt b/test.txt index 729112f..989ce33 100644 --- a/test.txt +++ b/test.txt @@ -1,3 +1,4 @@ git test git init git diff +understand how git control version $ git diff 命令即查看差异(difference),从输出结果可以看出我们在最后一行新增了understand how git control version 文字. 通过git status 知道文件发生了改动,git diff 让我们看到了改动的细节,现在我们提交到版本库就放心多了,还记得上节课如何添加版本库的命令吗? 分两步操作: git add 和 git commit -m 第一步: git add $ git add test.txt $ 等一下,在执行 git commit 命令之前,我们再运行 git status 命令查看一下当前仓库状态: $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt $ 此时 git status 命令告诉我们 test.txt 文件已被修改等待提交,好了,那么接着第二步的commit吧! 第二步: git commit -m # 提交到版本库并添加备注 $ git commit -m \"add understand how git control version\" [master 36f234a] add understand how git control version 1 file changed, 2 insertions(+) $ 提交后,我们此时再次运行git status 命令查看当前仓库状态: $ git status On branch master nothing to commit, working tree clean $ 输出结果显示没有需要提价的改动,工作目录是干净的. 小结 查看工作区状态 git status 比较修改差异 git diff var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/version-manage.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/reset.html":{"url":"git/usage/reset.html","title":"回到过去","keywords":"","body":"回到过去 背景 现在你已经掌握git的基本操作了,文件发生更改首先使用 git add 添加更改,然后 git commit 提交全部更改,当本地文件再次发生更改时,仍然需要git add 和 git commit 两步操作,中途如何想查看文件是否发生更改,使用git status 查看版本库状态,git diff 命令帮助我们查看更改详情. 像这样重复的操作其实每次都会产生一个快照,用于保存文件状态,只不过这个快照不是完整的文件,被称为提交或者版本commit .一旦发生意外,假如文件修改乱了或者误删了文件,我们可以从最近的一个 commit 中进行恢复,然后继续工作,这就是git 管理的好处之一. 每一次重大更新或者你认为比较重要的时刻,我们总会留作纪念,添加些什么特殊标记来区分平时的提交,还记得我们每次提交都会添加备注吗?git commit -m 这条命令现在就可以大显身手了,我们现在要做的就是找到我们提交的历史记录,而历史记录中有我们提交的详情,这样即使过了一个月或者更长时间,我们也能清楚知道当时的情景! 查看提交历史记录 git log,接下来我们赶紧试一下吧 $ git log commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) Author: snowdreams1006 Date: Thu Mar 7 22:19:00 2019 +0800 add understand how git control version commit 2006f72ffe2ce2278b5974313b8598847cf445e4 Author: snowdreams1006 Date: Tue Mar 5 13:27:46 2019 +0800 add 3 files. commit eaa4850070354ae987dc5108a9fd57fda9d64730 Author: snowdreams1006 Date: Tue Mar 5 12:18:57 2019 +0800 add git init commit 6ad8956bc09a6a62c731711eabe796690aa6471c Author: snowdreams1006 Date: Tue Mar 5 12:17:51 2019 +0800 add test.txt git log 命令默认显示最近到最远的提交历史,这一点也很好理解,毕竟我们是在命令行操作,输入git log 完毕后自然先要定位到命令处,看到最新提交记录方便我们确认是否符合我们预期,还有一点就是如果提交历史过多,从头开始到最新提交记录岂不是眼花缭乱,简直不敢想象啊! 下面以最新的一次提交 commit 为例,简单解释一下输出内容: # 提交唯一标示id: 36f234a60d858871f040cb0d7ca3e78251df82f7 commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) # 作者: snowdreams1006 邮箱: Author: snowdreams1006 # 日期: Thu Mar 7 22:19:00 2019 +0800 Date: Thu Mar 7 22:19:00 2019 +0800 # 提交备注: add understand how git control version add understand how git control version 默认输出内容有点多,不仅有提交 id ,提交备注还有作者时间之类的,由于每个 commit 都如此,这样一来,满屏都展示不下,那能不能简化些呢? 一行显示提交日志 --pretty=oneline ,即git log --pretty=oneline $ git log --pretty=oneline 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) add understand how git control version 2006f72ffe2ce2278b5974313b8598847cf445e4 add 3 files. eaa4850070354ae987dc5108a9fd57fda9d64730 add git init 6ad8956bc09a6a62c731711eabe796690aa6471c add test.txt $ 相比无参数git log,是不是简短了一些呢? 和之前日志相比少了作者和时间等信息,仍然保留提交 id 和提交备注. 因为提交 commit 是 git 的基础,当然不能省略,而提交备注能够帮助我们理解commit 的含义,毕竟提交备注使我们自定义的内容,这也是我们为什么提交时要写提交备注的原因! 现在我们已经了解到版本库存放了我们的提交,接下来让我们验证一下是否能够回到过去吧! 回到上一个提交,上一个提交自然是相对当前提交而言,只有知道当前提交才能知道上一个提交以及上一个提交的上一个提交. 提交id 36f234a60d858871f040cb0d7ca3e78251df82f7,那么上一个提交HEAD^,上上一个提交是HEAD^^.如果此时我想回到往上数100个版本,那么是不是可以这么写? HEAD^^^^...^^^ 其中^ 有100个,如果需要手动打出100个^的话,那么绝对是疯了! 既然有这种相对定位方式,自然也有绝对定位方式,用绝对定位方式解决就是这样: HEAD~100 $ git log commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) Author: snowdreams1006 Date: Thu Mar 7 22:19:00 2019 +0800 add understand how git control version 回到上一个版本 git reset --hard HEAD^ 在操作之前我们先看一下当前文件 test.txt 的内容: $ cat test.txt git test git init git diff understand how git control version 现在让我们开始回到过去,运行 git reset --hard HEAD^ 命令: $ git reset --hard HEAD^ HEAD is now at 2006f72 add 3 files. $ 现在让我们再看一下,test.txt 的内容有没有被还原: $ cat test.txt git test git init 果然被还原了!这就是git的神奇之处,说明我们已经能够回到过去了! 现在我们先用git log 查看下提交历史: $ git log commit 2006f72ffe2ce2278b5974313b8598847cf445e4 (HEAD -> master) Author: snowdreams1006 Date: Tue Mar 5 13:27:46 2019 +0800 add 3 files. commit eaa4850070354ae987dc5108a9fd57fda9d64730 Author: snowdreams1006 Date: Tue Mar 5 12:18:57 2019 +0800 add git init commit 6ad8956bc09a6a62c731711eabe796690aa6471c Author: snowdreams1006 Date: Tue Mar 5 12:17:51 2019 +0800 add test.txt $ 和上次相比,少了一条提交记录: commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) Author: snowdreams1006 Date: Thu Mar 7 22:19:00 2019 +0800 add understand how git control version 这样是正常的,毕竟你已经处于 过去 了,当然看不到 未来 的提交记录. 正如影视穿越剧那样,主人公意外穿越过去,总是想要回到未来,怎么办,没有法器没有未来的确切目标怎么行?! git 的穿越剧也需要这样一种法器,能准确告诉时光机把我们带到具体的那个时间点,当然这个时间点不一定是未来时刻,过去时刻也行,反正就是一个准确的坐标. 聪明的你肯定已经猜测到这个任务是由commit 担任的,所有我们现在要找到未来的时间点,也就是commit id,就是那一长串 hash 字符串. 只要当前命令行窗口还没有关闭,慢慢往上翻,总是能找到当初我们的穿越点commit的,即36f234a60d858871f040cb0d7ca3e78251df82f7 回到当初提交 git reset --hard 万事俱备只欠东风,已经成功定位到未来坐标,等待穿越到未来! $ git reset --hard 36f234a60d858871f040cb0d7ca3e78251df82f7 HEAD is now at 36f234a add understand how git control version $ 现在我们再次查看 test.txt 内容: $ cat test.txt git test git init git diff understand how git control versi 果然成功穿越回到未来! 上述穿越回到未来的场景是我们知道目标 commit ,也就是在当前命令行窗口没有关闭的情况下,手动查找穿越点 commit.那如果命令行窗口已关闭或者没办法通过查阅历史命令来定位穿越点 commit 情况下怎么办呢? 这种情况下也是有补救措施的,git 提供了命令历史 git reflog,记录了我们操作的命令历史. 翻阅历史命令 git reflog $ git reflog 36f234a (HEAD -> master) HEAD@{0}: reset: moving to 36f234a60d858871f040cb0d7ca3e78251df82f7 2006f72 HEAD@{1}: reset: moving to HEAD^ 36f234a (HEAD -> master) HEAD@{2}: commit: add understand how git control version 2006f72 HEAD@{3}: commit: add 3 files. eaa4850 HEAD@{4}: commit: add git init 6ad8956 HEAD@{5}: commit (initial): add test.txt 确实记录了我们操作的关键命令,从上述输出结果可以看出,穿越点 commit 正是36f234a60d858871f040cb0d7ca3e78251df82f7,剩下的事情应该不必多说了吧! 小结 HEAD 是当前提交的指针,指向的提交就是当前提交,上一个提交是 HEAD^,上上个提交是 HEAD^^,前100个提交是HEAD~100. git log 查看提交历史,git log --pretty=oneline 简短化输出提交历史. git reflog 查看命令历史,以便我们重拾关键步骤信息. git reset --hard 穿越到指定提交,比如上一个提交就是 git reset --hard HEAD^ . var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/reset.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/concept.html":{"url":"git/usage/concept.html","title":"基本概念","keywords":"","body":"基本概念 了解工作区,暂存区和版本库的区别和联系有助于我们更好理解 git 的工作流程,了解命令的操作意图. git 和其他版本控制系统如 svn 的不同之处就是有暂存区的概念. 基本概念 工作区 | Working Directory 正常情况下能看到的目录(不包括隐藏文件),也就是用户主动创建的目录 暂存区 | Stage 工作区下的隐藏.git目录下的.index文件,因此也称为索引. 版本库 | Repository 工作区下的隐藏目录.git目录 通过前几节我们知道,将文件纳入版本控制,需要分两步操作: 第一步 git add 添加文件,实际上是将文件更改添加到暂存区. 第二步 git commit 提交更改,实际上是将暂存区所有内容提交到当前分支. 我们使用 git init 命令初始化创建 git 仓库时,git 会自动创建唯一一个 master 分支,默认所有操作是在 master 分支上进行的,所以 git commit 就是徃 master 分支上提交更改的. 通俗地讲,文件更改可以多次添加到暂存区,即允许多次执行 git add 命令,然后一次性提交暂存区的全部更改到版本库,即只需要执行一次 git commit 命令即可. 说说个人理解 git 为何分成三部分进行版本控制操作,二部分行不行? 答案是肯定的,没有暂存区概念的 svn 同样可以进行版本控制,所以 git 增加暂存区必然是有存在的意外也就是所谓的好处的. 第一,暂存区的概念允许将本地文件的更改添加进来,也就是说本地文件的更改只有添加到暂存区才能进行下一步的提交更改,所以说那些更改添加到暂存区是由开发者本人决定的,这其实有了一定灵活性,并不是所有的更改都需要被记录! 第二,暂存区作为中间过程,暂存区的内容是打算提交更改的内容,也就是说暂存区可以视为一种临时缓存,用来记录预提交更改.实际工作中,新功能的开发并不是一蹴而就的,是由一系列的更改一起组成的,如果将这些更改分散开来单独提交,那势必会产生很多commit,如果等待全部工作完成再提交的话,解决了过多commit的问题,但是又遇到新问题就是你可能很长时间才能提交一次更改,失去了版本控制的意义.综上所述,暂存区的出现一种很好的解决方案,它允许将相关性代码添加在一起,方便后续提交更改时提交的都是相关性代码! 第三,作为分布式版本控制系统,不像集中式控制系统那样,对网络强相关,失去网络的 svn 是没办法再进行版本控制的,但失去网络的 git 仍然可以进行版本控制,只不过不能远程操作了而已,不过这部分也是无可厚非的,正所谓\"巧妇难为无米之炊\",你总不能要求断网下继续访问百度吧! 好了,我们继续回到 git 常用操作上,看一下工作区,暂存区和版本库三者如何协同工作的. 首先,先修改test.txt文件. # 查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version # 追加 how git work 到 test.txt 文件 $ echo \"how git work\" >> test.txt # 再次查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work $ 紧接着新建newFile.txt 并随便输入内容: # 查看当前文件夹下全部文件 $ ls . file1.txt file2.txt file3.txt test.txt # 创建新文件 newFile.txt $ touch newFile.txt # 再次查看当前文件夹下全部文件 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 输入 add newFile.txt 文件内容 到 newFile.txt 文件 $ echo \"add newFile.txt\" > newFile.txt # 查看 newFile.txt 文件内容 $ cat newFile.txt add newFile.txt $ 现在运行git status 命令查看当前文件状态: $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store newFile.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") $ 从输出结果中得知,test.txt 文件已修改(modified),还没添加到暂存区,而newFile.txt 文件还没被跟踪(Untracked). 现在我们使用git add 命令将 test.txt 和 newFile.txt 都添加到暂存区,再用 git status 查看文件状态: # 添加 test.txt 文件 git add test.txt # 添加 newFile.txt 文件 git add newFile.txt # 查看文件状态 git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: newFile.txt modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store $ 现在输出结果和上次就不一样了,显示的是即将被提交文件,其中newFile.txt 是新文件(new file),test.txt 是修改文件(modified). 所以,git add 命令作用是将需要提交的更改文件临时放到暂存区中,然后执行git commit 命令就可以一次性将暂存区的所有内容提交到当前分支. $ git commit -m \"understand how stage works\" [master a5cd3fb] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 newFile.txt $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 暂存区的所有内容提交到版本库,所以运行git status 时,工作区是干净的,即此时暂存区没有内容了! .DS_Store 是 mac 电脑自动生成的文件,可以暂不理会,等到后面的.gitignore 文件时再处理. 图解 下图展示了工作区,暂存区,版本库之间的关系: 图中左侧是工作区,右侧是版本库,版本库中标记index 的区域是暂存区,标记 master 的是 master 分支所代表的目录树. HEAD 是指向 master 分支的指针,标记 objects 的区域是 git 的对象库,真实路径位于.git/objects目录下,用于表示创建的对象和内容. 意图说明 git add 添加文件 工作区的修改或者新增的文件执行git add 命令后,暂存区(index)的目录树会自动更新,同时引发这次变化的文件内容会被记录下来,即生成对象库(objects)中的新对象,而对象的 id会被记录到暂存区的文件索引(index)中. git commit 提交文件 暂存区的目录树写入到对象库(objects),master 分支的目录树自动更新. git reset HEAD 撤销文件 暂存区的目录树被重写,被master 分支的目录树所替换,但是工作区不受影响. git rm --cached 删除缓存文件 删除暂存区文件,工作区不受影响. git checkout . 检出文件 暂存区的文件替换工作区文件,注意:当前尚未添加到暂存区的改动会全部丢失! git checkout HEAD . 检出文件 HEAD 指针指向的 master 分支中的文件替换暂存区以及工作区文件,注意:不仅清除工作区未提交的改动,连暂存区未提交的改动也会被清除! 小结 以上就是常用命令的背后意图,主要是工作区,暂存区和版本库之间文件同步策略的关系. git add 是工作区更新到暂存区 git commit 是暂存区更新到版本库 git reset HEAD 是版本库更新到暂存区 git checkout -- 是暂存区更新到工作区 git checkout HEAD 是版本库同时更新暂存区和工作区 git rm --cached 清空暂存区 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/concept.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/version-control.html":{"url":"git/usage/version-control.html","title":"版本控制","keywords":"","body":"版本控制 我们知道 git 是分布式版本控制系统,所以称被控制对象是版本本身没错,但是从git 命令中发现,并没有版本这个名词,有的只是commit,所以前几节我一直称其为提交. 为了避免后续教程引发歧义,特意说明,无论是版本也好,提交也罢,都是中文翻译而已,不必太过较真,直接原汁原味称commit也可以啊! 假设你已掌握暂存区的相关概念,简单来说,暂存区就是更改文件的缓存集合,等待一次性全部提交到版本库,正因如此,方便我们批量操作相关性文件,打包提交到版本库,这正是暂存区的独特魅力. 我们反复在说 git 是分布式版本控制系统,分布式的概念已经粗略讲过多次了,下面我们讲一下版本控制,谈谈 git 的版本控制和其他系统的版本控制有什么不同,为什么 git 这么优秀,如此流行? git 跟踪并管理的是更改,而非文件本身.正如linux 一切皆文件,java 一切皆对象一样,git 一切皆更改.新增文件是一个更改,新增文件内容是一个更改,修改文件内容是一个更改,删除文件内容也是一个更改,换言之,git 管理的正是这一个个的更改,并不是文件本身. 下面我们用事实说话,证明 git 管理的是更改而不是文件本身: 第一步,追加 git tracks changes 到 test.txt 文件 # 查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work # 追加 git tracks changes 文件内容到 test.txt 文件 $ echo \"git tracks changes\" >> test.txt # 再次查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes $ 第二步,添加test.txt 文件到暂存区并查看文件状态 $ git add test.txt sunpodeMacBook-Pro:demo sunpo$ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store $ 对于上述内容应该不必再解释了吧,无外乎说test.txt 文件已修改(modified),即将被提交(to be committed). 但是,此时偏偏不提交,继续修改 test.txt 文件:(这种情况实际工作中也有可能出现,比如你正在研发某功能,本以为已经开发完毕,满心欢喜添加到暂存区,然后意外发现一个小bug,分分钟就修复了,时间间隔很短以至于你根本不记得还需要再次添加到暂存区.) 第三步,继续修改文件内容,忘记再次添加到暂存区 # 编辑 test.txt 文件,将 git tracks changes 更改为 git tracks changes of files vim test.txt # 查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files $ 第四步,正常提交暂存区的全部更改到版本库 $ git commit -m \"git tracks changes\" [master 2daa74a] git tracks changes 1 file changed, 1 insertion(+) 此次提交后,我们再看一下文件状态: $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") $ 发现有什么不同吗?以往提交后再次查看文件状态,工作区都是干净的,这次居然提示我们 test.txt 文件已经修改但未添加到暂存区?! 等一下,我们先回忆一下我们的操作流程: 第一次修改(git tracks changes) -> git add -> 第二次修改(git tracks changes of files) -> git commit 这样就很好理解了,git 管理的是更改而不是文件本身,如果是文件本身的话,应该将文件的内容全部提交才对,所以管理的是更改. 第一次修改过后使用 git add 命令将工作区的第一次修改内容放到暂存区准备提交,但是此时工作区发生了第二次修改,注意,这次修改并没有放到暂存区,所以下一步的git commit 命令提交的暂存区内容中自然也就没有第二次修改的内容了!所以git commit 完毕后运行git status命令才会发现此时工作区和暂存区还存在版本差异,即此时工作区不是干净的! 这一次的实验很好理解,工作区的修改需要主动告诉暂存区,暂存区的全部更改再提交到版本库.所以版本库的提交取决于暂存区,而暂存区又取决工作区是否主动将更改添加进去了吗! 理论再多不如亲身体验,让我们直接比较一下工作区和版本库的差异吧! # 比较 test.txt 文件在工作区和版本库的差异 $ git diff HEAD -- test.txt diff --git a/test.txt b/test.txt index d31bdd2..56c76b7 100644 --- a/test.txt +++ b/test.txt @@ -3,4 +3,4 @@ git init git diff understand how git control version how git work -git tracks changes +git tracks changes of files $ 由此可见,工作区比版本库多了git tracks changes of files,少了git tracks changes,所以说第二次修改内容 git tracks changes of files 并没有被提交. 现在我们再解释一下-git tracks changes 和 +git tracks changes of files 的问题: 首先查看工作区 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files $ 根据上述分析,我们知道第一次的修改git tracks changes 已被提交到版本库,第二次的修改git tracks changes of files 没有被提交而是继续留在工作区. 因此,可以推断出目前版本库的文件应该是这样的: git test git init git diff understand how git control version how git work git tracks changes 既然如何,工作区和版本库相比岂不刚好是少了一个git tracks changes,多了git tracks changes of files,其余文件内容完全相同! 透过现象看本质,已经分析了现象也解释了产生现象的原因,是时候分析一下本质了. 抛出问题:因为git tracks changes of fiels 和 git tracks changes 被视为不同的更改,所以才会造成上述现象.如果git tracks changes of fiels 被认为是git tracks changes + of fiels 两者叠加产生的更改,还会产生上述现象吗? 答案是否定的,如果两个更改可以叠加的话,按照版本控制的思路,第二次的修改即便没有提交也只是 of fiels 没有加入到版本库而已,如此一来,工作区和版本库的差异将不再是少了一个git tracks changes,多了git tracks changes of files,而仅仅是多了of files! 由此可见,git 版本控制系统其实是全量更新的思维模式,并不是差量更新模式. 小结 工作区的更改需要git add 添加到暂存区,git commit 将暂存区的全部更改提交到版本库. 工作区,暂存区,版本库三者既相关独立又密切关联,三者是传递性依赖的关系. git 版本控制的是文件的更改,而不是文件本身,是全量更新模式,而不是差量更新模式. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/version-control.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/checkout-reset.html":{"url":"git/usage/checkout-reset.html","title":"撤销更改","keywords":"","body":"撤销更改 相信你已经了解了 git 的基本概念,也清楚了工作区,暂存区和版本库的关系,现在让我们用所学的知识继解决实际问题吧! 背景 正常看得见的目录是我们最为熟悉的工作区,在工作中不可能总是100%的精力,难免会犯错,尤其是下午犯困,晚上加班更是如此.下面列举了常见的一些场景 场景一: 工作区出现意外更改且尚未添加到暂存区 北京时间现在是晚上10点钟,你正在赶制一份工作报告,尽管心中一万个不愿意,还是不得不做. 开始模拟意外更改前,先查看一下 test.txt 文件相关信息: # 列出当前目录的文件 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 查看 `test.txt` 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files # 查看 `test.txt` 文件状态 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") # 查看 `test.txt` 文件差异 $ git diff diff --git a/test.txt b/test.txt index d31bdd2..56c76b7 100644 --- a/test.txt +++ b/test.txt @@ -3,4 +3,4 @@ git init git diff understand how git control version how git work -git tracks changes +git tracks changes of files $ 还记得在上一节中我们讲解 git 版本控制的到底是什么,为了证明 git 管理的是更改而不是文件本身,我们特意在第二次更改时没有添加到暂存区,现在我们先把这个遗留问题解决掉. # 工作区更改添加到暂存区 $ git add test.txt # 暂存区内容提交到版本没哭 $ git commit -m \"git tracks changes of files\" [master b7bda05] git tracks changes of files 1 file changed, 1 insertion(+), 1 deletion(-) # 查看文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 现在正在加班加点干活,一不小心将心中的不满表露出来了,于是有了下面的内容: # 意外更改正是这么犯傻的一句话 $ echo \"My stupid boss still prefers svn\" >> test.txt # 当前文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files My stupid boss still prefers svn $ 虽然强打精神,可还是很困,于是打算喝杯咖啡提提神,猛然发现 stupid boss 可能会让你丢掉这个月的奖金! 暗自庆幸,咖啡果然是个好东西,既然发现了问题,那就事不宜迟赶紧修复,因为不适宜的话正是 stupid boss ,所以你完全可以手动删除,但是假如你说了一大堆不合适的话,或者复制粘贴时弄错了,这就不是删除一两行那么简单了! 既然手动解决比较麻烦,那git 有没有什么好方法来解决这类问题呢?在寻求git 帮助前,首先再看一下当前文件状态(git status).正所谓\"知己知彼方能百战百胜\",还是看一眼吧! # 查看文件状态 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git 不负众望,果然给了我们希望,(use \"git checkout -- ...\" to discard changes in working directory) 这句话的告诉我们可以丢弃工作区的更改! 脑海中在快速回忆一下工作区,暂存区,版本库三者之间的关系,其实git checkout -- 命令的意思是用暂存区的内容替换掉工作区内容,因此也就是丢弃掉工作区的更改了. 事不宜迟,运行 git checkout -- 命令试试看吧: # 丢弃工作区的更改 $ git checkout -- test.txt # 查看文件内容: My stupid boss still prefers svn 终于不见了 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files # 查看文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 一顿操作猛如虎,撤销掉意外更改,回到上一次版本控制状态,世界如此美好... 注意: git checkout -- 中的 -- 至关重要,没有它就是切换分支了! 场景二: 工作区出现意外更改且已经添加到暂存区,但尚未提交到版本库 时间一分一秒过去了,转眼间已经11点了,假设你不但写了一些胡话,还添加到暂存区了(git add).可想而知,这次意外比场景一要糟糕. # 模拟正常提交(不然岂不是从场景一到场景二你什么都没做,那还能叫做赶制工作报告吗?!) $ echo \"someone prefers svn,but i don't care it\" >> test.txt $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it $ git add test.txt $ git commit -m \"normal commit\" [master ab1cbd2] normal commit 1 file changed, 1 insertion(+) # 意外更改的前夕 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it # 意外更改内容: my teammate is stupid too. $ echo \"my teammate is stupid too.\" >> test.txt $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it my teammate is stupid too. # 意外操作: 将意外更改内容提交到暂存区 $ git add test.txt 不过庆幸的是,在提交到版本库(git commit)之前及时发现问题,还是看一下现在的文件状态(git status)吧! # 查看文件状态: 救命稻草 (use \"git reset HEAD ...\" to unstage) $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store $ git 同样告诉我们,可以使用 git reset HEAD 命令撤销暂存区更改. 其实 git reset HEAD 命令是用版本库的内容替换掉暂存区的内容,也就是说原来暂存区的内容已被丢弃了! 所以说这个命令并不会影响工作区内容,不如我们现在再看一眼工作区内容,方便执行 git reset HEAD 命令后证实我们的结论. # 查看文件内容: my teammate is stupid too. $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it my teammate is stupid too. $ 迫不及待执行 git reset HEAD 命令,先睹为快! # 救命稻草: 版本库内容替换掉暂存区内容 $ git reset HEAD test.txt Unstaged changes after reset: M test.txt # 效果: 目标文件已修改但未添加到暂存区 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") # 目标文件内容: 仍然保持不变 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it my teammate is stupid too. $ 现在场景二已经退化成场景一了,目标文件发生意外更改但还没添加到暂存区,如何撤销工作区更改,请参考场景一方法. 提示: git checkout -- test.txt 场景三: 工作区出现意外更改不仅已添加到暂存区,还已提交到版本库,但尚未推送到远程仓库 时间不紧不慢地已经到凌晨了,困意越来越浓,洋洋洒洒写下几千字的工作报告,总算是写完了,添加到暂存区(git add),提交到版本库(git commit)一气呵成,等等,好像有什么不对劲,难免会犯糊涂,这不又发生意外了! # 衔接场景二 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it # 正常提交一 $ echo \"i love working,work makes me happy\" >> test.txt $ git add test.txt $ git commit -m \"encourage myself\" [master a44cf7a] encourage myself 1 file changed, 1 insertion(+) # 正常提交二 $ echo \"fix 110 bugs,so happy\" >> test.txt $ git add test.txt $ git commit -m \"fix bugs\" [master c66399d] fix bugs 1 file changed, 1 insertion(+) sunpodeMacBook-Pro:demo sunpo$ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) # 意外更改: hate to work overtime $ echo \"hate to work overtime\" >> test.txt $ git add test.txt $ git commit -m \"test.txt\" [master c965724] test.txt 1 file changed, 1 insertion(+) $ 天妒英才,加班加点做事情,本想赢得老板的赏识,没想到最后一句话\"hate to work overtime\"让所有的努力都付之一炬,怎么办? 死马当活马医,还是照例看看git status 能提供什么建议吧! $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 没有提供任何意见能帮助我们撤销意外更改,先别慌,容我深思三秒钟... 既然意外更改已经提交到版本库,那么应该用什么内容替换版本库内容呢?有了,既然最新版本库不可用,那上一个版本库内容可用的啊,完全可以用上一个版本库内容替换最新版本库内容,真乃\"天生我材必有用\"! # 当前文件内容: 闯祸的\"hate to work overtime\" $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it i love working,work makes me happy fix 110 bugs,so happy hate to work overtime # 版本回退: 回到过去假装什么都没发生过 $ git reset --hard HEAD^ HEAD is now at c66399d fix bugs sunpodeMacBook-Pro:demo sunpo$ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) # 岁月静好,一切似乎都没发生过 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it i love working,work makes me happy fix 110 bugs,so happy # 当前文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 详情请参考回到过去,时空穿越之旅就是这么方便哈! 提示: git reset --hard HEAD^ 场景四: 工作区出现意外更改不仅已添加到暂存区,还提交到版本库,还已推送到远程仓库 场景一到场景三都是本地仓库,所有的文件更改只能本机访问,小伙伴也好,上级领导也罢都无法查看到你本地更改,但是一旦你推送到远程仓库了,那么其他人就能查看你的更改了! 正常的提交更改还好,怕就怕这种\"stupid boss\"被领导看到就不好了,那应该怎么办?暂时还是自求多福吧! 小结 丢弃工作区更改: git checkout -- 丢弃暂存区更改: git reset HEAD 丢弃本地版本库更改: git reset --hard HEAD^ 丢弃远程版本库更改: 自求多福 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/checkout-reset.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/delete.html":{"url":"git/usage/delete.html","title":"删除文件","keywords":"","body":"删除文件 回忆一下文件的常见操作,新增文件,修改文件,删除文件等,新增和修改文件都单独讨论过,现在我们来研究一下如何删除文件. 你可能会说删除文件还不简单啊,直接 rm -rf 即可,但是这仅仅是本地文件被删除了,对于 git 来说,文件并没有被删除. 还记得我们开篇介绍git 时就说过,一切操作皆版本 ,对于新增是一个版本,修改也是一个版本,就连删除都是一个版本. 下面让我们看一下 git 中如何删除文件吧! 背景 # 查看当前文件列表 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 新建待删除文件 $ touch delete.txt # 再次查看当前文件列表,确保新建文件成功 $ ls delete.txt file2.txt newFile.txt file1.txt file3.txt test.txt # 查看当前文件状态: 新文件 `delete.txt` 还没被跟踪 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store delete.txt nothing added to commit but untracked files present (use \"git add\" to track) # 添加新文件 `delete.txt` $ git add delete.txt # 查看文件状态: 已添加到暂存区,待提交到版本库 $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: delete.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store # 提交新文件 `delete.txt` $ git commit -m \"add delete.txt\" [master 7df386a] add delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 delete.txt # 再次查看文件状态: 已经没有新文件 `delete.txt` 的更改信息 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 以上操作,我们简单创建 delete.txt 文件,添加(git add)并提交(git commit) 该文件,完成准备工作后,开始删除文件! # 删除前文件列表 $ ls delete.txt file2.txt newFile.txt file1.txt file3.txt test.txt # 删除刚刚创建的文件 `delete.txt` $ rm delete.txt # 删除后文件列表 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 当前文件状态: `delete.txt` 文件已被删除,且未添加到暂存区 $ git status On branch master Changes not staged for commit: (use \"git add/rm ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) deleted: delete.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") $ 本地删除 delete.txt 文件后,再次查看文件状态 git status 发现 git 给了我们两条建议,其中一条 git checkout -- 我们很熟悉,就是丢弃工作区的更改,此时此景下如果丢弃删除操作,相当于撤销删除,难怪说删除也是一个版本呢! 现在我们重点来看第一条建议 git add/rm ,rm 是 remove 单词的缩写,即删除文件. # 删除文件 $ git rm delete.txt rm 'delete.txt' # 查看文件状态: `delete.txt` 文件待提交 $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) deleted: delete.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store # 提交文件 $ git commit -m \"remove delete.txt\" [master 6298070] remove delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 delete.txt # 再次查看文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 删除文件和添加文件类似,都是一次commit ,本地文件的任何更改都要添加到暂存区,然后提交到版本库. 小结 删除文件和新增文件类似逻辑,git rm 删除文件后,依然需要 git commit 提交版本. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/delete.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/remote-repository.html":{"url":"git/usage/remote-repository.html","title":"远程仓库","keywords":"","body":"远程仓库 如果说本地仓库已经足够个人进行版本控制了,那么远程仓库则使多人合作开发成为可能. 如果你只是打算自己使用git,你的工作内容不需要发布给其他人看,那就用不到远程仓库的概念. git 是分布式版本控制系统,分布式意味着同一个git 仓库 可以部署在不同的机器上,正如\"鸡生蛋蛋生鸡\"问题一样,不论如何,先要有一个原始仓库,然后才能分布到其他机器上去. 充当原始仓库的机器要有一个特点那就是24h 开机且大家都能访问到,这个概念类似于\"中央服务器\".这样一来大家都可以从\"中央服务器\"下载最新代码,克隆到本地,本地发生更改后再推送给\"中央服务器\".如此一来,大家交流方便很多,轻松实现文件内容的共享. 这种\"中央服务器\"比较有名的是国外的网站 github,当然国内也有不少类似服务.像这种\"中央服务器\"也可以自己搭建,现阶段搭建的话简直就是\"杀鸡焉用牛刀\"! 背景 关于如何注册配置相关请参考 github 教程 为了和上述教程保持一致,项目名git-demo,先看一下当前工作区状态: # 查看文件列表 $ ls LICENSE README.md test.txt # 查看文件内容 $ cat test.txt add test.txt 现在测试一下本地更改能否推送到远程仓库,先在本地文件 test.txt 随便写点东西,然后添加(git add),提交(git commit),最后推送到远程仓库(git push origin master). # 写入新的内容并提交到本地仓库 $ echo \"see https://snowdreams1006.github.io/git/usage/remote-repository.html\" >> test.txt $ git add test.txt $ git commit -m \"see https://snowdreams1006.github.io/git/usage/remote-repository.html\" [master b3d8193] see https://snowdreams1006.github.io/git/usage/remote-repository.html 1 file changed, 1 insertion(+) # 推送到远程仓库 $ git push origin master Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 359 bytes | 359.00 KiB/s, done. Total 3 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), completed with 1 local object. To github.com:snowdreams1006/git-demo.git 8e62564..b3d8193 master -> master $ 命令行没有报错证明我们已经成功推送到 github,现在登录 github 看一下有没有刚才我们提交的新内容. 现在本地版本库和远程版本库已经能够正常建立关联了,此刻起将不再是独自一人在战斗! 小结 创建已有本地仓库和远程仓库的关联 # 添加远程仓库关联 git remote add origin git@github.com:username/repos.git # 首次推送 master 分支的全部内容 git push -u origin master # 后续推送 master 分支的最新更改 git push origin master 从已有远程仓库克隆到本地仓库 # 克隆远程仓库到本地仓库 git clone git@github.com:username/repos.git # 推送 master 分支的最新更改 git push origin master var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/remote-repository.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/branch-manage.html":{"url":"git/usage/branch-manage.html","title":"分支管理","keywords":"","body":"分支管理 背景 什么是分支?简单地说,分支就是两个相对独立的时间线,正常情况下,独立的时间线永远不会有交集,彼此不知道对方的存在,只有特定情况下,两条时间线才会相遇,因为相遇,所以相知,因为相知,所以改变! 正如分支对于科幻电影来说是一个很好的卖点,关于分支的话题完全可以开启新的题材,对于这点相信不少科幻迷都深有体会,不必赘述. 回归正题,分支对于版本控制系统又意味着什么呢?实际工作中,我们大多作为一个团队一起合作开发项目,如果是独立开发者,只有一个人的话,其实用不到分支的概念,甚至远程仓库也用不到.所以下述情况针对的都是团队开发情况. 作为团队中的一员不论是项目领导还是项目成员,都需要了解并掌握分支的一般概念和常用操作.如果你刚好是实际开发的程序猿,上级领导分派一个新功能,预期两个星期内才能完成,其他同事也是如此,每个人都有自己的任务.接收任务就要开始干活,第一天工作开了一个头,还留下一大堆的 TODO 标记,此时你照例运行 git add ,git commit 等命令,学会上节的git push origin master 你知道了本地仓库和远程仓库的概念,你想将你的工作成果分享给其他人就要推送到远程仓库,这样其他人才能可见,等一等,别急! 首先明确的是,这个完整功能至少需要2个星期才能基本完成啊,你现在刚刚起了个头还没完成呢!你要是真的推送到远程仓库了,那其他人是不是有理由认为你这部分功能已完成?那你可能会反驳说,我可以在工作群吼一声,说这个功能还没完成,大家别着急使用哈!这样确实可以,很长一段时间内其他人必须无视你的代码,只有等你的功能基本可用时,等你再吼一声,别人才会去使用你的代码.粗略一看,好像并没有什么问题?! 实际上这种情况是存在很大风险的,因为未完成未经过测试的代码可能会产生大量意外 bug,严重的话,甚至影响整个系统,到时候由于你的未完成代码导致别人项目都无法运行,那别人还怎么工作,这个责任是谁负责? 所以,为了不给其他人造成麻烦,最好不要把未完成工作直接暴露到别人面前,那长时间提交又可能会造成丢失更改的风险,此时此景,平行时间线应用而生! 从接手新功能的时间点开始,创建一条新的时间线,于是新功能的开发完全在新的时间线上进行,至于其他人是否开启新的时间线那就不是我们能控制得了,我们能做到的就是不给其他人制造麻烦,如果其他人给我们制造麻烦的话,那我们就去上级领导那告他一状,哈哈! 等功能开发差不多时,你再想办法切换到原来的时间线上并将开发时间线的更改顺便都带过来,这样一来,别人虽然看不到你的开发时间线,但是看到了你离开的这段时间原来做了这么多的更改啊! 现在用git的专业术语再解释一遍上述场景: 接手新功能的时刻开始,创建一个开发分支(既可以是本地分支也可以是远程分支),以后新功能的开发全部在开发分支上完成,处于开发分支上你可以照常运行 git add ,git commit 等命令,不用担心丢失更改.等工作一段时间后,终于完成了新功能,是时候让新功能展示给其他同事了.此时再切换到原来的主干分支,在主干分支上合并开发分支,现在主干分支上已经有新功能了,这样一来,其他同事突然发现你已经偷偷地完成了新功能的开发! 不仅 git 有分支概念,其他版本控制系统比如 svn 也有分支概念,基本概念和常用操作类似,只不过 git 更强大,创建分支,切换分支,合并分支等功能十分强大,效率太高! (svn 创建分支,切换分支等操作简直慢到可以喝一杯茶了,分支管理都快成摆设了!) 建议 开发新功能时尽量创建自己的分支,不要给其他人造成麻烦 分配任务时要求项目成员创建各自分支,等时机成熟时再合并到主干分支 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/branch-manage.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/branch-overview.html":{"url":"git/usage/branch-overview.html","title":"分支总览","keywords":"","body":"分支总览 分支就是一条独立的时间线,既有分支,必有主干,正如一棵树谈到树枝,必有树干一样的道理.我们先前对git 的全部操作默认都是在主干上进行的,这个主干也是一种特殊的分支,名为 master 分支. 无论是穿越历史还是撤销更改,我们都或多或少接触过时间线,git 管理的版本串在一起就组成了这个时间线,其中master 分支是当前分支,HEAD 指向master ,因此HEAD 相当于指向了最新的版本. 基于分支上的操作,每一次 commit 都会提交一个新版本,并且新的 commit 指向原来的 commit,这来最新的 commit 就可以往前找,直到找到最初的commit.这就是 git 的时间线. 当我们打算开辟新的时间线时,git 在当前 HEAD 指向的 master 分支的 commit 处新建一个 dev 分支.如果主角没有主动进入时间线的话,那么仍然处于 master 分支,进入的方法就是 HEAD指向新建的 dev 分支. 不考虑孙悟空的分身特效,主角不能同时处于不同的时空下,git 也是如何,HEAD 只能指向某一个 commit ,既然刚刚已经指向了 dev 分支,所以原来的 master 分支就没有 HEAD 了,因为相当于master 分支静止了. 当主角在 dev 分支独自闯荡干出一番事业时,决定回到故乡 master 分支,并将出门在外所学的本领带回家乡,建设美好家园.master 分支因为合并了 dev 分支,所以一下子增添了很多内容,家乡焕然一新! 主角这次携带 dev 分支归来,HEAD 分支自然又回到了 master 分支上,年轻的心向往外面的世间,相信不久后还会有同样的故事发生... 下面详解分支相关命令 创建分支 创建 dev 分支,列出分支已验证是否创建成功 # 创建分支 $git branch dev # 列出分支 $ git branch dev * master $ * master 前面的 * 标记表明当前仍然处于 master 分支 切换分支 切换到新分支以便在分支上开展工作 # 切换分支 $ git checkout dev Switched to branch 'dev' # 列出分支 $ git branch * dev master $ 现在,我们在 dev 分支上奋笔疾书,先后提交两个版本后完成分支开发工作: # 查看当前文件列表 $ ls LICENSE README.md test.txt # 查看目标文件内容 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html # 第一个版本: learn git branch $ echo \"learn git branch\" >> test.txt $ git add test.txt $ git commit -m \"learn git branch\" [dev 9c30e50] learn git branch 1 file changed, 1 insertion(+) # 第二个版本: see https://snowdreams1006.github.io/git/usage/branch-overview.html $ echo \"see https://snowdreams1006.github.io/git/usage/branch-overview.html\" >> test.txt $ git add test.txt sunpodeMacBook-Pro:git-demo sunpo$ git status On branch dev Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt $ git commit -m \"see https://snowdreams1006.github.io/git/usage/branch-overview.html\" [dev 413a4d1] see https://snowdreams1006.github.io/git/usage/branch-overview.html 1 file changed, 1 insertion(+) 此时,再从 dev 分支切换回 master 分支,合并dev分支前看一下当前文件内容: # 切换回 master 分支 $ git checkout master Switched to branch 'master' Your branch is up to date with 'origin/master'. sunpodeMacBook-Pro:git-demo sunpo$ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean # 查看当前文件列表 $ ls LICENSE README.md test.txt # 查看文件内容: 无 dev 分支更改 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html $ 合并分支 切换回 master 分支并没有我们在 dev 分支的更改,因为两条时间线是独立的,现在合并 dev 分支,再看一下当前文件内容: # 合并 dev 分支 $ git merge dev Updating b3d8193..413a4d1 Fast-forward test.txt | 2 ++ 1 file changed, 2 insertions(+) # 查看文件内容: 已经存在 dev 分支的更改! $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/ 删除分支 合并分支后,dev 分支的历史使命已经完成,应该及时清空不必要分支. # 删除 dev 分支 $ git branch -d dev Deleted branch dev (was 413a4d1). # 列出当前分支: 只剩下 master 分支 $ git branch * master $ 以上场景包括了分支的常用操作,创建分支(git branch ),切换分支(git checkout ),删除分支(git branch -d )一系列操作十分流畅,因此 git 鼓励我们大量使用分支! 小结 列出分支 git branch 创建分支 git branch 切换分支 git checkout 创建并切换分支 git checkout -b 合并指定分支到当前分支 git merge 删除分支 git branch -d var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/branch-overview.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/branch-merge-with-conflict.html":{"url":"git/usage/branch-merge-with-conflict.html","title":"冲突合并","keywords":"","body":"冲突合并 如果足够幸运的话,团队成员互不影响,彼此相安无事,大家各自基于 master 分支的某个 commit 创建自己的分支,平时在分支上独立工作,等到一段时间后再合并 merge 到 master 分支,这样一样 master 作为各个功能的集大成者,最终完成项目. 然而事情总不是一帆风顺的,团队协作时由于意见不同,遇到冲突简直是家常便饭,既然无法回避冲突,当冲突发生时如何应该呢? 背景 基于 master 分支上的某个 commit ,新功能由此继续开发: echo \"git commit c1\" >> test.txt $ git add test.txt $ git commit -m \"git commit c1\" 新功能分支命名为 feature ,使用git checkout -b 创建分支并切换: $git checkout -b feature Switched to a new branch 'feature' $ 在新功能 feature 分支上开发新功能,并提交: $ echo \"git commit c2\" >> test.txt $ git add test.txt $ git commit -m \"git commit c2\" [feature 0fe95f8] git commit c2 1 file changed, 1 insertion(+) $ 无论新功能 feature 是否开发完毕,团队的其他成员均有可能处于 master 分支并做相应更改: $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 3 commits. (use \"git push\" to publish your local commits) 其他成员对新功能有着自己的看法,于是也提交了版本,由于我们之前提交的是 git commit c2,而此时master 分支提交的是git commit c3,显然我们两个人的意见不一致! $ echo \"git commit c3\" >> test.txt $ git add test.txt $ git commit -m \"git commit c3\" [master 0949cc3] git commit c3 1 file changed, 1 insertion(+) $ 正在此时,feature 分支的新功能已开发完毕并主动切换回 master 分支,准备合并 feature 分支. # 合并 feature 分支 $ git merge feature Auto-merging test.txt CONFLICT (content): Merge conflict in test.txt Automatic merge failed; fix conflicts and then commit the result. $ 由于项目成员沟通不畅或者意见不一致,导致了代码冲突,git 作为版本控制系统,自然无法解决这类问题,总不能擅自做主抛弃后来的更改吧或者抛弃分支更改?所以 git 只负责抛出问题,等待我们程序员去解决问题. 既然是人的问题,那我们看一下我们到底是哪里不一致,为什么会产生冲突? # 查看状态 $ git status On branch master Your branch is ahead of 'origin/master' by 4 commits. (use \"git push\" to publish your local commits) You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add ...\" to mark resolution) both modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") # 比较差异 $ git diff diff --cc test.txt index 6e00f87,0f95fd7..0000000 --- a/test.txt +++ b/test.txt @@@ -3,4 -3,4 +3,8 @@@ see https://snowdreams1006.github.io/gi learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 ++>>>>>> feature 和我们预期一样,test.txt 文件产生了冲突,当前 HEAD 指向的提交即 master 分支是 git commit c3 ,而 feature 分支是 git commit c2,对于同一个文件的同一行内容发生不同的更改,git 不知道也不应该知道如何处理. # 查看内容 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 >>>>>> feature git 用 标记一个分支冲突开始,======= 标记分支分割线,>>>>>>> 标记另一个分支结束. 经过冲突双方的讨论后,彼此间达成妥协,决定修改成git commit c2 and c3 ,修改后继续提交: # 编辑冲突文件,按照协商一致的内容修改文件 $ vim test.txt # 将冲突内容更改为 git commit c2 and c3 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 $ git add test.txt $ git commit -m \"fix conflict\" [master 3b8f434] fix conflict 冲突已经解决,现在回顾一下提交历史,使用git log --graph 图形化展示提交历史: # 查看提交日志 $ git log --pretty=oneline --graph * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 (HEAD -> master) fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b (feature) git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 最后,删除新功能分支 feature ,不用的分支及时清理干净,需要时再创建分支. $ git branch -d feature 小结 无法杜绝冲突的发生,代码上的冲突本质上是人为因素造成的冲突. 解决冲突需要有关双方协商解决,不可能独自解决冲突,除非你抛弃自我,完全以对方为准. 使用 git log --graph 命令可以图表化查看提交历史,抑或 git log --pretty=oneline --graph var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/branch-merge-with-conflict.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/branch-strategy.html":{"url":"git/usage/branch-strategy.html","title":"分支策略","keywords":"","body":"分支策略 默认情况下合并分支常常直接使用 git merge 命令,是最方便快速的合并方法.其实这种情况下 git 采用的是 fast forward 模式,特点是删除分支后,会丢失分支信息,好像从来没存在该分支一样,而我们推荐的是recursive 模式,能够保留分支的版本记录. 递归模式(recursive) 创建并切换 dev 分支,提交版本后切换回 master 分支,然后再合并 dev 分支,这不过这一次不再使用 git merge dev 命令: # 创建并切换 dev 分支 $ git checkout -b dev Switched to a new branch 'dev' # 提交版本 $ echo \"git checkout -b dev\" >> test.txt $ git add test.txt $ git commit -m \"git checkout -b dev\" [dev 44d68f6] git checkout -b dev 1 file changed, 1 insertion(+) # 切换回 master 分支 $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 6 commits. (use \"git push\" to publish your local commits) $ 现在添加 --no-ff 参数禁用 fast forward 模式,即git merge --no-ff: $ git merge --no-ff -m \"git merge --no-ff dev\" dev Merge made by the 'recursive' strategy. test.txt | 1 + 1 file changed, 1 insertion(+) $ 上述内容显示,这次使用的不再是 fast forward 模式,而是 recursive 模式,那让我们看一下提交历史有什么不同吧! $ git log --pretty=oneline --graph * 22fbef71b7575cd7eb7911079551618667f9f38f (HEAD -> master) git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c (dev) git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 这种递归模式(recursive) 有一个明显的特点就是会产生一个新的 commit ,并不会像之前快速前进模式(fast forward)那样单纯更改 HEAD 的指向. 秉承着阅后即焚的习惯,分支一旦合并后就立即删除,现在删除 dev 分支,看一下会发生什么: # 删除 dev 分支 $ git branch -d dev Deleted branch dev (was 44d68f6). # 查看提交历史 $ git log --pretty=oneline --graph * 22fbef71b7575cd7eb7911079551618667f9f38f (HEAD -> master) git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 由此可见,删除 dev 分支后仅仅少了 dev 的引用而已,原来 dev 分支所做的更改全部保留下来了! 快速前进模式(fast forward) 创建并切换 dev 分支,提交版本后切换回 master 分支,然后再合并 dev 分支,使用 git merge dev 命令: # 创建并切换 dev 分支 $ git checkout -b dev Switched to a new branch 'dev' # 提交版本 $ echo \"fast forward\" >> test.txt $ git add test.txt $ git commit -m \"fast forward\" [dev 3fe94c0] fast forward 1 file changed, 1 insertion(+) $ 现在切换回 master 分支,采用默认的git merge 命令合并 dev 分支: $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 8 commits. (use \"git push\" to publish your local commits) sunpodeMacBook-Pro:git-demo sunpo$ git merge dev Updating 22fbef7..3fe94c0 Fast-forward test.txt | 1 + 1 file changed, 1 insertion(+) $ 上述内容显示这次合并采用的是快速前进模式(fast forward),让我们看一下提交历史: $ git log --pretty=oneline --graph * 3fe94c0088cae526eda1fb2ffa303001b1eb42ba (HEAD -> master, dev) fast forward * 22fbef71b7575cd7eb7911079551618667f9f38f git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 上述内容表明,此次合并并没有产生新的 commit ,只是更改下 HEAD 指向而已(HEAD -> master, dev). 同样,现在删除 dev 分支,再看一下提交历史: # 删除 dev 分支 $ git branch -d dev Deleted branch dev (was 3fe94c0). # 查看提交历史 $ git log --pretty=oneline --graph * 3fe94c0088cae526eda1fb2ffa303001b1eb42ba (HEAD -> master) fast forward * 22fbef71b7575cd7eb7911079551618667f9f38f git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 由此可见,快速前进模式一旦删除分支后就彻底丢失了分支的信息,即便是从提交历史中也找不到曾经存在的痕迹! 分支策略 git 是分布式版本控制系统,同时鼓励大量使用分支,如此一来大量的分支该如何管理? 实际开发中,建议准从以下原则进行分支管理: master 分支作为主干分支,负责对外提供服务,要求稳定可靠,因为应该专人负责更新维护. dev 分支作为开发分支,取代 master 分支的开发地位,积累到一定产出时再合并到 master 分支. feature 分支作为新功能分支,根据实际情况动态创建,删除分支,并适时合并到 dev 分支. bugFixed 分支作为修复特定 bug 分支,可能由 master 分支衍生而来,也可能由 dev 分支衍生等等,修复后及时合并到原分支. custom 自定义分支,项目成员私有分支,由上级领导分配任务后各开发人员自行选择创建自己的分支,并根据实际情况决定合并到 dev 分支或 feature 等分支. 小结 快速前进模式(git merge )不保留分支合并历史,递归模式(git merge --no-ff -m )保留分支合并历史. 制定大家都认同的分支管理原则,并严格准守规则. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/branch-strategy.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/branch-emergency-fixbug.html":{"url":"git/usage/branch-emergency-fixbug.html","title":"紧急修复","keywords":"","body":"紧急修复 和往常一样,每个人团队开发者都在自己的本地分支上进行日常工作,相互独立又相互联系,一直以来相安无事,可是某天下午,上级领导突然急冲冲的打电话告诉你线上出bug了,需要你紧急修复,下班之前必须解决! 我们天生就是创造 bug 的特殊群体,每天都在和各种各样的 bug 打交道,早已经习惯了这样的工作节奏,再也没有当初刚刚遇到紧急问题的手足无措,先喝杯茶,冷静一下,然后汇报领导说:放心吧!保证30min 内解决问题! 背景 学习了分支操作的相关知识,团队内部就基本的开发流程达成一致: 假设线上是主干 master 分支,开发是 dev 分支,团队成员是自定义 custom 分支,平时开发时在大家在各自 custom 分支上工作,完成分配任务后再合并到开发 dev 分支,等到开发分支功能稳定后,由项目领导负责合并到主干分支 master . 上述流程只是开发流程的简化版,实际情况更加复杂,后续再介绍 gitflow 工作流相关知识. 由于是线上出现 bug,理所当然是基于 master 分支检出临时分支,修复分支代号为 issue-110,然后定位 bug 并提交,最后再合并到 master 分支,如此一来成功修复 bug,完成既定任务,心安理得准备下班回家! 如果真的向上述步骤那样操作,显然还不够冷静,刚才那一杯茶算是白喝了!因为这样操作可能会丢失现场数据,那很多工作岂不是白做了,下面简单演示一下: 错误示例 (一). 事发前正在自定义的 snow 分支上愉快编码中... # 线上分支 `master`,开发分支 `dev`,自定义分支 `snow`,当前正处于自定义分支 $ git branch dev master * snow # 接到领导电话前正在自定义 `snow` 分支上进行愉快编码中... $ echo \"Happy coding\" >> test.txt $ git add test.txt $ git commit -m \"Happy coding\" (二). 事发时直接检出主分 master 分支,并紧急修复 bug . (2.1) 基于 master 分支检出 issue-110 分支,并修复提交. # 注意: 事发时正在思考人生,此时更改尚未添加到暂存区! $ echo \"who am i\" >> test.txt # 当前情况下,默认不允许直接切换到其他分支,因为工作区更改会被重写,这里为了演示错误示例,强制切换! $ git checkout -f master # 基于主干 `master` 分支检出修复 `issue-110`分支 $ git checkout -b issue-110 Switched to a new branch 'issue-110' # 定位线上 `bug`并修复,假设将 `fast forward` 更改为 `fast forward not recommend`,瞬间修复 `bug`有没有! $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward $ vim test.txt $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward not recommend # 修复 `bug` 后,提交更改并备注已修复 $ git add test.txt $ git commit -m \"fix bug about issue-110\" [issue-110 e60c8ad] fix bug about issue-110 1 file changed, 1 insertion(+), 1 deletion(-) sunpodeMacBook-Pro:git-demo sunpo$ git status On branch issue-110 nothing to commit, working tree clean $ (2.1) 切换到主干 master 分支,并合并修复 issue-110 分支 # 切换回 `master` 分支,合并修复 `issue-110` 分支 $ git checkout master Switched to branch 'master' Your branch is up to date with 'origin/master'. $ git merge issue-110 Updating 3fe94c0..e60c8ad Fast-forward test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) # 验证 `bug` 已修复: 更改为 `fast forward not recommend` $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward not recommend $ (三). 事发后切换回自定义 snow 分支,打算下班回家. # 切换回 `snow` 分支,发现丢失了事发前的未保存更改:`who am i` $ git checkout snow Switched to branch 'snow' $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward Happy coding $ 现在还打算下班吗?你所做的更改因为没有提交或者不能提交造成全部丢失! 结果 因为手头工作进行到一半无法提交或者忘记提交等原因,为了临时修复紧急 bug 而直接切换到目标分支再回来时发现更改全部丢失,相当于那部分工作白忙活了! 正确示例 经过上述错误示例的惨痛教训后,再也不敢轻易切换分支了,原因在于工作区更改并没有被提交,或者说不能提交,如果能够有一种机制来保护案发现场,这样我们就能放心切换到其他分支工作,回来时一切如初,那该多好? 幸运的是,git 确实提供这么一种机制,git stash 命令临时存储工作区,类似\"草稿箱\"作用. (一). 恢复工作区丢失更改,并使用 git stash 命令保存现场. # 修复工作区丢失更改: 同样未添加到暂存区 $ echo \"learn git stash\" >> test.txt $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward Happy coding learn git stash # 保护现场: 存储到\"草稿箱\" $ git stash Saved working directory and index state WIP on snow: 93227ba Happy coding (二). 切换到开发 dev 分支并合并修复 issue-110 分支. # 切换到开发 `dev` 分支 $ git checkout dev Switched to branch 'dev' sunpodeMacBook-Pro:git-demo sunpo$ git status On branch dev nothing to commit, working tree clean # 合并修复 `issue-110` 分支 $ git merge issue-110 Updating 3fe94c0..e60c8ad Fast-forward test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) sunpodeMacBook-Pro:git-demo sunpo$ git status On branch dev nothing to commit, working tree clean $ (三). 切换回自定义 snow 分支,并恢复工作现场. # 切换回自定义 `snow` 分支 $ git checkout snow Switched to branch 'snow' sunpodeMacBook-Pro:git-demo sunpo$ git status On branch snow nothing to commit, working tree clean $ git status 命令返回结果怎么显示工作区是干净的,好不容易才将丢失的更改找回来怎么又不见了?!逗我玩? 冷静,冷静,不要慌,既然工作现场已经保存到\"草稿箱\",那我们想要找回总要去\"草稿箱\"才能取出来吧?现在让我们看一下\"草稿箱\"有没有我们的工作现场? # 查看存储的\"草稿箱\"列表 $ git stash list stash@{0}: WIP on snow: 93227ba Happy coding $ 这里的 stash@{0} 是草稿 id,因为\"草稿箱\"允许保存多条草稿! 现在放心了吧,保存的\"草稿\"安然无恙躺在未知的某个地方,现在我们想办法恢复回工作区即可! git stash apply 恢复草稿,然后 git stash drop 删除草稿 git stash pop 恢复并删除草稿 # 恢复工作现场 $ git stash pop On branch snow Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") Dropped refs/stash@{0} (b0c8ddc034d21f31204c82e9838fc5d4c01a49a8) # 工作现场已恢复,更改未添加到暂存区,`learn git stash` 又恢复了! $ git status On branch snow Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward Happy coding learn git stash 结果 不论手头工作有没有提交,一旦工作区保存到\"草稿箱\"后,就放心大胆切换分支进行工作,回来时岁月静好,一切如初! 小结 紧急修复 bug 时,可以通过 git stash 保护工作现场,然后再切换到目标分支,检出修复分支,完成修复后切换到目标分支,合并修复分支,最后删除修复分支,此时再切换回本地分支后一切如初! 工作区更改添加到\"草稿箱\" : git stash,支持多次添加到\"草稿箱\" 列出\"草稿箱\"内容 : git stash list 恢复\"草稿箱\"内容 : git stash apply 删除\"草稿箱\"内容 : git stash drop 恢复并删除\"草稿箱\"内容 : git stash pop 恢复|删除指定\"草稿箱\"内容 : git stash ,例如 git stash apply stash@{0} var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/branch-emergency-fixbug.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/branch-rebase.html":{"url":"git/usage/branch-rebase.html","title":"变基合并","keywords":"","body":"变基合并 git 鼓励大量使用分支---\"早建分支!多用分支!\",这是因为即便创建再多的分支也不会造成存储或内存开销,并且分支的作用有助于我们分解逻辑工作,这样一样其实比维护单一臃肿分支要简单得多! 正因如此,每个新功能会创建合并分支,修复 bug 会创建合并分支等等,一段时间后再次回顾整个版本库的提交历史就会发现分支错综复杂,难以理清! 虽然\"条条大路通罗马\",但错综复杂的道路容易让人迷失方向,如果不使用分支,当然就不存在\"分叉问题\",所以在某些情况下我们希望寻求一种替代方案来解决分支合并带来的\"分叉问题\"! 回顾提交历史 查看提交历史: git log --pretty=oneline --graph --abbrev-commit # 查看提交历史 $ git log --pretty=oneline --graph --abbrev-commit * e60c8ad (HEAD -> dev, origin/master, origin/HEAD, master) fix bug about issue-110 * 3fe94c0 fast forward * 22fbef7 git merge --no-ff dev |\\ | * 44d68f6 git checkout -b dev |/ * 3b8f434 fix conflict |\\ | * 0fe95f8 git commit c2 * | 0949cc3 git commit c3 |/ * 5c482cd git commit c1 * 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50 learn git branch * b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e62564 add test.txt * 9b196aa Initial commit 仅仅是简单的演示项目的提交历史都已经出现\"分叉问题\",更何况真实的企业级开发项目呢?如果真的是多分支多人合作开发的话,\"分叉现象\"将更加明显,模拟效果图大概长这样: 整理提交历史 如果想要一条直路直达罗马,那我们必须规划好路径,摒弃小道,坚持主干道.git 的各种 dev,feature等分支就是需要治理的一条条分叉小道,而 master 主分支就是我们的大道. 演示项目有三个分支,主干master,开发dev,自定义snow,目标是将自定义 snow 分支的工作成功整理合并到主干分支,从而解决\"分叉问题\",dev 分支与项目演示无关,无需更改. (1). 切换到 snow 分支并提交一个版本(learn git rebase) # 切换到 `snow` 分支 $ git checkout snow Switched to branch 'snow' # 追加新内容到 `test.txt` 文件 $ echo \"learn git rebase\" >> test.txt # 提交到版本库 $ git commit -am \"learn git rebase\" [snow 7d21e80] learn git rebase 1 file changed, 1 insertion(+) $ (2). 切换到 master 分支也提交一个版本(modify README) # 切换回 `master` 分支 $ git checkout master Switched to branch 'master' Your branch is up to date with 'origin/master'. # 追加新内容到 `README.md` 文件 $ echo \"learn git ,share git\" >> README.md # 提交到版本库 $ git add README.md $ git commit -m \"modify README\" [master 3931d48] modify README 1 file changed, 1 insertion(+) $ (3). 切换回 snow 分支,整理提交历史(git rebase)到 master 分支 # 切换到 `snow` 分支 $ git checkout snow Switched to branch 'snow' # 改变基础版本(父版本),简称\"变基\" $ git rebase master HEAD is up to date. # 当前提交历史线 $ git log --pretty=oneline --graph --abbrev-commit * e92f068 (HEAD) rebase * 72f4c01 fix confict about happy coding * 3931d48 (master) modify README * e60c8ad (origin/master, origin/HEAD, dev) fix bug about issue-110 * 3fe94c0 fast forward * 22fbef7 git merge --no-ff dev |\\ | * 44d68f6 git checkout -b dev |/ * 3b8f434 fix conflict |\\ | * 0fe95f8 git commit c2 * | 0949cc3 git commit c3 |/ * 5c482cd git commit c1 * 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50 learn git branch * b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e62564 add test.txt * 9b196aa Initial commit $ (4). 切换回 master 主干分支再次变基合并 snow 分支 # 切换回 `master` 分支 $ git checkout master Warning: you are leaving 2 commits behind, not connected to any of your branches: e92f068 rebase 72f4c01 fix confict about happy coding If you want to keep them by creating a new branch, this may be a good time to do so with: git branch e92f068 Switched to branch 'master' Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) # 改变父版本为 `snow` 分支指向的版本 $ git rebase snow First, rewinding head to replay your work on top of it... Applying: modify README $ (5). 整理分支完成,最终主干分支是一条直线 # 查看提交历史线 $ git log --pretty=oneline --graph --abbrev-commit # `modify README` 是 `master` 分支提交的版本 * dcce09c (HEAD -> master) modify README # `learn git rebase` 是 `snow` 分支提交的版本 * 7d21e80 (snow) learn git rebase * a06a866 fix conflict |\\ | * e60c8ad (origin/master, origin/HEAD, dev) fix bug about issue-110 * | ab846f9 learn git stash * | 93227ba Happy coding |/ * 3fe94c0 fast forward * 22fbef7 git merge --no-ff dev |\\ | * 44d68f6 git checkout -b dev |/ * 3b8f434 fix conflict |\\ | * 0fe95f8 git commit c2 * | 0949cc3 git commit c3 |/ * 5c482cd git commit c1 * 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50 learn git branch * b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e62564 add test.txt 这一次我们没有使用 git merge 而是采用 git rebase 方式完成了分支的合并,优点是提交历史更清晰,缺点是丢失了分支信息. 小结 git rebase 变基合并分支,实际上就是取出一系列的提交版本并“复制”到目标版本,从而形成一条新的提交历史线. 比如我们想要把 bugFix 分支里的工作直接移到 master 分支上,移动以后会使得两个分支的功能看起来像是按顺序开发,但实际上它们是并行开发的,这就是 git rebase 的作用. git rebase 的优势是创造更线性的提交历史,使得代码库的提交历史变得异常清晰,劣势是缺失了分支信息,好像从没存在过该分支一样. 将目标分支上的工作成果转移到到主干分支 : git rebase master 主干分支接收已转移好的目标分支工作成果 : git rebase var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/branch-rebase.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/branch-remote.html":{"url":"git/usage/branch-remote.html","title":"协同开发","keywords":"","body":"协同开发 前面我们已经介绍过远程仓库的相关概念,不过那时并没有深入探讨,只是讲解了如何创建远程仓库以及推送最新工作成果到远程仓库,实际上远程仓库对于团队协同开发很重要,不仅仅是团队协同开发的基础,也是代码备份的保障手段,现在我们先简单回忆下相关概念,以便为接下来的协同开发做好铺垫! 远程仓库和远程分支 远程仓库 远程仓库其实并不复杂,实际上只是本地电脑上的本地仓库在另一台远程电脑的备份而已. 相对本地仓库来说远程电脑上的版本库自然就是远程仓库,远程仓库使得我们的版本库更加安全,毕竟远程电脑可不是一般的电脑,出错的概率比我们平时工作所使用的电脑概率要小得多,这样一来即使不小心丢失了本地仓库的全部数据,只要远程仓库没有丢失,那我们就可以通过远程仓库重新取回最新数据! 还有一点,远程仓库让代码社交化,因为大家有了一致途径来访问远程仓库,团队也好或者陌生人也罢,只有你愿意,他们就可以获取远程仓库的最新代码并参与开发,这也是 github 的一大亮点! 远程分支 回顾好远程仓库的概念后,我们再来讲一下本地仓库的远程分支是什么意思? 当前你正在工作的电脑上存储的是本地仓库,如果没有远程仓库的支持,只能一个人鼓捣,别人无法共享你的工作成果,现在加入了团队开发流程,自然不再一个人独自开发,需要和团队其他人协同开发,共享开发成果. 所以本地仓库必然保存着远程仓库的基本信息,只有区分好自己的工作成果和公共成果,才能不乱套,又能做到信息及时共享. 实际上,在项目初期刚刚拷贝远程仓库(git clone)时,git 已经默认在本地仓库创建一个远程分支(origin/master),本地修改提交首先都是在本地仓库完成的,比如 git add,git commit 等命令,如果需要发布你的工作成果,那么就需要使用 git push origin 命令推送到远程仓库,这里的 origin 指的就是远程仓库名称(因为最初大家都是先从远程仓库克隆下来的,所以远程仓库存储的项目相当于原始项目,故而叫origin). git clone 命令帮助本地仓库的 master 分支和远程仓库的 master 分支建立了关联,一般称远程仓库名称为 origin. 查看远程仓库信息 : git remote 或 git remote -v # 查看远程仓库名称 $ git remote origin # 查看远程仓库详情 : 拉取和推送链接 $ git remote -v origin git@github.com:snowdreams1006/git-demo.git (fetch) origin git@github.com:snowdreams1006/git-demo.git (push) $ 本地分支推送到远程仓库 : git push origin 本地仓库和远程仓库的分支理论上应该一一对应,本地仓库的主干分支叫做 master ,而远程仓库也有相应的分支叫做 master ,这种映射关系是使用 git clone 命令时默认生成的,也是推荐的做法. 一般来说,本地仓库的分支推送到远程仓库指的就是推送到远程仓库同名的分支上,例如 git push origin master 意思是: 推将本地仓库的 master 分支推送到远程仓库的 master分支,当然你也可以推送其他分支到相应的远程分支上. 按照之前约定的分支管理策略来说,master 分支用于生产环境部署,dev 分支用于收集开发成果,feature 分支用于开发具体功能分支,既然如此,那这些本地分支哪些需要同步推送到远程仓库就比较清晰了! 推送本地 master 分支到远程仓库的 master 分支 : git push origin master 推送本地 dev 分支到元层仓库的 dev 分支 : git push origin dev # 查看当前分支 : `master` 主分支 $ git branch dev * master snow # 推送本地 `master` 分支到远程仓库 `origin` 上相应的 `master` 分支 $ git push origin master Counting objects: 15, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (15/15), 1.31 KiB | 1.31 MiB/s, done. Total 15 (delta 9), reused 0 (delta 0) remote: Resolving deltas: 100% (9/9), completed with 3 local objects. To github.com:snowdreams1006/git-demo.git e60c8ad..dcce09c master -> master $ 正常来说,本地仓库的 master 分支应该领先远程仓库 origin 上的 master 分支若干个版本. 一旦我们已经将本地分支上的工作成果推送到远程仓库上相应分支时,本地仓库和远程仓库这时候就保持一致了. $ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean $ 远程仓库下载到本地分支 : git fetch 远程仓库的操作可以简单归纳为两部分: 上传和下载. 本地仓库推送到远程仓库是上传,而远程仓库拉取到本地仓库就是下载. 团队多人协作开发时,大家都会定期或不定期往 master 或 dev 等分支上推送各自的更改,相应的我们就需要下载别人的最新工作成果. 现在模拟其他伙伴正在往 master 分支上推送更改,最好在另一个电脑另一个账户,当然模拟的话也可以是同一个电脑下其他目录,或者最简单的方式,直接登录 github 更改 master 分支上某个文件内容,简单起见,我们采用最后一种方式. 其他伙伴已往远程仓库上的 master 分支提交了新的版本: 创建 git-remote.txt 文件 现在我们想要下载其他人的最新工作成果,接下来让我们看看本地仓库的 master 还能和远程仓库的 master 分支保持一致吗? # 下载远程仓库的 `master` 分支 $ git fetch origin master remote: Enumerating objects: 4, done. remote: Counting objects: 100% (4/4), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:snowdreams1006/git-demo * branch master -> FETCH_HEAD dcce09c..10942ff master -> origin/master $ 执行 git fetch 命令后,远程仓库上的最新提交记录已经下载到本地仓库,同时更新了本地仓库的远程分支origin/master ,值得注意的是本地仓库的 master 分支并没有更新! 那你可能会有疑问了,我想要的结果是下载其他人的最新工作成果,怎么我本地仓库的 master 分支并没有更新呢? # 查看工作区 $ ls LICENSE README.md test.txt # 查看版本库状态 $ git status On branch master Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use \"git pull\" to update your local branch) nothing to commit, working tree clean $ 既然 git fetch 并没有更新本地仓库的 master 分支,那它到底做了哪些工作呢? git fetch 会做的事情 实际上, git fetch 完成了仅有的但是很重要的两步操作: 从远程仓库下载本地仓库中缺失的提交记录 更新本地仓库的远程分支(比如origin/master) 通过上述两步操作完成的效果是: 将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态. 远程分支实际上是反映了远程仓库在你最后一次与它通信时的状态,而git fetch 就是你与远程仓库通信的方式了！ git fetch 不会做的事情 git fetch 并不会改变你本地仓库的状态,所以也就不会更新你的 master分支,自然也不会修改你磁盘上的文件. 理解这一点很重要,因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了. 实际上它可能已经将进行这一操作所需的所有数据都下载了下来,但是并没有修改你本地的文件. 既然本地仓库的远程分支已更新,那么想要更新本地仓库的 master 分支该如何做呢?很简单,可以 git merge 啊! 远程仓库更新到本地分支 : git pull 其实通过 git fetch 命令我们已经下载了远程仓库的最新版本,只不过还没有合并到本地仓库而已,如何合并分支相信大家已经轻车熟路了,有很多方法: git merge origin/master git rebase origin/master git cherry-pick origin/master 实际上,先抓取更新(git fetch)再合并(git merge)这个流程很常用,因此 git 是有专门的命令来完成这两步操作的,这就是拉取更新git pull --- 刚好与推送更新 git push 相反! # 拉取最新版本 $ git pull Updating dcce09c..10942ff Fast-forward git-remote.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 git-remote.txt # 查看版本库状态 $ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean # 查看工作区内容: 文件已更新 $ ls LICENSE README.md git-remote.txt test.txt $ 团队协作 掌握了远程仓库和远程分支的相关概念后,现在开始真正模拟团队协作开发了,为了简单起见,仍然以直接操作 github 上的 master 分支为例说明如何协同开发. (1). 其他人已往远程仓库推送2个版本 (2). 你正在本地仓库提交1个版本 $ echo \"learn teamwork\" >> test.txt $ git commit -am \"learn teamwork\" [master f971647] learn teamwork 1 file changed, 1 insertion(+) $ (3). 你推送到远程仓库前先拉取最新版本 # 拉取最新版本,并尝试合并 $ git pull remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (5/5), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. From github.com:snowdreams1006/git-demo 10942ff..612e08a master -> origin/master Merge made by the 'recursive' strategy. git-remote.txt | 2 ++ 1 file changed, 2 insertions(+) # 查看版本库状态 $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits) nothing to commit, working tree clean # 查看其他人工作成果 $ cat git-remote.txt git remote git clone git commit -am \"fake second teamwork\" # 查看自己即将推送的工作成果 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward not recommend Happy coding learn git stash learn git rebase learn teamwork $ (4). 你将本地仓库更改内容推送到远程仓库 # 推送到远程仓库 $ git push origin master Counting objects: 5, done. Delta compression using up to 4 threads. Compressing objects: 100% (5/5), done. Writing objects: 100% (5/5), 564 bytes | 564.00 KiB/s, done. Total 5 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 3 local objects. To github.com:snowdreams1006/git-demo.git 612e08a..8fe5aba master -> master $ 现在前往 github 网站确认我们已经推送成功,我们的工作成果和其他人的工作成果同时存在于远程仓库中,这样就完成了一次团队协同开发的案例. 现在简单回顾一下整个协同开发流程: 其他人先于我们提交2个版本 我们本地提交1个版本 本地版本推送前拉取远程仓库 本地仓库推送到远程仓库 小结 查看远程仓库信息: git remote -v 本地仓库推送到远程仓库: git push origin 远程仓库抓取到本地仓库: git fetch 远程仓库拉取到本地仓库: git pull 相当于 git fetch 和 git merge 本地创建和远程仓库一致的分支: git checkout -b origin/,本地和远程分支名称最好一直,比如本地 master 和 远程 origin/master,本地 dev 和远程 origin/dev 本地分支和远程分支建立关联: git branch --set-upstream origin/ ,足够任性的话,本地 dev 可以关联远程 remote-dev 等,不过建议名称最好一致. 团队协同开发时,不仅平时要定期拉取(git pull),推送到远程仓库前更应先拉取(git pull)再推送(git push),如出现冲突,解决冲突后再推送. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/branch-remote.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/local-remote-repository.html":{"url":"git/usage/local-remote-repository.html","title":"本地和远程仓库的本质","keywords":"","body":"本地和远程仓库的本质 本地仓库和远程仓库在本质上没有太大区别,只不过一个是本地电脑,一个是远程电脑. 远程仓库不一定非得是 github 那种专门的\"中央服务器\",甚至局域网的另外一台电脑也可以充当\"中央服务器\"的角色,因为它存在的最初目的只是方便大家交换彼此的提交记录而已! 所以本地仓库和远程仓库的基本行为应该是一致的,约定俗成的规定是远程仓库一般不直接参与日常开发工作,主要作为项目托管中心. 某些自动化持续集成环境中也可能会直接操作远程仓库,这时远程仓库就真的和本地仓库没什么区别了! 个人开发常用命令 个人开发看重的是效率,同时兼顾下版本控制的话算是是锦上添花,git 的本地仓库是本地备份,而远程仓库则是网盘备份. git init : 初始化本地项目 将本地项目初始化 git 项目,直观表现是在该项目同级目录下多了 .git 隐藏目录,其存储着 git 版本库相关信息. 此后当前项目便具备了本地管理的能力,可以与 git 进行交互. git clone : 克隆远程项目 同 git init 一样的作用,也是创建本地仓库,只不过 git init 是直接将本地项目作为本地仓库,而git clone 是将远程项目克隆到本地并作为本地仓库. 由此可见,git clone 比 git init 多了一层远程仓库的概念. git add : 添加文件 将工作区的提交记录添加到暂存区,暂存区是工作区和版本库交互的桥梁,暂存区积累到一定量的提交记录时可以批量提交到版本库,这一点暂存区有点像缓存. git commit : 提交文件 将暂存区的版本提交到版本库,从而形成工作区->暂存区->版本库的基本链路,本地工作区的版本控制流程大致如此. git push : 推送文件 如果是使用 git clone 命令克隆的本地项目,当工作到一定程度时可能需要将这部分工作成果推送到远程仓库,这时候使用 git push 命令完成本地版本的推送流程. 如果是使用 git init 命令初始化的本地项目,可能没有远程仓库,自然也就不需要推送.如果后来创建了远程仓库,那么你自然是想要将本地仓库推送到远程仓库的,因此你需要准确告诉 git 你要推送到哪个远程仓库. 使用 git remote add origin git@github.com:username/repos.git 命令添加远程仓库信息,这样就建立了本地仓库和远程仓库的关联,以后就可以正常推送到远程仓库了. 团队开发常用命令 团队开发注重的不仅是个人效率还有团队的整体进度,随着企业级开发的日趋复杂化,不再是一个人能够独立完成的,更何况时间也不允许慢慢完成,大多数公司采用的是人力换时间的方式,团队并行开发来缩短整个项目周期,这种复杂需求下正是 git 大展拳脚的好机会. 项目整体采用并行开发模式,拆解成不同的功能模块,每个人负责各自模块,模块之间相对独立但也不排除存在交集的可能性.对于每一个个体开发者来说,既需要版本控制又需要团队交流.这时候分支的作用就凸显出来了. 根据项目的业务特点将其拆解成不同的功能模块,这些功能模块分别代表不同的分支,而这些功能模块又组成了完整的项目,这就是主干和分支的关系. 初始时项目是一个整体,中间拆解成不同功能模块,最后再合并成一个整---\"分久必分合久必分\". git branch : 创建分支 每一个独立的功能模块被定义成一个单独分支,创建分支的过程其实是拆解项目的过程,创建本地分支后就在分支上开发特有功能,不再关心其他功能分支. git checkout : 切换分支 模块拆解完成并创建了相应的分支后,需要切换到既定分支上才能开展自己的工作. git merge : 合并分支 没有绝对的独立,项目再怎么拆分也是整体的一部分,肯定需要和其他功能模块发生关系,某些情况下需要其他分支的工作成果合并到自己的本地仓库中,这样才能完成一次小规模的组装. 可以预期的是,当这种组装足够多的时候,最终便会演变成项目的终极形态,形成一个整体. git fetch : 抓取远程分支 合并目标分支首先需要能够获取到目标分支的提交记录,既然每个功能模块都是不同的项目成员负责开发的,也就不在我们电脑上,所以我们先要将目标分支下载到我们本地电脑,然后才能合并该分支到本地分支. git pull : 拉取远程分支 \"先下载目标分支再合并到本地分支,从而小规模组成更复杂更强大的功能\",每一次的组装过程都需要两步操作者显然不符合懒人思维啊,git pull 就是这两步操作的简化命令,先下载再合并就是这么简单! 本地和远程仓库的碰撞 不论是个人开发还是团队开发,我们几乎习惯惯站在主动方的角度来思考问题,有没有想过当远程仓库接收到我们的git push 或 git pull 请求时,远程仓库发什么了什么改变,这种改变对本地仓库又有什么影响? 远程仓库(远程电脑上的本地仓库)只是众多分布式电脑上本地仓库中的一员,说它特殊也很特殊,充当着\"中央服务器\"作用,其余人统一从这里下载或推送;说它普通也很普通,和本地电脑上的本地仓库没有什么不同,因为它随时可被任意电脑上的本地仓库所取代! 揭开远程仓库的神秘面纱后,现在我们只需要将其视为普通的本地仓库一样对待即可,然而我们本地电脑上已经有了本地仓库,故而需要将远程仓库做一下简单标识区分(origin)称之为远程分支. 先说说 git push 命令做了什么? 对于本地来说,git 将本地仓库的指定分支推送到远程仓库的相应分支,同时更新了本地仓库的远程分支. 对于远程来说,git 接收到本地仓库的推送请求时应该在相应分支上合并本地分支,同时更新远程仓库的相应分支. 只要本地的指定分支成功推送到远程的相应分支时,对于本地来说,不论是指定分支还是远程分支(origin/master)都应该是最新状态,因为已经与服务器同步了. 而远程接收到此次推送请求时,应该尝试合并此次推送请求,再更新自己的相应分支,远程合并完成后再通知本地此次推送结果,如此一来,三端同步,皆大欢喜! 再讲讲 git pull 命令发生了什么? 对于远程来说,接收到本地的拉取请求时,因为没有新版本需要处理,所以无需任何操作. 对于本地来说,当远程仓库的相应分支下载到本地时应该更新远程分支状态,再尝试合并到本地的相应分支. git pull 命令或者说是 git fetch 命令是本地和远程通信的方式,所以 origin/master 会自动更新! 小结 本地仓库和远程仓库本质上没有太大区别, git fetch 是本地仓库和远程仓库之间的通信途径,本地仓库中的远程分支(origin/master)保存着它们之间最后一次的通信状态. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/local-remote-repository.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/usage/tag.html":{"url":"git/usage/tag.html","title":"里程碑式标签","keywords":"","body":"里程碑式标签 \"春风得意马蹄疾,一日看尽长安花\",对于项目也是如此,最值得期待的恐怕就要数新版本发布的时刻了吧?每当发布新版本时要么是版本号命名(比如v0.0.1)或者代号命名(比如Chelsea),不管怎么说这种里程碑阶段总是要留下些许纪念意义. 既然想要纪念这种特殊的历史时刻,自然是希望它能够固定下来,不要发生随意移动,产生不可预期后果. 这种需求其实和我们前面说的分支概念很相似,均是源于特殊的版本号,逐渐收集起一系列版本,最终形成一条相对独立的历史线,但分支并不是实现里程碑概念的最佳选择,为什么? 分支适合多人协作开发时互不影响,适当时机主动合并他人工作成果这种模式,而这种模式是由不同的功能模块进行驱动的,正所谓\"天下大势分久必合,合久必分\",当功能模块开发完毕后自然也就没有分支存在的必要性,更何况分支在收集版本的过程中会一直移动,并没有特殊的固定版本,显然分支不是最佳选择! 但是,分支确定一定程度上和里程碑概念很相似,源于特定版本,自主命名,收集版本等,那么何必重头再来,为何不复用已有概念呢? 实际上,git 中的标签(tag) 就是实现里程碑概念的方式,它可以永久性指向特定的提交并将命名,然后就可以将其理解成分支一样引用了! 但标签(tag)不是分支(branch),标签是一个点的话,分支就是若干点连接而成的线,标签是静态的,分支是动态的,标签是只读的,分只是可读可写的. 创建标签 git tag # 方式一: 默认 `HEAD` 指向的版本 git tag v0.0.1 # 方式二: 指定 `commit_id` 表示的版本 git tag v0.0.2 f971647 # 方式三: 指定 `commit_id` 表示的版本,同时创建标签说明信息 git tag -a v0.0.3 -m \"v0.0.3\" f971647 列出标签 git tag git tag 显示标签 git show git show v0.0.1 删除标签 git tag -d git tag -d v0.0.1 推送标签 git push origin git push origin v0.0.1 推送全部标签 git push origin --tags git push origin --tags 删除远程标签 git tag -d git push origin :refs/tags/ # 删除本地标签 git tag -d v0.0.1 # 推送删除标签(删除也是推送) git push origin :refs/tags/v0.0.1 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/usage/tag.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/custom/about.html":{"url":"git/custom/about.html","title":"私人定制","keywords":"","body":"个性化 git 前情概要 初识 git 时,我们就已经接触过 git 的基本配置,使用 git config 命令配置用户名和邮箱: # 配置当前项目(`local`)的用户名(`snowdreams1006`) git config --local user.name \"snowdreams1006\" # 配置当前项目(`local`)的邮箱(`snowdreams1006@163.com`) git config --local user.email \"snowdreams1006@163.com\" 快速回忆一下配置的相关语法: # 查看默认全部配置: `local>global>system` git config --list # 查看当前项目配置,等同于 `.git/config` 文件 git config --local --list # 查看当前用户配置,等同于 `~/.gitconfig` 文件 或 `~/.config/git/config` 文件 git config --global --list # 查看当前系统配置,等同于 `/etc/gitconfig` 文件 git config --system --list man git-config 查看帮助文档,git 的配置文件是普通文本,也可以直接编辑. 高频配置 总体来说,git 的配置项基本分为两类: 客户端和服务端.其中大部分属于客户端配置, 除非使用自己搭建私服,否则没机会手动配置服务端(第三方服务器基本都支持可视化配置,比如禁止强制推送等配置). alias 别名 熟悉 linux 操作的小伙伴对 ll 这个命令可能再熟悉不过了,是 ls -l 的缩写,称之为别名. git 也支持别名,有个别名我们可以将常用的命令都缩短,大大降低出概率,提高工作效率. # `git checkout` 缩写成 `git co` git config --global alias.co checkout # `git commit` 缩写成 `git ci` git config --global alias.ci commit # `git branch` 缩写成 `git br` git config --global alias.br branch 如此一来,以后再也不用担心打错字了,简化命令,懒人至上! core.editor 编辑器 默认情况下,git 使用的是 $VISUAL 或 $EDITOR 配置的文本编辑器,如果没有设置,则调用 vi 编辑器创建和编辑文本信息. 查看当前编辑器配置项: # 查看编辑器配置项: 若没配置过,则无内容输出,已配置过的话,会输出相应编辑器信息 git config core.editor 假设使用 sublime 作为默认编辑器,那么便可如下设置: # `Mac` 系统如下设置: 设置成自己的 `Sublime` 的安装路径 git config --local core.editor \"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' -n -w\" # `Windows` 系统如下设置: 设置成自己的 `Sublime` 的安装路径 git config --local core.editor \"'F:\\Sublime Text 3 sublime text.exe' -n -w\" 此时再次查看编辑器配置项应该会输出刚才配置信息,接下来我们验证下编辑器的效果: 查看提交历史,已经提交成功(之前备注信息是在命令行中直接输入的,而现在是在编辑器中编辑) $ git log --pretty=oneline --abbrev-commit 43fa8aa (HEAD -> master) validate sublime successfully 00e16d7 ok 2400f11 git config --local core.editor \"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' -n -w\" 0d60cb8 ok 8fe5aba (origin/master, origin/HEAD) Merge branch 'master' of github.com:snowdreams1006/git-demo $ 如果只是输入简单备注,根本用不到编辑器,若提交备注有格式化要求时再手动输入就显得力不从心了! core.template 提交模板 如果你需要格式化提交备注,那么这种情况下模板文件最好不过了,和自定义的编辑器一起搭配,这样就能约束自己和他人按照既定格式规范填写提交备注,方便以后统一管理. 查看当前提交模板配置: git config commit.template 假设你在当前项目下创建 commit-template.txt 模板文件,内容如下: # This is commit template # snowdreams1006 # git-demo 将编辑好的模板文件设置成提交默认信息,需要如下设置: git config --local commit.template commiit-template.txt 此时再次运行 git config commit.template 查看已配置提交模板,现在看一下实际效果: 查看提交历史,当然也提交成功啦,可根据实际需求定制适合自己的提交模板. $ git log --abbrev-commit commit a2ca3f0 (HEAD -> master) Author: snowdreams1006 Date: Wed Mar 27 16:22:18 2019 +0800 ok myself yes commit 43fa8aa Author: snowdreams1006 Date: Wed Mar 27 14:58:36 2019 +0800 validate sublime successfully commit 00e16d7 Author: snowdreams1006 Date: Wed Mar 27 14:56:20 2019 +0800 ok commit 2400f11 git 还支持其他配置,暂时不一一介绍了,详情请参考在线帮助文档: man git-config var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/custom/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/custom/ignore.html":{"url":"git/custom/ignore.html","title":"忽略文件","keywords":"","body":"忽略文件 \"并不是所有的牛奶都叫特仑苏\",在版本控制系统中也有相似的表达,那就是\"并不是所有的文件都需要提交\". 有的是因为没必要提交,比如日志文件,系统缓存文件等,有的是因为不能提交,比如个人隐私文件,付费文档等. 正常来说,这些文件都是不应该被提交到版本库,倘若一不留神提交到版本库,要么泄露机密信息,要是造成经济损失,要么对团队其他人工作造成不便. 有鉴于此,我们应该寻求一种机制来规避事故的发生,在 git 版本控制系统中一般有三种不同的解决方案. 最常用也是最简单的当属 .gitignore 文件,不过先不要着急,我们先了解一下忽略原则和配置规则. 忽略文件的基本原则 忽略操作系统自动生成的文件,保持不同操作系统的纯粹性和整洁度. 忽略工具软件自动生成的文件,避免因个性化配置而产生的工作障碍. 忽略个人隐私配置文件,除非你愿意承担公开隐私所带来的潜在风险. 目标: 只提交必要文件,忽略无用文件,尽可能考虑多种情况,不给他人制造麻烦. 忽略文件的配置规则 一行记录代表一条规则,配置规则仅针对尚未被跟踪的文件清单. # 忽略 `*.a` 文件 *.a # 忽略 `*.A` 文件,但 `somefile.A` 除外. *.A !somefile.A # 忽略 `*.b` 和 `*.B` 文件 *.[bB] # 忽略 `*.c` 和 `*.C` 文件,但 `somefile.C` 除外. *.[cC] !somefile.C # 只忽略 `somepath/` 目录(包括该目录下所有文件),但不忽略 `somepath` 文件 somepath/ # 只忽略 `somepath/` 一级子目录下 `*.txt`,但不忽略 `somepath/sub/*.txt` 文件 somepath/*.txt # 忽略 `somepath` 文件和 `somepath` 目录 somepath # 只忽略 `somepath` 文件,但不忽略 `somepath/` 目录 somepath !somepath/ # 只忽略当前目录下的 `somepath` 文件和目录,但不忽略子目录的 `somepath` /somepath 说明: # 开头表示注释,! 紧跟某规则之后表示增加例外情况 在线示例和帮助文档 提供两个不错的在线示例,可以参考下在什么场景应该忽略哪些文件以及如何编写忽略规则. https://www.gitignore.io/ https://github.com/github/gitignore 运行 git help ignore 命令查看帮助文档 三种设置方式 git 设置忽略文件有三种方式,如下: 全局配置文件(~/.gitignore),执行 git config --global core.excludesfile ~/.gitignore 命令后适用于所有的版本库. 远程配置文件($PWD/.gitignore),编辑 .gitignore 文件后适用于远程和本地版本库. 本地配置文件($PWD/.git/info/exlude),编辑 $PWD/.git/info/exlude 文件后适用于本地版本库. 最常用方式 三种设置方式中,第二种最为常见,另外两种大致一样,重点在于配置文件如何编写. 创建 .gitignore 文件 参考在线示例以及基本语法编写自定义忽略规则 # General .DS_Store .AppleDouble .LSOverride # Windows thumbnail cache files Thumbs.db ehthumbs.db ehthumbs_vista.db 提交 .gitignore 文件 忽略文件规则配置完毕后,需要将该文件提交到版本库,这样在其他电脑上也能应用相同的忽略规则. # 添加 `.gitignore` git add .gitignore # 提交 `.gitignore` git commit -m \"add .gitignore\" # 上传 `.gitignore` git push origin master 验证忽略效果 新建 .gitignore 文件中已忽略的文件,运行 git status 命令,如果提示 working directory clean,那么说明忽略文件的配置已经生效,如果工作区不干净,很遗憾,忽略文件配置可能并未生效,需要检查下哪里配置错了. 运行 git check-ignore 命令检查是哪个配置规则写错了,从而我们能够更正相应的配置规则. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/custom/ignore.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/custom/sync-remote-repo.html":{"url":"git/custom/sync-remote-repo.html","title":"同步推送多Git仓库","keywords":"","body":"同步推送多Git仓库 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/custom/sync-remote-repo.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-15 17:18:01 "},"git/server/private.html":{"url":"git/server/private.html","title":"搭建私服","keywords":"","body":"git 私服搭建教程 前几节我们的远程仓库使用的是 github 网站,托管项目大多是公开的,如果不想让任何人都能看到就需要收费,而且 github 网站毕竟在国外,访问速度太慢,基于上述两点原因,我们有必要搭建自己的 git 服务器. 虽然我们能搭建基本的 git 服务器,但是想要做到 github 网站那种规模还不是目前能够探讨的,本节的主要目标是使用我们私有服务器对我提供类似于github的远程仓库托管服务,以下示例以centos 服务器为例说明: 安装 git 服务 运行以下命令安装 git 服务 # 安装 git 相关依赖 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel # 安装 git yum install git # 查看 git 版本 git --version 详情请参考安装 git 配置 git 用户 创建 git 用户组和 git 用户,以便对外提供 git 服务 # 新增 git 用户组 groupadd git # 新增 git 用户并归属于 git 用户组 useradd git -g git # 禁用 git 用户登录 shell 编辑 /etc/passwd git:x:1001:1001:,,,:/home/git:/bin/bash 更改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 收集 git 公钥 回忆一下,在我们使用 github 网站时,我们是不是曾经将本地电脑生成的公钥~/.ssh/id_rsa.pub 复制到 Account -> Settings -> SSH and GPG keys -> New SSH key,而我们现在搭建的git 服务还是简单,但是这步骤必不可少,因此只能手动收集素有需要访问我们服务器的公钥文件. 我们知道需要登录我们服务器的用户公钥一般是存放在~/.ssh/id_rsa.pub ,那当前服务器作为远程服务器将这些公钥存放到哪里呢?还记得上一步我们创建了 git 用户吗? 因为 linux 系统支持多用户操作,而 git 用户就用于专门运行 git 服务,负责所有和 git 有关的事宜.因此,导入公钥文件的目录就是/home/git/.ssh/authorized_keys文件.一个用户公钥占用一行,几个用户就有几行. # 切换到 git 用户主目录 cd /home/git/ # 创建.ssh 目录 mkdir .ssh # 赋予标准目录权限 chmod 755 .ssh # 创建authorized_keys文件 touch .ssh/authorized_keys # 赋予标签文件权限 chmod 744 .ssh/authorized_keys 如果团队规模不大,那么上述方案完全可行,如果团队规模几百上千人,通过手动收集每个人的公钥再上传到服务器统一管理就有点力不从心了,这时候推荐 gitosis 决这一问题. 初始化 git 仓库 同样我们和github 网站类比,在 github 创建仓库时都会在当前账号下创建项目,完整的访问路径大概是这样的: git@github.com:snowdreams1006/git-demo.git,从中我们可以看出项目仓库都有一个前缀即命名空间,这和上一步操作是不是很类似,上一步收集 git 公钥时我们也有统一的目录,这次也不例外. 假设 git 仓库存放目录在 /home/git/repos/,同样的先创建该目录并赋予响应权限. # 切换到 git 用户主目录 cd /home/git/ # 创建 repos 目录 mkdir repos # 更改 repos 目录属主 chown git:git repos/ # 切换到 repos 目录 cd repos # 初始化 git 裸仓库 git init --bare git-demo.git # 更改 git-demo.git 仓库属主 chown -R git:git git-demo.git 这里搭建git服务器仅为了共享,不考虑用户直接登录该服务器上使用 git 将其作为工作区这一情况 经过上述操作,我们成功在远程服务器部署了 git 服务,并且创建了 git-demo 测试项目,实际访问路径大概是这样的 git@snowdreams1006.cn:/home/git/repos/git-demo.git 访问授权 总是存在一些公司不仅视源代码为生命,还视员工为窃贼,抑或是深受svn毒害,要求在版本控制系统中设置一套完善的权限控制体系,具体到每个账号对每个项目的每个目录是否有读写权限. 然而 git 天生并不支持权限控制,这一点和其出身有关,本来就是为了开源而生,并不关心所有人的提交. 不过这并不意味着 git 无法实现权限控制功能,因为 git 支持钩子函数(hook) ,所以在服务器端编写一系列的脚本控制提交行为,从而实现权限控制.详情请参考 gitolite 本地克隆远程仓库 身份回到本地电脑,假设本地已搭建好 git 环境,并且生成的ssh 公钥上传到远程服务器,那么我们接下来就可以和之前远程服务器是 github 网站那样的方式开发我们的项目了,唯一不同的是,接下来我们推送的远程服务器均是我们刚搭建好的主机. 需要做好心里准备,我们搭建的服务器还很简单,没有 github 网站那样可以直观操作远程仓库,但是这并不影响我们的 pull push merge 等操作哟! git clone git@snowdreams1006.cn:/home/git/repos/git-demo.git git-指的是 git 用户,snowdreams1006.cn-指的是远程主机域名或ip,/home/git/repos-指的是 git 仓库的目录,git-demo.git-指的是项目名称 现在我们已经成功搭建好自己的 git私服了,是不是很简单呢?有没有对 git 和 github 进一步理解?欢迎大家一起探讨! 小结 git 私服就是无 web 界面的简化版 github 小团队人工收集用户公钥,大团队使用 gitosis 实现类似 svn 那样的权限控制请使用 gitolite var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/server/private.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/tools/about.html":{"url":"git/tools/about.html","title":"扩展工具","keywords":"","body":"扩展工具 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/tools/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/tools/git-bash-command.html":{"url":"git/tools/git-bash-command.html","title":"git bash 常见命令","keywords":"","body":"git bash 常见命令 已投稿给脚本之家公众号,如需查看请访问: 从 git bash 命令行中窥探人生 https://mp.weixin.qq.com/s/5bSogfIMqmhgMcZ5NoYNlA var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/tools/git-bash-command.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/tools/git-bash-relationship.html":{"url":"git/tools/git-bash-relationship.html","title":"git bash 朋友圈","keywords":"","body":"git bash 朋友圈 已投稿给脚本之家公众号,如需查看请访问: 看过git bash的朋友圈才知道cmd为啥会呵呵一笑 https://mp.weixin.qq.com/s/4t2OPNtlVL12AQjrqAjuHg var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/tools/git-bash-relationship.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/tools/git-bash-tree.html":{"url":"git/tools/git-bash-tree.html","title":"git bash 竟然没有tree命令","keywords":"","body":"git bash 没有tree命令? 开门见山 git bash 是 Windows 用户安装 git 时默认安装的命令行工具,不仅界面漂亮功能也不错,大多数情况下可以替代 Windows 原生的 cmd 命令行. 然而,git bash 命令行不是万金油,并不能完全替代 cmd ,详情请参考 mintty 官网的相关说明. mintty is not a full replacement for the Windows Console window git bash 命令行默认使用 mintty 作为终端模拟器,而 mintty 官宣表示自己不能完全替代 cmd,也就是说 git bash 可能不具备某些 cmd 命令. 举个简单的例子,如果想要查看当前目录的文件结构,最好是以目录树的形式展现,聪明的你获取已经猜到了tree 命令. git bash 命令行中输入 tree 命令发现并无此命令. snowdreams1006@home MINGW64 /g/sublime/test $ tree bash: tree: command not found 为了验证,确实没有 tree 命令,我们直接打开 git bash 支持的命令文件目录,查看到底有没有 tree.exe 文件. 在 git bash 桌面快捷方式右键,选择打开文件位置,当前正处于 git 的安装目录,进入.\\usr\\bin 文件夹. 经过验证,git bash 支持的命令文件确实没有发现 tree.exe 文件,因此真的不支持 tree 命令. 然而,cmd 自带的命令行中输入 tree 中竟然发现能够输出目录树,原来 cmd 支持 tree 命令. G:\\sublime\\test>tree 卷 工作 的文件夹 PATH 列表 卷序列号为 00000081 CC3C:50D0 G:. ├─cmd └─git tree 命令其实调用的是 tree.com 并不是常见的 tree.exe 格式. 科普时间 现在我们已经知道 git bash 提供的终端模拟器不支持某些 linux 命令,但是为什么不支持以及如何才能支持这些命令呢? 这些问题必须等我们弄清楚 mintty 的朋友圈关系才能更好地解决上述问题,接下来简单科普下 mintty 的朋友圈. 关于科普知识的来源,请参考上一篇文章: > mintty 是什么 Mintty 是 Cygwin，MSYS 或 Msys2 的终端模拟器,派生项目和 WSL. mintty 开源终端模拟器,基于 putty 的终端仿真和 Windows 前端页面. mintty 作为一款优秀的终端模拟器,不仅是其他系统上默认的终端,也是 git bash 的默认终端. $ mintty --help Usage: mintty [OPTION]... [ PROGRAM [ARG]... | - ] Start a new terminal session running the specified program or the user's shell. If a dash is given instead of a program, invoke the shell as a login shell. Options: -c, --config FILE Load specified config file -e, --exec Treat remaining arguments as the command to execute -h, --hold never|start|error|always Keep window open after command finishes -i, --icon FILE[,IX] Load window icon from file, optionally with index -l, --log FILE|- Log output to file or stdout -o, --option OPT=VAL Override config file option with given value -p, --position X,Y Open window at specified coordinates -s, --size COLS,ROWS Set screen size in characters -t, --title TITLE Set window title (default: the invoked command) -u, --utmp Create a utmp entry -w, --window normal|min|max|full|hide Set initial window state --class CLASS Set window class name (default: mintty) -H, --help Display help and exit -V, --version Print version information and exit 如果想要自定义 mintty 终端,在 git bash 命令行界面右键选择选项设置即可打开设置页面. mingw 是什么 mingw 是 Minimalist GNU for Windows 的缩写,是 Microsoft Windows 应用程序的极简主义开发环境. msys 是什么 MSYS 是 Minimal SYStem 的缩写,是 Bourne Shell 命令行解释器系统.作为 Microsoft 的 cmd.exe 的替代品,它提供了一个通用的命令行环境,特别适合与 MinGW 一起使用,用于将许多开源应用程序移植到 MS-Windows平台; 它是 Cygwin-1.3 的轻量级分支，它包含一小部分 Unix 工具,可以帮助实现这一目标. cygwin 是什么 大量 GNU 和开源工具,提供类似于 Windows 上的 Linux 发行版的功能. gnu 是什么 GNU 是 GNU's Not Unix 的递归缩写,是自由软件操作系统. 朋友圈关系梳理 git bash 采用 mintty 作为终端模拟器,而 mintty 终端是 mingw ,msys2 和 cygwin的默认终端,这些\"操作系统\"或多或少都是 GNU 的一部分. GNU 是自由软件运动的成果,提出自由软件以及自由软件操作系统概念,源码开源发布. 正因如此,江山代有才人出,前人栽树后人乘凉,Cygwin 作为 GNU 一员,提出了要在 Windows 打造出 Linux 的感觉,开发出一套完整的解决方案. 或许由于这套方案太完整,功能齐全因而软件包体积庞大,因此 MinGW 和 MSYS 分别在其基于上进行精简重构,保留最简功能,发展出\"极简主义的GNU\". 开源的力量是可持续的,慢慢的,这些操作系统的内置终端功能也被单独提取出来,mintty 作为他们的默认终端也逐渐独立提供终端模拟器服务,轻松和各个系统进行安装集成. 说到开源,自然是少不了 git 的身影,分布式版本控制系统这种优秀工具应该造福全人类,然而 git 本身仅支持类 Unix 系统,并不提供 WIndows 系统的支持. Git For Windows 组织出手增加了 git 对 Windows 系统的支持,背后的技术多半离不开上述介绍的 GNU 操作系统. Git Bash Here 则是 Git For Windows 的命令行工具,使用的终端模拟器就是明星模拟器 mintty. 回到正题 弄清楚事情的来龙去脉后,对我们解决问题有什么帮助呢? 帮助可大了去了,刨根问题找到了源头,问题自然迎刃而解! 我劝少年放弃吧 你确定不是在逗我?让我直接放弃? 亲,真的抱歉呢,放弃是解决问题的最快途径! ... 谈一谈为什么要放弃? git bash 命令行使用的是 mintty 终端,而 mintty 终端并不能完全替代 cmd ,也没有提供包管理工具供我们扩展第三方命令. 所以默认情况下,如果没有提供某些命令,那我们只好放弃在 git bash 命令行中使用这些命令. 此路不通,自然会寻求其他解决途径,比如可以借助 cmd 命令行或者其他第三方软件等,没必要非要坚持使用git bash! 既然本文是 tree 命令引发的讨论,那就谈点和主题有关的技能点,不然岂不是跑题了? tree 命令虽然 git bash 不提供,但是 cmd 却已经内置了. 值得注意的是,cmd 提供的 tree 命令比较特殊,并不是常见的 .exe 结尾文件,而是 .com 结尾的文件. 所以 git bash 中输入 tree 命令时,自身 /usr/bin 中没有 tree.exe 文件,而系统中也没有 tree.exe 命令,那么就会提示找不到命令了啊! 手动补全命令 那么第一种调用方法便是补全后缀名,这样自然能够调用 cmd 的 tree.com 命令. git bash 并不识别 .com 后缀的命令,输入 tree 命令时以为是 tree.exe ,实际上 tree 命令应该是 tree.com 的简写. 我擦,竟然出现乱码,根据我多年的开发经验来看,乱码问题多半是编码问题导致的,那么修改下终端的编码设置应该就能解决问题. 在命令行窗口内右键弹出 mintty 终端的设置页面,选择文本(Text)中本地化(Locale)配置,选择中文简体(zh_CN),字符集(Character set)设置为UTF-8. 瞬间被打脸,无论是原来的git bash 命令行窗口还是新开的命令行窗口,仍然还是乱码! 然而,我是不会承认被打脸的,世人皆醉我独醒,肯定是 bug,哈哈! 其实,中文乱码真的是 bug ,还是官方认可的 bug 哟,我并没有被打脸呢,后续会介绍. 调用 cmd 程序 既然git bash 没有提供 tree 命令,而恰巧 cmd 提供了 tree 命令,那为何不假借他人之手实现自己的目的呢? 在 cmd 中使用 tree 命令直接输入即可得到目录树结构,但是现在需要在 git bash 中调用 cmd 中的 tree 命令. # 直接输入 `tree` 命令,正确响应并且无中文乱码. G:\\sublime\\test>tree 卷 工作 的文件夹 PATH 列表 卷序列号为 00000093 CC3C:50D0 G:. ├─cmd └─git # 输入 `cmd tree` 命令,虽无报错,但也没有正确响应. G:\\sublime\\test>cmd tree Microsoft Windows [版本 6.3.9600] (c) 2013 Microsoft Corporation。保留所有权利。 cmd 中直接输入 tree 命令即可,无需通过 cmd tree 这种方式,还以为你要调用 cmd 命令呢! 因此,我们需要告诉git bash 要通过 cmd 去调用下 tree 命令. # 注意看前缀是 `snowdreams1006@home MINGW64` 表明当前处于 `git bash` 环境 snowdreams1006@home MINGW64 /g/sublime/test # 输入 `cmd tree` 命令,虽无报错,但也没有正确响应,并且仍然有中文乱码. $ cmd tree Microsoft Windows [▒汾 6.3.9600] (c) 2013 Microsoft Corporation▒▒▒▒▒▒▒▒▒▒Ȩ▒▒▒▒ # 输出 `tree` 命令,正确响应但有中文乱码.此时命令行前缀已经更改为 `G:\\sublime\\test>` 表明当前不再处于`git bash` 环境! G:\\sublime\\test>tree tree ▒▒ ▒▒▒▒ ▒▒▒ļ▒▒▒ PATH ▒б▒ ▒▒▒▒▒к▒Ϊ 0000006B CC3C:50D0 G:. ▒▒▒▒cmd ▒▒▒▒git 通过上述操作结果来看,不难发现以下问题. cmd tree 命令切换到 cmd 环境,并且tree 命令并没有执行. 换句话说,cmd tree 和 cmd dir 或者 cmd 的作用相同,都是切换了当前 bash 环境. 进入 cmd 命令行运行 tree 能够得到正确响应,但存在中文乱码. 想要退出 cmd 环境,Ctrl + C 组合即可重新回到 git bash 环境. 由此可见,不加任何参数冒昧进入到 cmd 环境还是比较麻烦的,因此下面提供带参数的命令帮助我们阅后即焚. cmd //c tree 命令,阅后即焚,表示执行完立即退出. snowdreams1006@home MINGW64 /g/sublime/test $ cmd //c tree ▒▒ ▒▒▒▒ ▒▒▒ļ▒▒▒ PATH ▒б▒ ▒▒▒▒▒к▒Ϊ 00000008 CC3C:50D0 G:. ▒▒▒▒cmd ▒▒▒▒git snowdreams1006@home MINGW64 /g/sublime/test $ 执行命令前后我们都在 git bash 环境并且在 cmd 中得到正确响应结果,唯一的区别就是多加了 //c 参数,表示执行完命令立即退出 cmd 环境. 优雅调用 cmd 简单总结下,如何在 git bash 中借助 cmd 实现 tree 命令. tree.com : 补全调用命令后缀名,直接调用系统命令. cmd //c tree : 借助 cmd 运行 tree 命令,从而实现调用 tree 的目的. 这两种方式都存在中文乱码问题,即使设置了终端的编码方式也没有解决乱码. 调用 tree 命令的目的已经达到,没有解决的问题是中文乱码. 解决问题最快速的方式是百度一下或者从官网寻求帮助,这次我选择后者,因为百度一下人人都会,不用我再讲了吧! 简单解释下这段话的意思: 如果在 mintty 终端调用原生 cmd 程序,简单的输出指令没有什么问题,交互指令可能存在问题. 因此建议使用 winpty 进行包装再调用原生 cmd 程序. winpty 是一种提供与cmd 通信的软件包,详情请参考https://github.com/rprichard/winpty 有什么神奇之处?不妨加上 winpty 试试看! snowdreams1006@home MINGW64 /g/sublime/test # `winpty` + `tree.com` : 正常输出且无中文乱码 $ winpty tree.com 卷 工作 的文件夹 PATH 列表 卷序列号为 00000074 CC3C:50D0 G:. ├─cmd └─git snowdreams1006@home MINGW64 /g/sublime/test # `winpty` + `cmd //c tree` : 正常输出且无中文乱码 $ winpty cmd //c tree 卷 工作 的文件夹 PATH 列表 卷序列号为 000000B3 CC3C:50D0 G:. ├─cmd └─git snowdreams1006@home MINGW64 /g/sublime/test $ 果然是神药,一下子就治好了我多年的老寒腿啊! winpty tree.com : 不叫小名而叫全称,直接调用系统命令 winpty cmd //c tree : 假借他人之手,变相调用系统命令 上文中说设置文件编码应该能够解决中文乱码问题结果仍然有乱码,猜测是 bug ,现在没有打脸吧? 既然已经提供了解决方案,那文章是不是应该到此为止了呢? 不不不,远远还没结束,这只是开胃小菜,好戏还在后头呢. 更何况这命令也忒长了,记不住啊! 很简单,可以设置别名啊,把常用命令设置成别名,这样就记住啦! 输入 alias 命令没有报错,说明目前环境是支持设置别名的. snowdreams1006@home MINGW64 /g/sublime/test $ alias alias ll='ls -l' alias ls='ls -F --color=auto --show-control-chars' alias node='winpty node.exe' 按照 linux 的操作习惯,命令行设置的一般都是临时性的,想要永久生效,都要写入到文件中,别名这种当然要一劳永逸设置成永久文件. snowdreams1006@home MINGW64 /g/sublime/test $ cat /etc/bashrc cat: /etc/bashrc: No such file or directory snowdreams1006@home MINGW64 /g/sublime/test $ cat ~/.bashrc cat: /c/Users/snowdreams1006/.bashrc: No such file or directory 竟然配置文件都不存在? 当然不存在了啊!快醒醒,你是在 Windows 系统上并不是 Linux 系统,上哪给你弄这些配置文件去? 脑海中迅速闪现哲学基本问题: 我是谁,我在那,我在干什么? 我是 Windows 系统用户,正在 git bash 命令行中试图设置别名,没有找到类似于 linux 配置文件. 既然你明白你何出来,那你去那里看看有没有什么发现? snowdreams1006@home MINGW64 /g/sublime/test $ cd /e/git snowdreams1006@home MINGW64 /e/git $ winpty tree.com 卷 软件 的文件夹 PATH 列表 卷序列号为 00000063 223E:7300 E:. ├─bin ├─cmd ├─dev │ ├─mqueue │ └─shm ├─etc │ ├─pkcs11 │ ├─pki │ │ └─ca-trust │ │ ├─extracted │ │ │ ├─java │ │ │ ├─openssl │ │ │ └─pem │ │ └─source │ │ └─anchors │ ├─profile.d │ └─ssh ├─mingw64 │ ├─bin │ ├─doc │ │ └─git-credential-manager │ ├─etc │ │ ├─pkcs11 │ │ └─pki │ │ └─ca-trust │ │ └─extracted │ │ ├─java │ │ ├─openssl │ │ └─pem │ ├─lib │ │ ├─dde1.4 │ │ ├─engines │ │ ├─itcl4.0.4 │ │ ├─p11-kit │ │ ├─pkcs11 │ │ ├─reg1.3 │ │ ├─sqlite3.11.0 │ │ ├─tcl8 │ │ │ ├─8.4 │ │ │ │ └─platform │ │ │ ├─8.5 │ │ │ └─8.6 │ │ │ └─tdbc │ │ ├─tcl8.6 │ │ │ ├─encoding │ │ │ ├─http1.0 │ │ │ ├─msgs │ │ │ ├─opt0.4 │ │ │ └─tzdata │ │ │ ├─Africa │ │ │ ├─America │ │ │ │ ├─Argentina │ │ │ │ ├─Indiana │ │ │ │ ├─Kentucky │ │ │ │ └─North_Dakota │ │ │ ├─Antarctica │ │ │ ├─Arctic │ │ │ ├─Asia │ │ │ ├─Atlantic │ │ │ ├─Australia │ │ │ ├─Brazil │ │ │ ├─Canada │ │ │ ├─Chile │ │ │ ├─Etc │ │ │ ├─Europe │ │ │ ├─Indian │ │ │ ├─Mexico │ │ │ ├─Pacific │ │ │ ├─SystemV │ │ │ └─US │ │ ├─thread2.7.3 │ │ └─tk8.6 │ │ ├─demos │ │ │ └─images │ │ ├─images │ │ ├─msgs │ │ └─ttk │ ├─libexec │ │ └─git-core │ │ └─mergetools │ ├─share │ │ ├─antiword │ │ ├─doc │ │ │ ├─connect │ │ │ ├─git-doc │ │ │ │ ├─howto │ │ │ │ └─technical │ │ │ └─nghttp2 │ │ ├─gettext-0.19.7 │ │ │ └─its │ │ ├─git │ │ │ ├─bindimage.txt │ │ │ └─completion │ │ ├─git-core │ │ │ └─templates │ │ │ ├─hooks │ │ │ └─info │ │ ├─git-gui │ │ │ └─lib │ │ ├─gitweb │ │ │ └─static │ │ ├─licenses │ │ │ ├─bzip2 │ │ │ ├─expat │ │ │ ├─gcc-libs │ │ │ ├─gettext │ │ │ │ ├─gettext-runtime │ │ │ │ │ ├─intl │ │ │ │ │ └─libasprintf │ │ │ │ ├─gettext-tools │ │ │ │ │ └─gnulib-lib │ │ │ │ │ └─libxml │ │ │ │ └─gnulib-local │ │ │ │ └─lib │ │ │ │ └─libxml │ │ │ ├─libffi │ │ │ ├─libiconv │ │ │ │ └─libcharset │ │ │ ├─libssh2 │ │ │ ├─libsystre │ │ │ ├─libtasn1 │ │ │ ├─libtre │ │ │ ├─libwinpthread │ │ │ │ └─mingw-w64-libraries │ │ │ │ └─winpthreads │ │ │ ├─openssl │ │ │ ├─wineditline │ │ │ └─zlib │ │ ├─nghttp2 │ │ ├─p11-kit │ │ │ └─modules │ │ ├─perl5 │ │ │ └─site_perl │ │ │ └─Git │ │ │ └─SVN │ │ │ └─Memoize │ │ └─pki │ │ └─ca-trust-source │ └─ssl │ └─certs ├─tmp └─usr ├─bin │ ├─core_perl │ └─vendor_perl ├─lib │ ├─awk │ ├─coreutils │ ├─gawk │ ├─gnupg │ │ └─gnupg │ ├─openssl │ │ └─engines │ ├─p11-kit │ ├─perl5 │ │ ├─core_perl │ │ │ ├─auto │ │ │ │ ├─arybase │ │ │ │ ├─attributes │ │ │ │ ├─B │ │ │ │ ├─Compress │ │ │ │ │ └─Raw │ │ │ │ │ ├─Bzip2 │ │ │ │ │ └─Zlib │ │ │ │ ├─Cwd │ │ │ │ ├─Data │ │ │ │ │ └─Dumper │ │ │ │ ├─DB_File │ │ │ │ ├─Devel │ │ │ │ │ ├─Peek │ │ │ │ │ └─PPPort │ │ │ │ ├─Digest │ │ │ │ │ ├─MD5 │ │ │ │ │ └─SHA │ │ │ │ ├─Encode │ │ │ │ │ ├─Byte │ │ │ │ │ ├─CN │ │ │ │ │ ├─EBCDIC │ │ │ │ │ ├─JP │ │ │ │ │ ├─KR │ │ │ │ │ ├─Symbol │ │ │ │ │ ├─TW │ │ │ │ │ └─Unicode │ │ │ │ ├─Fcntl │ │ │ │ ├─File │ │ │ │ │ ├─DosGlob │ │ │ │ │ └─Glob │ │ │ │ ├─Filter │ │ │ │ │ └─Util │ │ │ │ │ └─Call │ │ │ │ ├─GDBM_File │ │ │ │ ├─Hash │ │ │ │ │ └─Util │ │ │ │ │ └─FieldHash │ │ │ │ ├─I18N │ │ │ │ │ └─Langinfo │ │ │ │ ├─IO │ │ │ │ ├─IPC │ │ │ │ │ └─SysV │ │ │ │ ├─List │ │ │ │ │ └─Util │ │ │ │ ├─Math │ │ │ │ │ └─BigInt │ │ │ │ │ └─FastCalc │ │ │ │ ├─MIME │ │ │ │ │ └─Base64 │ │ │ │ ├─mro │ │ │ │ ├─NDBM_File │ │ │ │ ├─ODBM_File │ │ │ │ ├─Opcode │ │ │ │ ├─PerlIO │ │ │ │ │ ├─encoding │ │ │ │ │ ├─mmap │ │ │ │ │ ├─scalar │ │ │ │ │ └─via │ │ │ │ ├─POSIX │ │ │ │ ├─re │ │ │ │ ├─SDBM_File │ │ │ │ ├─Socket │ │ │ │ ├─Storable │ │ │ │ ├─Sys │ │ │ │ │ ├─Hostname │ │ │ │ │ └─Syslog │ │ │ │ ├─threads │ │ │ │ │ └─shared │ │ │ │ ├─Tie │ │ │ │ │ └─Hash │ │ │ │ │ └─NamedCapture │ │ │ │ ├─Time │ │ │ │ │ ├─HiRes │ │ │ │ │ └─Piece │ │ │ │ ├─Unicode │ │ │ │ │ └─Collate │ │ │ │ ├─Win32 │ │ │ │ ├─Win32API │ │ │ │ │ └─File │ │ │ │ └─Win32CORE │ │ │ ├─B │ │ │ ├─Compress │ │ │ │ └─Raw │ │ │ ├─CORE │ │ │ ├─Data │ │ │ ├─Devel │ │ │ ├─Digest │ │ │ ├─Encode │ │ │ │ ├─CN │ │ │ │ ├─JP │ │ │ │ ├─KR │ │ │ │ ├─MIME │ │ │ │ │ └─Header │ │ │ │ └─Unicode │ │ │ ├─File │ │ │ │ └─Spec │ │ │ ├─Filter │ │ │ │ └─Util │ │ │ ├─Hash │ │ │ │ └─Util │ │ │ ├─I18N │ │ │ ├─IO │ │ │ │ └─Socket │ │ │ ├─IPC │ │ │ ├─List │ │ │ │ └─Util │ │ │ ├─Math │ │ │ │ └─BigInt │ │ │ ├─MIME │ │ │ ├─PerlIO │ │ │ ├─Scalar │ │ │ ├─Sub │ │ │ ├─Sys │ │ │ ├─threads │ │ │ ├─Tie │ │ │ │ └─Hash │ │ │ ├─Time │ │ │ ├─Unicode │ │ │ │ └─Collate │ │ │ └─Win32API │ │ └─vendor_perl │ │ ├─auto │ │ │ ├─HTML │ │ │ │ └─Parser │ │ │ ├─Net │ │ │ │ └─SSLeay │ │ │ ├─SVN │ │ │ │ ├─_Client │ │ │ │ ├─_Core │ │ │ │ ├─_Delta │ │ │ │ ├─_Fs │ │ │ │ ├─_Ra │ │ │ │ ├─_Repos │ │ │ │ └─_Wc │ │ │ └─Term │ │ │ └─ReadKey │ │ ├─HTML │ │ ├─Net │ │ │ └─SSLeay │ │ ├─SVN │ │ └─Term │ ├─pkcs11 │ ├─sasl2 │ ├─ssh │ ├─tar │ └─terminfo │ ├─63 │ ├─64 │ └─78 ├─libexec ├─share │ ├─bash-completion │ │ └─completions │ ├─cygwin │ ├─git │ ├─gnupg │ ├─licenses │ │ ├─curl │ │ ├─dos2unix │ │ ├─expat │ │ ├─file │ │ ├─gcc-libs │ │ ├─libffi │ │ ├─libsasl │ │ ├─libsqlite │ │ ├─libssh2 │ │ ├─mintty │ │ ├─ncurses │ │ ├─openssh │ │ ├─openssl │ │ ├─p11-kit │ │ ├─perl-Net-SSLeay │ │ ├─perl-TermReadKey │ │ ├─unzip │ │ ├─vim │ │ └─zlib │ ├─misc │ ├─p11-kit │ │ └─modules │ ├─perl5 │ │ ├─core_perl │ │ │ ├─App │ │ │ │ └─Prove │ │ │ │ └─State │ │ │ │ └─Result │ │ │ ├─Archive │ │ │ │ └─Tar │ │ │ ├─Attribute │ │ │ ├─autodie │ │ │ │ ├─exception │ │ │ │ └─Scope │ │ │ ├─B │ │ │ ├─Carp │ │ │ ├─Class │ │ │ ├─Compress │ │ │ ├─Config │ │ │ │ └─Perl │ │ │ ├─CPAN │ │ │ │ ├─Exception │ │ │ │ ├─FTP │ │ │ │ ├─HTTP │ │ │ │ ├─Kwalify │ │ │ │ ├─LWP │ │ │ │ ├─Meta │ │ │ │ └─Plugin │ │ │ ├─DBM_Filter │ │ │ ├─Devel │ │ │ ├─Digest │ │ │ ├─Encode │ │ │ ├─encoding │ │ │ ├─Exporter │ │ │ ├─ExtUtils │ │ │ │ ├─CBuilder │ │ │ │ │ └─Platform │ │ │ │ │ └─Windows │ │ │ │ ├─Command │ │ │ │ ├─Constant │ │ │ │ ├─Liblist │ │ │ │ ├─MakeMaker │ │ │ │ │ └─version │ │ │ │ ├─ParseXS │ │ │ │ └─Typemaps │ │ │ ├─File │ │ │ ├─Filter │ │ │ ├─Getopt │ │ │ ├─HTTP │ │ │ ├─I18N │ │ │ │ └─LangTags │ │ │ ├─IO │ │ │ │ ├─Compress │ │ │ │ │ ├─Adapter │ │ │ │ │ ├─Base │ │ │ │ │ ├─Gzip │ │ │ │ │ ├─Zip │ │ │ │ │ └─Zlib │ │ │ │ ├─Socket │ │ │ │ └─Uncompress │ │ │ │ └─Adapter │ │ │ ├─IPC │ │ │ ├─JSON │ │ │ │ └─PP │ │ │ ├─Locale │ │ │ │ ├─Codes │ │ │ │ └─Maketext │ │ │ ├─Math │ │ │ │ ├─BigFloat │ │ │ │ └─BigInt │ │ │ ├─Memoize │ │ │ ├─Module │ │ │ │ ├─CoreList │ │ │ │ └─Load │ │ │ ├─Net │ │ │ │ └─FTP │ │ │ ├─overload │ │ │ ├─Params │ │ │ ├─Parse │ │ │ │ └─CPAN │ │ │ ├─Perl │ │ │ ├─PerlIO │ │ │ │ └─via │ │ │ ├─Pod │ │ │ │ ├─Perldoc │ │ │ │ ├─Simple │ │ │ │ └─Text │ │ │ ├─Search │ │ │ ├─TAP │ │ │ │ ├─Formatter │ │ │ │ │ ├─Console │ │ │ │ │ └─File │ │ │ │ ├─Harness │ │ │ │ └─Parser │ │ │ │ ├─Iterator │ │ │ │ ├─Result │ │ │ │ ├─Scheduler │ │ │ │ ├─SourceHandler │ │ │ │ └─YAMLish │ │ │ ├─Term │ │ │ ├─Test │ │ │ │ ├─Builder │ │ │ │ │ ├─IO │ │ │ │ │ └─Tester │ │ │ │ ├─Tester │ │ │ │ └─use │ │ │ ├─Text │ │ │ ├─Thread │ │ │ ├─Tie │ │ │ ├─Time │ │ │ ├─Unicode │ │ │ │ └─Collate │ │ │ │ └─CJK │ │ │ ├─unicore │ │ │ │ ├─lib │ │ │ │ │ ├─Age │ │ │ │ │ ├─Alpha │ │ │ │ │ ├─Bc │ │ │ │ │ ├─BidiC │ │ │ │ │ ├─BidiM │ │ │ │ │ ├─Blk │ │ │ │ │ ├─Bpt │ │ │ │ │ ├─Cased │ │ │ │ │ ├─Ccc │ │ │ │ │ ├─CE │ │ │ │ │ ├─CI │ │ │ │ │ ├─CompEx │ │ │ │ │ ├─CWCF │ │ │ │ │ ├─CWCM │ │ │ │ │ ├─CWKCF │ │ │ │ │ ├─CWL │ │ │ │ │ ├─CWT │ │ │ │ │ ├─CWU │ │ │ │ │ ├─Dash │ │ │ │ │ ├─Dep │ │ │ │ │ ├─DI │ │ │ │ │ ├─Dia │ │ │ │ │ ├─Dt │ │ │ │ │ ├─Ea │ │ │ │ │ ├─Ext │ │ │ │ │ ├─Gc │ │ │ │ │ ├─GCB │ │ │ │ │ ├─GrBase │ │ │ │ │ ├─Hex │ │ │ │ │ ├─Hst │ │ │ │ │ ├─Hyphen │ │ │ │ │ ├─IDC │ │ │ │ │ ├─Ideo │ │ │ │ │ ├─IDS │ │ │ │ │ ├─In │ │ │ │ │ ├─Jg │ │ │ │ │ ├─Jt │ │ │ │ │ ├─Lb │ │ │ │ │ ├─LOE │ │ │ │ │ ├─Lower │ │ │ │ │ ├─Math │ │ │ │ │ ├─NChar │ │ │ │ │ ├─NFCQC │ │ │ │ │ ├─NFDQC │ │ │ │ │ ├─NFKCQC │ │ │ │ │ ├─NFKDQC │ │ │ │ │ ├─Nt │ │ │ │ │ ├─Nv │ │ │ │ │ ├─PatSyn │ │ │ │ │ ├─PatWS │ │ │ │ │ ├─Perl │ │ │ │ │ ├─QMark │ │ │ │ │ ├─SB │ │ │ │ │ ├─Sc │ │ │ │ │ ├─Scx │ │ │ │ │ ├─SD │ │ │ │ │ ├─STerm │ │ │ │ │ ├─Term │ │ │ │ │ ├─UIdeo │ │ │ │ │ ├─Upper │ │ │ │ │ ├─WB │ │ │ │ │ ├─XIDC │ │ │ │ │ └─XIDS │ │ │ │ └─To │ │ │ ├─User │ │ │ ├─version │ │ │ ├─warnings │ │ │ └─Win32API │ │ │ └─File │ │ └─vendor_perl │ │ ├─Authen │ │ │ └─SASL │ │ │ └─Perl │ │ ├─Convert │ │ ├─Date │ │ │ └─Language │ │ ├─Encode │ │ ├─Error │ │ ├─File │ │ ├─HTML │ │ ├─HTTP │ │ │ ├─Cookies │ │ │ ├─Headers │ │ │ └─Request │ │ ├─IO │ │ │ └─Socket │ │ │ └─SSL │ │ ├─LWP │ │ │ ├─Authen │ │ │ └─Protocol │ │ ├─Mail │ │ │ ├─Field │ │ │ └─Mailer │ │ ├─MIME │ │ │ ├─Decoder │ │ │ ├─Field │ │ │ └─Parser │ │ ├─Net │ │ │ ├─HTTP │ │ │ └─SMTP │ │ ├─Time │ │ ├─URI │ │ │ ├─file │ │ │ └─urn │ │ └─WWW │ │ └─RobotRules │ ├─pki │ │ └─ca-trust-source │ ├─tabset │ ├─terminfo │ │ ├─63 │ │ ├─64 │ │ └─78 │ └─vim │ └─vim74 │ ├─autoload │ │ └─xml │ ├─colors │ ├─compiler │ ├─doc │ ├─ftplugin │ ├─indent │ ├─keymap │ ├─macros │ │ ├─hanoi │ │ ├─life │ │ ├─maze │ │ └─urm │ ├─pack │ │ └─dist │ │ └─opt │ │ ├─dvorak │ │ │ ├─dvorak │ │ │ └─plugin │ │ ├─editexisting │ │ │ └─plugin │ │ ├─justify │ │ │ └─plugin │ │ ├─matchit │ │ │ ├─doc │ │ │ └─plugin │ │ ├─shellmenu │ │ │ └─plugin │ │ └─swapmouse │ │ └─plugin │ ├─plugin │ ├─print │ ├─spell │ ├─syntax │ ├─tools │ └─tutor └─ssl ├─certs └─misc 看到熟悉的 ./etc/bash.bashrc 文件,顿时亲切不少,设置一下别名再说. snowdreams1006@home MINGW64 /e/git $ echo \"# Set alias for tree command\" >> ./etc/bash.bashrc snowdreams1006@home MINGW64 /e/git $ echo \"alias tree='winpty tree.com'\" >> ./etc/bash.bashrc snowdreams1006@home MINGW64 /e/git $ source ./etc/bash.bashrc 现在测试一下能否正确打印出目录树: snowdreams1006@home MINGW64 /e/git $ cd /g/sublime/test snowdreams1006@home MINGW64 /g/sublime/test $ tree 卷 工作 的文件夹 PATH 列表 卷序列号为 000000A3 CC3C:50D0 G:. ├─cmd └─git 亲测有效,通过设置别名的方式可以简化命令,从而实现在 git bash 中优雅调用 tree 命令. 固执少年一意孤行 少年既然不听劝,那我只好和你一起一意孤行. git bash 不支持 tree 命令,意味着 mintty 终端不支持 tree 命令,但 mintty 既然作为一款优秀的终端模拟器不可能不支持 tree 命令,否则 cygwin ,msys2 和 mingw 等系统不可能将其作为默认终端. 回想起 linux 系统,最小化安装版也不支持 tree 命令,通过包管理工具自行扩展即可支持 tree 命令. 因此,思路有两种,像 linux 那样通过包管理工具安装 tree 命令,或者通过源码编译方式扩展 tree 命令. 第一种需要包管理工具,而git bash 使用的是 mintty 终端,并没有提供相应的包管理工具. 所以想要通过包管理工具进行安装 tree 命令也是无路可走. 包管理工具安装 如果能够提供包管理工具,那么我们就可以像 linux 系统那样安装第三方命令一样,安装 tree 命令了. 首先想到的是 mintty 官网有没有相关说明,遗憾的是,mintty 本身一般是通过包管理工具安装的,单独的终端并没有包管理的环境,因此无法调用相关命令. Administrator@snowdreams1006 MINGW64 /f/workspace/test $ mingw-get bash: mingw-get: command not found Administrator@snowdreams1006 MINGW64 /f/workspace/test $ pacman bash: pacman: command not found 然而,小小的挫折是不会轻易放弃的,既然 mintty 官网不能提供有效的帮助,那我们回到最初安装 git 的地方,看一下 git 能否提供相关的包管理工具. 频繁出现 Git For Windows 名词,根据软件的命令规则,Git for Windows 可能是独立的软件,更何况 git bash 集成的终端也不是自身研发的终端而是第三方的 mintty 终端. 所以,我们有理由相信 Git for Windows 是另外的团队在维护,而不是 Git 团队. git-for-windows 官网: https://gitforwindows.org/ 根据官方说明,安装后正在下载相关依赖,下载速度比较慢的话,请自行解决. 下载完成后,原来的 cmd 窗口会自动关闭并且打开新的 git bash 窗口. Administrator@snowdreams1006 MINGW64 / (master) $ sdk help The 'sdk' shell function helps you to get up and running with the Git for Windows SDK. The available subcommands are: create-desktop-icon: install a desktop icon that starts the Git for Windows SDK Bash. cd : initialize/update a worktree and cd into it. Known projects: git git-extra msys2-runtime installer build-extra MINGW-packages MSYS2-packages mingw-w64-busybox mingw-w64-curl mingw-w64-cv2pdb mingw-w64-git mingw-w64-git-credential-manager mingw-w64-git-lfs mingw-w64-git-sizer mingw-w64-wintoast bash curl gawk git-flow gnupg heimdal mintty nodejs openssh openssl perl perl-HTML-Parser perl-Locale-Gettext perl-Net-SSLeay perl-TermReadKey perl-XML-Parser perl-YAML-Syck subversion tig init : initialize and/or update a worktree. Known projects are the same as for the 'cd' command. build : builds one of the following: git-and-installer git git-extra msys2-runtime installer mingw-w64-busybox mingw-w64-curl mingw-w64-cv2pdb mingw-w64-git mingw-w64-git-credential-manager mingw-w64-git-lfs mingw-w64-git-sizer mingw-w64-wintoast bash curl gawk git-flow gnupg heimdal mintty nodejs openssh openssl perl perl-HTML-Parser perl-Locale-Gettext perl-Net-SSLeay perl-TermReadKey perl-XML-Parser perl-YAML-Syck subversion tig edit : edit a well-known file. Well-known files are: git-sdk.sh sdk.completion ReleaseNotes.md install.iss reload: reload the 'sdk' function. 现在安装完成后,我们再次打开 Git for Windows 的开发文档简介,从中不难发现该项目使用了 MSYS2 项目,那么问题迎刃而解. 根据科普知识,我们知道 MSYS2 和 MinGW 都是操作系统,而 Git For Windows 将两者结合在一起,默认使用 MSYS2 的包管理工具. Administrator@snowdreams1006 MINGW64 / (master) $ Pacman -h 用法: Pacman [...] 操作: Pacman {-h --help} Pacman {-V --version} Pacman {-D --database} Pacman {-F --files} [选项] [软件包] Pacman {-Q --query} [选项] [软件包] Pacman {-R --remove} [选项] Pacman {-S --sync} [选项] [软件包] Pacman {-T --deptest} [选项] [软件包] Pacman {-U --upgrade} [选项] 使用 'Pacman {-h --help}' 及某个操作以查看可用选项 激动人心的时刻就要来临,在正式使用 Pacman 安装 tree 命令外,我们再次检查当前系统环境以确保没有 git bash 无法调用 tree 命令. Administrator@snowdreams1006 MINGW64 / (master) $ tree bash: tree: 未找到命令 调用 Pacman -S tree 命令安装 tree 命令. Administrator@snowdreams1006 MINGW64 / (master) $ Pacman -S tree 正在解析依赖关系... 正在查找软件包冲突... 软件包 (1) tree-1.8.0-1 下载大小: 0.05 MiB 全部安装大小： 0.07 MiB :: 进行安装吗？ [Y/n] y 警告：没有 /var/cache/pacman/pkg/ 缓存存在，正在创建... :: 正在获取软件包...... tree-1.8.0-1-x86_64 51.1 KiB 211K/s 00:00 [#####################] 100% (1/1) 正在检查密钥环里的密钥 [#####################] 100% (1/1) 正在检查软件包完整性 [#####################] 100% (1/1) 正在加载软件包文件 [#####################] 100% (1/1) 正在检查文件冲突 [#####################] 100% (1/1) 正在检查可用存储空间 [#####################] 100% :: 正在处理软件包的变化... (1/1) 正在安装 tree 验证安装成功,切换到测试目录调用 tree 命令真的打印出了目录树结构. Administrator@snowdreams1006 MINGW64 / (master) $ pwd / Administrator@snowdreams1006 MINGW64 / (master) $ cd /f/workspace/test Administrator@snowdreams1006 MINGW64 /f/workspace/test $ tree . ├── cmd └── gitbash 2 directories, 0 files tree.exe 文件确实已经存在,通过这样方式当然可以安装任意第三方命令了呢! Administrator@snowdreams1006 MINGW64 / (master) $ pwd / Administrator@snowdreams1006 MINGW64 / (master) $ ls usr/bin/tree.exe usr/bin/tree.exe* Administrator@snowdreams1006 MINGW64 / (master) $ ls usr/bin/tree.exe usr/bin/tree.exe* 然而,事情还没有结束,虽然打印当前路径显示的是在 / ,但是如果从普通的 git bash 命令行窗口进入 /,发现他们并不一致! 开发版左上角文字: SDK-64,普通版左上角: MinGW64. 事情应该不至于这么复杂,我猜测如果进入到 git sdk 的安装目录,应该是一样的! 源码编译安装 还有一种源码编译安装方式,可以猜想到的是将会比较麻烦,不仅要安装 c 编译环境,还可能会面临如何移植到 Windows 环境的问题. 恕再下先行一步,告辞! 但是老司机怎么能收走就走,不是说好一起闯天下得嘛? 然而,心有余而力不足,编译安装再到测试确实是不少挑战,最重要的是,电脑太卡了等不了. 所以,收集到了一些资料方便有条件的小伙伴去研究吧! 下载链接: ftp://mama.indstate.edu/linux/tree/tree-1.8.0.tgz 在 mingw ,msys2 或者 cygwin 系统上编译安装 tree 的 c 文件,最终生成 tree.exe 可执行文件. 独立安装 c 编译环境,生成的 tree.exe 可执行文件再想办法兼容到 git bash 所支持的 .exe 类型,或许也不用转换. 请参考 linux 系统的 tree 命令源码: http://mama.indstate.edu/users/ice/tree/ 我觉得我还可以再坚持一会,虽然不能从头开始编译生成 tree.exe 可执行文件,但是研究了这么多朋友圈关系,足够我找到解决方案了. tree 命令的源码文件编译成 tree.exe 可执行文件比较费劲,但是可以找到已经编译好的文件啊. 说道这里,不得不提一下神奇的 sourceforge 网站,提供源码和下载网站. 前面我们一直在说 mintty 终端模拟器也好,或者 mingw ,msys2 和 cygwin 操作系统也罢,他们或多或少和 GNU 有一些联系,而 GNU 是自由软件操作系统,源码会随程序一同发布. 所以我们应该可以从 sourceforge 网站上找到些蛛丝马迹,说不定还有打包好的可执行文件呢,如果那样的话就不用我们手动编译安装了! 功夫不负有心人,竟然真的找到了,搜索 GNU 发现了 gnuwin32 项目,完整提供了原生命令,其中就有我们需要的 tree 命令. 下载链接: https://sourceforge.net/projects/gnuwin32/files/tree/1.5.2.2/tree-1.5.2.2-bin.zip/download 于是下载二进制文件找到其中的 /bin/tree.exe 并将其复制到 /git/usr/bin 目录下,这样 git bash 本身就支持 tree 命令了. 首先清除掉上一步设置的别名,防止干扰以确保此二进制文件真实有效. snowdreams1006@home MINGW64 /g/sublime/test # 切换到 `git` 安装目录 $ cd /e/git snowdreams1006@home MINGW64 /e/git # 编辑 `bash.bashrc` 配置文件,移除别名 $ vim ./etc/bash.bashrc snowdreams1006@home MINGW64 /e/git # 查看配置文件内容,别名设置已移除 $ tail ./etc/bash.bashrc [[ \"$-\" != *i* ]] && return # Set a default prompt of: user@host, MSYSTEM variable, and current_directory #PS1='\\[\\e]0;\\w\\a\\]\\n\\[\\e[32m\\]\\u@\\h \\[\\e[35m\\]$MSYSTEM\\[\\e[0m\\] \\[\\e[33m\\]\\w\\[\\e[0m\\]\\n\\$ ' # Uncomment to use the terminal colours set in DIR_COLORS # eval \"$(dircolors -b /etc/DIR_COLORS)\" # Fixup git-bash in non login env shopt -q login_shell || . /etc/profile.d/git-prompt.sh snowdreams1006@home MINGW64 /e/git # 刷新配置文件,使其立即生效 $ source ./etc/bash.bashrc snowdreams1006@home MINGW64 /e/git # 移除 `tree` 别名,适用于命令行方式设置而不是文件设置 $ unalias tree snowdreams1006@home MINGW64 /e/git # 运行 `tree` 命令,确保已经无法通过别名方式调用系统的 `tree.com` 命令 $ tree bash: tree: command not found 真的成功添加了 tree.exe 命令,明显和 cmd 自带的 tree.com 命令不一致. snowdreams1006@home MINGW64 /e/git $ cd /g/sublime/test snowdreams1006@home MINGW64 /g/sublime/test # 扩展命令 `tree` 帮助信息 $ tree.exe --help usage: tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset] [--filelimit #] [] -a All files are listed. -d List directories only. -l Follow symbolic links like directories. -f Print the full path prefix for each file. -i Don't print indentation lines. -q Print non-printable characters as '?'. -N Print non-printable characters as is. -p Print the protections for each file. -u Displays file owner or UID number. -g Displays file group owner or GID number. -s Print the size in bytes of each file. -h Print the size in a more human readable way. -D Print the date of last modification. -F Appends '/', '=', '*', or '|' as per ls -F. -v Sort files alphanumerically by version. -r Sort files in reverse alphanumeric order. -t Sort files by last modification time. -x Stay on current filesystem only. -L level Descend only level directories deep. -A Print ANSI lines graphic indentation lines. -S Print with ASCII graphics indentation lines. -n Turn colorization off always (-C overrides). -C Turn colorization on always. -P pattern List only those files that match the pattern given. -I pattern Do not list files that match the given pattern. -H baseHREF Prints out HTML format with baseHREF as top directory. -T string Replace the default HTML title and H1 header with string. -R Rerun tree when max dir level reached. -o file Output to file instead of stdout. --inodes Print inode number of each file. --device Print device ID number to which each file belongs. --noreport Turn off file/directory count at end of tree listing. --nolinks Turn off hyperlinks in HTML output. --dirsfirst List directories before files. --charset X Use charset X for HTML and indentation line output. --filelimit # Do not descend dirs with more than # files in them. snowdreams1006@home MINGW64 /g/sublime/test # 原生 `tree.com` 帮助信息 $ winpty tree.com /? 卷 软件 的文件夹 PATH 列表 卷序列号为 000000CA 223E:7300 E:\\GIT\\? 无效的路径 - \\GIT\\? 没有子文件夹 虽然原生 cmd 自带的 tree.com 命令也能打印出目录结构树,但是和扩展的第三方 tree.exe 命令相比,可配置的选项实在太少,难怪固执少年会执意扩展 tree 命令. 懒人直达 如果想要在 git bash 命令行中调用 tree 命令,总结了下列几种方法. 注意: 从上到下逐渐复杂,根据自己的情况自行选择. winpty tree.com : 直接调用 cmd 内置 tree.com 命令. winpty cmd //c tree : 通知 cmd 调用 tree 命令. 安装 Git For Windows 开发版,Pacman -S tree 安装 tree 命令,然后执行 tree 调用. 下载 已编译好的 tree.exe 文件到 git bash 安装目录下的 /usr/bin 目录,然后执行 tree 命令. 回顾总结 Git 本身并不支持 Windows 系统,Git For Windows 团队为了移植到 Windows 平台,付出了很多努力,最直观的感受就是提供了 Git For Windows 软件. 由于 Git for Windows 的出色工作得到 Git 的官方认可,现在默认下载的 Git 就是来源于 Git for Windows. 但 Git 底层是运行在类 linux 系统的,这种差异必然需要 Windows 到 Linux 的中间处理层进行转换. 因此,Git for Window 背后的技术中涉及到大量的 GNU 自由软件操作系统和 WSL (Windows Subsystem for Linux) 的相关代码. 正是由于背后千丝万缕的联系,为我们扩展 git bash 命令行提供了一些思路. 基于 Cygwin 系统进行扩展,安装完整的操作系统,模拟出 linux 运行环境,在 Windows 上也能找到 linux 的感觉. 当然,Cygwin 由于比较完整,体积也相当大,所以在此衍生出 MSYS2 和 MinGW 操作系统. 殊途同归,他们的底层架构有些不同,但目的是一致的,都是在 Windows 上找到 Linux 的感觉,并且他们的终端命令行几乎都是 mintty . 在终端中调用各自的包管理工具即可轻松扩展第三方命令,此外,由于他们大多数都有 c 编译环境,因此也可以选择重新编译安装. 所以 git bash 命令行看起来下像是 git 官方支持,其实却是由 Git for Windows 组织独立维护的开源项目. 默认 Git for Windows 没有提供包管理工具,开发版却默认集成了 MSYS2 环境.也就是说我们可以用 Pacman 来安装 tree 命令. 最后稍微总结本文知识要点: git bash 命令行并不能完全替代 cmd 命令,两者互补才能相得益彰. git bash 命令行中调用 cmd 程序需要通过 winpty 调用,比如 winpty tree.com git bash 默认安装程序无包管理工具等高级功能,如需扩展自定义命令应该下载Git for Windows SDK. git bash 环境兼容 MSYS2 ,MinGW ,Cygwin 等系列自由软件,其他类似系统的 tree.exe 可能并不支持. 好了,说了这么多,小伙伴们 get 到如何在 git bash 使用(扩展) tree 命令了吗? 如有疑问,欢迎留言告诉我! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/tools/git-bash-tree.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/tools/git-bash-extend-up.html":{"url":"git/tools/git-bash-extend-up.html","title":"git bash 扩展命令(上)","keywords":"","body":"git bash 扩展命令(上) 已投稿给脚本之家公众号,如需查看请访问: 三招教你轻松扩展 git bash 命令(上) https://mp.weixin.qq.com/s/29laLQ9k1YAPS_Rx3IAeQQ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/tools/git-bash-extend-up.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/tools/git-bash-extend-middle.html":{"url":"git/tools/git-bash-extend-middle.html","title":"git bash 扩展命令(中)","keywords":"","body":"git bash 扩展命令(中) 已投稿给脚本之家公众号,如需查看请访问: 三招教你轻松扩展 git bash 命令(中) https://mp.weixin.qq.com/s/qN4KbT8Lc1pQhnDdSeHcEQ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/tools/git-bash-extend-middle.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/tools/git-bash-extend-down.html":{"url":"git/tools/git-bash-extend-down.html","title":"git bash 扩展命令(下)","keywords":"","body":"git bash 扩展命令(下) 已投稿给脚本之家公众号,如需查看请访问: 三招教你轻松扩展 git bash 命令(下) https://mp.weixin.qq.com/s/yAtGh4FiGXbzoCeKnhZ2ag var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/tools/git-bash-extend-down.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/summary/about.html":{"url":"git/summary/about.html","title":"沙海拾贝","keywords":"","body":"沙海拾贝 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/summary/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/summary/common.html":{"url":"git/summary/common.html","title":"知识速查","keywords":"","body":"知识速查 创建版本库 初始化项目 git init 从零开始创建项目 示例 git init 克隆项目 git clone 将已有项目拷贝到本地 示例 git clone git@github.com:snowdreams1006/snowdreams1006.github.io.git 添加文件 git add 将新文件或已修改文件添加到缓存区 示例 git add README.md 查看状态 git status 查看当前文件是否和上次提交内容是否有修改 示例 git status README.md 比较差异 git diff 查看当前文件和上次提交内容的具体差异 尚未缓存的修改: git diff 查看已缓存修改: git diff --cached 查看已缓存与未缓存的所有修改: git diff HEAD 显示摘要而非整个差异: git diff --stat 示例 git diff README.md 提交文件 git commit 将缓存区内容添加到版本库 示例 git commit -m \"remark\" 取消已缓存内容 git reset HEAD 将缓存区内容添加到版本库 示例 git reset HEAD 删除文件 git rm 从暂存区中移除且不保留在工作目录: git rm 强制从暂存区中移除且不保留在工作目录: git rm -f 从暂存区中移除但保留工作目录: git rm --cached 示例 git rm README.md 移动文件 git mv 移动或重命名文件,目录,软连接 示例 git mv README.md README_NEW.md commit push pull fetch merge 的区别与含义: git commit : 将本地修改过的文件提交到本地仓库中 git push : 将本地仓库的最新版本推送到远程库中 git pull : 从远程库获取最新版本到本地,并自动merge git fetch : 从远程库获取最新版本到本地,不会自动merge git merge : 将指定版本合并到当前分支 替换本地改动 丢弃当前文件修改内容,已添加到暂存区以及新文件都不会受到影响 示例 git checkout -- 丢弃本地所有改动 示例 git reset --hard 分支管理 创建分支 git branch 创建本地分支,但不自动切换新分支 示例 git branch dev 切换分支 git checkout 切换到指定分支 示例 git checkout dev 创建并切换分支 git checkout -b 创建本地分支并自动切换到新分支 示例 git checkout -b feature 合并分支 git merge 将指定分支合并到当前分支 示例 git merge dev 删除分支 git branch -d 删除指定分支 示例 git branch -d dev 列出分支 git branch 列出本地全部分支 示例 git branch 提交日志 git log 查看纳入版本库的提交日志 示例 git log 标签管理 创建标签 git tag -a 创建标签并提交备注 示例 git tag -a v1.0.0 追加标签 git tag -a 追加标签并更新备注 示例 git tag -a v0.9.0 6ad8956bc09a6a62c731711eabe796690aa6471c 删除标签 git tag -d 删除指定标签 示例 git tag -d v1.0.0 查看标签 git show 查看指定标签 示例 git show v1.0.0 列出标签 git tag 列出本地全部标签 示例 git tag var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/summary/common.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"git/summary/cheatsheet-translation.html":{"url":"git/summary/cheatsheet-translation.html","title":"备忘录[译]","keywords":"","body":"备忘录[译] 创建 | Create 克隆一个已存在的仓库 | Clone an existing repository git clone git@github.com:snowdreams1006/snowdreams1006.github.io.git 创建一个新的本地仓库 | Create a new local repository git init 本地更改 | Local Changes 工作目录中已更改文件 | Changed files in your working directory git status 已追踪文件的更改 | Changes to tracked files git diff 添加当前全部更改到下次提交版本 | Add all current changes to next commit git add . 添加文件中某些更改到下次提交版本 | Add some changes in to next commit git add -p 提交已追踪文件的全部本地更改 | Commit all local changes in tracked files git commit -a 提交上一次暂存区更改 | Commit previously staged changes git commit 更改上次提交 | Change the last commit 没有更改已发布的提交 | Don't amend publishd commits! git commit --amend 提交历史 | Commit history 显示全部提交,以最新的开头 | Show all commits,starting with newest git log 显示某个文件一段时间内的更改 | Show changes over time for a specific file git log -p 某文件是谁在什么时候更改了什么内容 | Who changed what and when in git blame 分支和标签 | Branches & Tags 列出全部已存在的分支 | List all existing branches git branch -av 切换到 HEAD 分支 | Switch HEAD branch git checkout 基于当前 HEAD 创建新分支 | Create a new branch based on your curent HEAD git branch 基于远程分支创建新的正在追踪分支 | Create a new tracking branch based on a remote branch git checkout --track 删除一个本地分支 | Delete a local branch git branch -d 为当前提交打上标签 | Make the current commit with a tag git tag 更新和发布 | Update & Publish 列出当前全部已配置的远程仓库 | List all currently configured remotes git remote -v 显示远程仓库信息 | Show information about a remote git remote show 添加的远程仓库 | Add new remote repository named git remote add 下载来自远程仓库的所有更改但是不合并到 HEAD | Download all changes from but don't integrate into HEAD git fetch 下载来自远程仓库指定分支的所有更改并且自动合并到 HEAD | Download changes and directly merge/integrate into HEAD git pull 在远程仓库上发布本地更改 | Publish local changes on a remote git push 在远程仓库上删除分支 | Delete a branch on the branch git branch -dr 发布你的标签 | Publish your tags git push --tags 合并和变基 | MERGE & REBASE 合并指定分支到你的 HEAD | Merge into your current HEAD git merge 变基到当前HEAD | Rebase your current HEAD onto 不要变基已发布的提交 | Don't rebase published commits! git rebase 取消变基 | Abort a rebase git rebase --abort 使用已配置的冲突工具去解决冲突 | Use your configured merge tool to solve conflicts git mergetool 使用编辑器手工解决冲突然后(解决之后)标记文件已解决冲突 | Use your editor to manually solve conflicts and (after resolving) mark file as resolved git add git rm 撤销 | UNDO 丢弃工作区全部更改 | Discard all local changes in your working directory git reset --hard HEAD 丢弃指定文件的本地更改 | Discard local changes in a specific file git checkout HEAD 抵消一个提交(通过产生一个新的相反的提交) | Revert a commit (by producing a new commit with contrary changes) git revert 重置当前 HEAD 指针到上一个提交...然后丢弃自那以后的全部更改 | Reset your HEAD pointer to a previous commit ... and discard all changes since then git reset --hard ...然后作为未缓存更改保存全部更改 | ... and preserve all changes as unstaged change git reset ...然后保存未提交的本地更改 | ... and preserve all changes as unstaged change git reset --keep 建议 | SUGGESTION 提交相关更改 | COMMIT RELATED CHANGES 提交应该是相关更改的包装,例如,修复两个不同的 bug 应该产生两个单独的提交. 小的提交让其他开发者更容易理解此次更改,并且万一出错方便回滚. 在暂存区这类工具以及暂存部分文件的能力下,git 很容易创建细粒度的提交. A commit should be a wrapper for related changes, For example,fixing two different bugs should produce two separete commits. Small commits make it easier for other developers to understand the changes and roll them back if something went wrong. With tools like the staging area and the ability to stage only parts of a file. Git makes it easy to create very granular commits. 经常提交 | COMMIT OFTEN 经常提交使得你的提交很小并且有助于仅提交相关更改. 此外,这样允许你更频繁地和其他人分享你的代码,对于每个人来说更容器定期合并更改,避免了遭遇合并冲突. ,很少的大提交,很少分享它们.相反很难解决冲突. Commiting often keeps your commits small and again helps you commit only related changes. Moreover,it allows you to share your code more frequently with others. That way it's easier for everyone to integrate changes regularly and avoid having merge conflicts.Having few large commits and sharing them rarely.in contrast,makes it hard to solve conflicts. 不要提交未完成工作 | DON'T COMMIT HALF-DONE WORK 你应该仅提交已完成代码,这并不意外着提交前你不得不完成一个完整的,很大的功能分支.恰恰相反,将功能分支划分成很多逻辑块并且记得早一点,频繁些提交. 如果仅仅是为了下班前仓库该有点什么就不要提交,如果你尝试提交仅仅是因为你需要一个干净的工作副本(检出分支,拉取更改),考虑使用 git 的 stash 特性. You should only commit code when it's completed. This doesn't mean you have to complete a whole ,large feature before commiting. Quite the contrary:split the feature's implementatiion into logical chunks and remember to commit early and often. But don't commit just to have something in the repository before leaving the ofice at the end of the day. If you're tempted to commit just because you need a clean working copy (to check out a branch,pull in changes ,etc.) consider using Git's feature instead. 提交前测试代码 | TEST CODE BEFORE YOU COMMIT 抵制自以为已完成的提交. 直接测试来确保它真的已完成并且没有副作用(显而易见的). 当提交半成品到本地仓库时要求你不得不自我谅解,让你的代码进过测试对发布或者分享你的代码也很重要. Resist the temptation to commit something that you think is completed. Test it thoroughly to make sure it really is completed and has no side effect (as far as one can tell). While committing half-baked thing in your local repository only requires you to forgive yourself,having your code tested is even more important when it comes to publishing/sharing your code with others. 编写代码提交信息 | WRITE CODE COMMIT MESSAGE 对你的更改以简短总结进行描述(达到50字符作为准则). 以包括空白行作为分割下述内容. 提交信息体应该提供下述问题的详细答案: 此次更改的动机是什么? 和上一个实现有什么不同? 使用必要的现在时语态(更改,不是已更改,或者变更)和使用形如 git merge 命令生成的信息保持一致. Begin your message with short summary of your changes(up to 50 characters as a guideline). Separate it from the following body by including a blank line. The body of your message should provide detailed answers to the following questions: What was the motivation for the change? How does it differ from the previous implementation? Use the imperative ,present tense(change,not changed or changes) to be consistent with generated messages from commands like git merge. 版本控制不是一个备份系统 | VERSION CONTROL IS NOT A BACKUP SYSTEM 在远程服务器存有文件的备份是版本控制系统的一个很好副作用.但是你不应该将VCS 视为一个备份系统. 当做版本控制时,你应该注意语义化提交,而不是死记硬背文件. Having your files backed up on a remote server is a nice side effect of having a version control system. But you should not use your VCS like it was a backup system. When doing version control,you should pay attention to committing semantically(see related changes) - you shouldn't just cram in files. 利用分支 | USE BRANCHES 分支是 git 最强大的特性之一,这不是偶然. 从第一天开始快速而简单的分支就是一个核心需求. 分支是帮助你避免弄混不同开发线的完美工具. 在你的开发流程中应该广泛使用分支,像新功能,修复 bug,新想法... Branching is one of Git's most powerful features-and this is not by accident:quick and easy branching was a central requirement from day one. Branches are the perfect tool to help you avoid mixing up different lines of development. You should use branches extensively in your development workflows:for new features,bug fixes,ideas... 认同工作流 | AGREE ON A WORKFLOW Git 允许你从大量不同的工作流中选择一个:长期运行的分支,主题分支,合并或变,基工作流... 具体选择哪一个取决于一系列因素:你的项目,你的总体开发和部署工作流和(可能是最重要的)你和你的团队的个人偏好. 不论你选择哪一个去工作,你需要确保准守一个大家都认同的工作流. Git lets you pick from a lot of different workflows:long-running branches,topic branches,merge or rebase,git-flow... Which one you choose depends on a couple of factors:your project,your overall development and deployment workflows and (maybe most importantly ) on your and your teammate's personal preferences. However you choose to work,just make sure to agree on a common workflow that everyone follows. 帮助和文档 | HELP & DOCUMENTATION 命令行下获取 git 帮助 git help Git help on the command line git help 免费在线资源 | FREE ONELINE RESOURCES http://www.git-tower.com/learn http://rogerdudler.github.io/git-guide/ http://www.git-scm.org/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/git/summary/cheatsheet-translation.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"github/":{"url":"github/","title":"github 入门教程","keywords":"","body":"github 入门教程 github 是一个基于 git 的代码托管平台,是平时工作学习的好帮手,学会如何用好 github 网站能够帮助我们更好分享代码或者与其他开发人员合作. 注册 github 账号 首先准备好邮箱和密码,然后在 github 官网注册新账号,和大多数网站类似的注册流程,唯一注意的是你要想好注册类型,针对个人用户来说,一般无外乎个人账号和项目账号两种,比如 snowdreams1006 就认为是个人账号,而这种 security-plus 认为是项目账号. 其实这两种账号对于 github 来说是一样的,不像是个人账号同企业账号的差异那么大,那为什么称个人账号和项目账号呢? 是因为,大多数个人开发者名下会有多款开源作品,这些作品既可以全部挂载在某一个开发者账号下面,也可以单独挂载某一个开发者账号下面,如果此时的账号名恰好是项目名岂不是清晰多了? 因为个人刚开始可能并没多大名气,如果一个产品直接挂载在个人名下,那么这个产品很大程度上就依赖于个人名气了,所以不妨反过来,用产品说话,事实胜于雄辩,这种做法也是一种常用的宣传手段,很多个人开源产品正是这么做的! 除此之外项目账号还有一个好处,利用 github 的静态网站托管服务可以免费快速搭建项目官网,只要创建一个snowdreams1006.github.io 的项目,那么这个项目就可以作为静态网站的源码项目了,访问 https://snowdreams1006.github.io 就能看到项目官网了! 注意: snowdreams1006仅仅是笔者用户名,实际需要替换成读者的用户名 配置 github 既然项目已经托管到 github 网站,那本地如何访问到远程仓库呢?常用的方式有两种,一种是 https 方式,每次都需要输入密码,另外一种是 ssh 方式,只需要一次配置ssh 密钥对. 这里我们重点介绍最常用也是最方便的第二种 ssh 方式访问 github ,大致思路是本地生成密钥对,然后将公钥上传给 github 表明身份,之后本地再次推送给远程仓库时,github 自然就能识别到我们身份了. 第一步: 生成密钥对 默认情况下,会在当前用户目录下生成一对密钥对. ssh-keygen -t rsa -C \"youremail@example.com\" 这里的邮箱 youremail@example.com 需要填写自己的 github 邮箱,之后会提示输入路径和密码,一路回车采用默认值即可,运行结束后会在当前用户目录下 生成一对密钥对,包括公钥和私钥.其中公钥可以发送给任何人,而私钥千万不可泄露. 第二步: 复制公钥 在当前用户根目录下打开 .ssh 目录,其中包括两个文件,一个是公钥 id_rsa.pub ,另一个是私钥 id_rsa,用记事本或者其他方式打开公钥文件,复制其中内容,准备粘贴到github 相关设置项. # 查看当前用户下的 ssh 目录 ls ~/.ssh # 查看生成的公钥内容 cat ~/.ssh/id_rsa.pub 第三步: 设置 github 回到 github,点击头像(Acount),选择设置(Settings),再选择左侧的 SSH and GPG keys,点击右侧的NEW SSH Key,然后填写标题(Title),最好是有意义的名称,比如youremail@example.com for github,密钥(Key)填写上一边生成的公钥,一般是以ssh-rsa 开头的一大串字符,最后保存(Add SSH Key). 第四步: 验证 ssh 利用 ssh 协议测试一下是否能够正常访问 github 网站,如果出现成功提示,那就证明我们的配置没问题. ssh -T git@github.com 创建远程仓库 登录 github 网站新建远程仓库(New Repository),例如git-demo,默认权限是公开的(public),也可以选择私有的(private),初始化 README.md 文件和 .gitignore 文件以及选择开源协议这些都是可选的,视具体情况而定. 刷新当前页面,应该能到看到已创建好的git-demo 项目,接下来准备将其克隆到本地电脑. 克隆到本地仓库 将远程项目克隆到本地工作空间,和之前本地仓库的开发流程一样,例如add commit status 等等,唯一不同的是,多了一步 push 命令,即本地仓库的最新版本需要推送给远程仓库中,只有这样其他小伙伴才能从远程仓库拉取最新版本,进而才能看到你的代码,因而打破各自为政局面,实现团队协同开发. # 克隆到本地仓库 git clone git@github.com:snowdreams1006/git-demo.git # 切换到当前项目 cd git-demo # 创建新文件 touch test.txt echo \"add test.txt\" > test.txt # 添加文件到暂存区 git add test.txt # 提交文件到本地仓库 git commit -m \"add test.txt\" # 推送到远程仓库 git push origin master 提交完成后,登录 github 网站,刷新当前项目 git-demo ,应该能看到我们刚刚提交的新文件test.txt. 添加仓库关联 添加本地仓库和远程仓库之间关联,默认本地仓库分支名和远程仓库分支名相同 git remote add origin2 git@github.com:snowdreams1006/git-demo.git 查看远程仓库 查看当前配置有哪些远程仓库 git remote 执行时加上-v 参数能够查看别名关联的具体地址,即 git remote -v 下载远程仓库 从远程仓库下载最新分支数据 git fetch 注意: 该命令并不会自动合并当前分支,如需要合并,需手动执行git merge 命令 拉取远程仓库 从远程仓库拉取最新分支数据,自动尝试合并到当前分支,如有冲突,需先解决冲突再合并到当前分支. git pull git pull 相当于 git fetch + git merge 推送远程分支 将本地最新版本推送到远程仓库 git push origin master 以上命令将本地 master 分支推送到 origin 远程仓库的 master 分支 删除远程仓库 git remote rm origin var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/github/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"github/speedup.html":{"url":"github/speedup.html","title":"github 访问速度太慢","keywords":"","body":"github 访问速度太慢 github 是全世界最流行的开源项目托管平台,其代表的开源文化从根本上改变了软件开发的方式. 基本上所有的需求都能从 github 上或多或少找到现成的实现方案,再也不用重头开始造轮子而是自定义轮子! 然而,有时候国内访问 https://github.com/ 速度太慢,如何加速访问 github.com 网站就成了刚需. 由于 github.com 网站位于美国旧金山,所以初始访问 github.com 时网络寻址会比较耗费时间,这也是网站打开速度慢的其中一个原因. 国外在线检测网站: https://www.ipaddress.com/,无法访问的话,请另辟蹊径. 最初用户从浏览器中输入 github.com 网址时,浏览器并不知道这个域名对应的真实 ip 地址,先问问自己电脑认识不认识这个域名的门牌号,如果本机不认识会接着往上问,当地运行商也不认识这个域名的话,继续问上级,直到问出来 github.com 的门牌号是 192.30.253.113 为止! 如此繁琐的问路过程被称之为 DNS 寻址,如果问路的时间都占用很久,那么访问网站的速度自然会很慢. 所以,如果我们直接告诉浏览器目的地,那么浏览器也就不会一步一步去费劲问路了,这在一定程度上也就优化了访问网站的速度. $ ping github.com -c 3 PING github.com (192.30.253.113): 56 data bytes 64 bytes from 192.30.253.113: icmp_seq=0 ttl=41 time=405.924 ms 64 bytes from 192.30.253.113: icmp_seq=1 ttl=41 time=346.654 ms 64 bytes from 192.30.253.113: icmp_seq=2 ttl=41 time=345.485 ms --- github.com ping statistics --- 3 packets transmitted, 3 packets received, 0.0% packet loss round-trip min/avg/max/stddev = 345.485/366.021/405.924/28.220 ms ping github.com -c 3 查看 github.com 网站的门牌号 正常来说,网站的主域名下会存在多个子域名,由这些域名组合在一起提供完整的服务. 而 github.com 也不例外,其中 github.com是一级域名,也是主域名,其他的域名基本上都是二级域名或者说次域名. 所以我们不仅要告诉本机 github.com 的主域名,还要把相关的子域名也告诉本机,帮人帮到底,送福送到西! 那到哪里去查询域名和 ip 的对应关系呢? 想一想现实生活中,每个人都有自己的家,而这个家有具体的地址,也就是平时说的门牌号. 当然,有些人名下不只有一个家,有钱人的世界可以有很多家,毕竟狡兔还有三窟呢! 在这个家中既可以是单身窝,也可以是情侣房,或者是家庭房,具体容纳几个人是由房屋大小决定的. 对应到计算机世界中,如果域名是用户,那么 ip 地址就是用户的家. 同一个域名可以对应多个 ip 地址,同一个 ip 地址也可以有多个域名. 如果有人想要拜访您,肯定要有具体的地址才能到你家里做客,从你家到你家的地址这个过程可能是你告诉他的,也可能是他自己找别人打听到的消息. 域名到 ip 地址的过程同样也需要找人询问,这个信息一般会存在 dns 服务商那里,就像我们的地址登记到相关政府机构一样. 虽然相关机构的信息比较权威及时,但门槛有点高,所以不访问一下当地的\"消息通\". 互联网上的\"消息通\"更是数不胜数,这里推荐两个查询域名解析的网站. https://www.ipaddress.com/ http://tool.chinaz.com/dns/ 子域名有哪些 下面以 ipaddress.com 网站为例,查询下 github.com 网站的相关信息. 在输入框中输入 github.com 域名后开始解析该域名的相关信息,不仅找到了域名对应的 ip 地址还查询到相关网站的域名信息. 亲自去体验一下: 域名查询 根据查到的相关域名信息,再次查询出这些域名对应的 ip 地址,于是整理出以下内容. # github related website 192.30.253.113 github.com 151.101.185.194 github.global.ssl.fastly.net 192.30.253.118 gist.github.com 192.30.253.120 codeload.github.com 185.199.108.153 desktop.github.com 185.199.108.153 guides.github.com 185.199.108.153 blog.github.com 18.204.240.114 status.github.com 185.199.108.153 developer.github.com 185.199.108.153 services.github.com 192.30.253.175 enterprise.github.com 34.195.49.195 education.github.com 185.199.108.153 pages.github.com 34.196.237.103 classroom.github.com 就近 cdn 加速 大型网站服务器都不会是只有一台服务器,而是多台服务器组成的集群一起对外提供服务. 全世界都在使用 github ,如果每一次访问网站时走的都是美国服务器,即使浏览器知道目的地,但是距离太多遥远还是会很慢. 因此,如果能够就近访问 github 网站就能大幅提高访问速度了,幸运的是,网络上同样有现成的工具来帮助我们查看就近的网站地址. 亲自去体验一下: DNS查询 从上图中我们可以看出,同一个域名有很多不同的 ip 地址,从中选择 TTL 值最小的作为优化标准. 于是,将上述清单继续优化成以下内容: # github related website 192.30.253.113 github.com 151.101.185.194 github.global.ssl.fastly.net 203.98.7.65 gist.github.com 13.229.189.0 codeload.github.com 185.199.109.153 desktop.github.com 185.199.108.153 guides.github.com 185.199.108.153 blog.github.com 18.204.240.114 status.github.com 185.199.108.153 developer.github.com 185.199.108.153 services.github.com 192.30.253.175 enterprise.github.com 34.195.49.195 education.github.com 185.199.108.153 pages.github.com 34.196.237.103 classroom.github.com 最好亲自测试一下就近站点以求获得最佳体验,不过推测应该差异不是很大,所以直接复制也无妨. 告诉本机新地址 现在我们已经弄清楚域名和 ip 的映射关系,接下来要做的事情就是告诉本机,不同的操作系统具体文件存放的地址可能有些不同,下面我们以 Windows 和 Mac 举例说明. # github related website 192.30.253.113 github.com 151.101.185.194 github.global.ssl.fastly.net 203.98.7.65 gist.github.com 13.229.189.0 codeload.github.com 185.199.109.153 desktop.github.com 185.199.108.153 guides.github.com 185.199.108.153 blog.github.com 18.204.240.114 status.github.com 185.199.108.153 developer.github.com 185.199.108.153 services.github.com 192.30.253.175 enterprise.github.com 34.195.49.195 education.github.com 185.199.108.153 pages.github.com 34.196.237.103 classroom.github.com windows 映射文件存放于: C:\\Windows\\System32\\drivers\\etc\\hosts 打开 hosts 文件,将上述映射关系追加到文件末尾,保存并退出. 如果由于权限不足,无法保存,可以复制到桌面再编辑文件,最后移动并替换到 hosts 文件. 运行 ipconfig /flushdns 刷新 dns 缓存. mac 映射文件存放于: /etc/hosts 编辑 hosts 文件并追加上述映射关系. $ cat /etc/hosts # jetbrains 0.0.0.0 account.jetbrains.com 0.0.0.0 www.jetbrains.com # github related website 192.30.253.113 github.com 151.101.185.194 github.global.ssl.fastly.net 203.98.7.65 gist.github.com 13.229.189.0 codeload.github.com 185.199.109.153 desktop.github.com 185.199.108.153 guides.github.com 185.199.108.153 blog.github.com 18.204.240.114 status.github.com 185.199.108.153 developer.github.com 185.199.108.153 services.github.com 192.30.253.175 enterprise.github.com 34.195.49.195 education.github.com 185.199.108.153 pages.github.com 34.196.237.103 classroom.github.com 运行 sudo dscacheutil -flushcache 刷新 dns 缓存. $ ping github.com -c 3 PING github.com (192.30.253.113): 56 data bytes 64 bytes from 192.30.253.113: icmp_seq=0 ttl=41 time=395.808 ms 64 bytes from 192.30.253.113: icmp_seq=1 ttl=41 time=306.919 ms 64 bytes from 192.30.253.113: icmp_seq=2 ttl=41 time=298.188 ms --- github.com ping statistics --- 3 packets transmitted, 3 packets received, 0.0% packet loss round-trip min/avg/max/stddev = 298.188/333.638/395.808/44.105 ms $ 又到总结时间 本文讲述了如何解决 github.com 网站访问速度慢的问题,通过修改本机的 hosts 文件来绕过 dns 解析,这种方法仅仅适用于能够访问网站只不过是访问速度慢这一现象. 如果本身无法访问国外网站,那么这种方法就不适用,可能需要另辟蹊径! 最后再贴一下 hosts 文件内容: # github related website 192.30.253.113 github.com 151.101.185.194 github.global.ssl.fastly.net 203.98.7.65 gist.github.com 13.229.189.0 codeload.github.com 185.199.109.153 desktop.github.com 185.199.108.153 guides.github.com 185.199.108.153 blog.github.com 18.204.240.114 status.github.com 185.199.108.153 developer.github.com 185.199.108.153 services.github.com 192.30.253.175 enterprise.github.com 34.195.49.195 education.github.com 185.199.108.153 pages.github.com 34.196.237.103 classroom.github.com var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/github/speedup.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"github/badge.html":{"url":"github/badge.html","title":"github 徽章从何而来","keywords":"","body":"github 徽章从何而来 前言 平时大家在在逛 github 时或多或少都看到过项目首页各式各样的小徽章,不知道你是否和我一样好奇这些小徽章都是哪来的呢? 首先我们先来一睹为快目前前端开发的三大主流框架: var ,看一看他们的 github 项目首页有哪些小徽章吧! Vue : https://github.com/vuejs/vue Angular : https://github.com/angular/angular React : https://github.com/facebook/react 小结: 前端三大框架的徽章均不相同,由此可见,这应该不是 github 统一分发而是自定义行为! 虽然不是统一分配的,但也不是毫无规律可寻,想要制作专属的小徽章,其实真的很简单! 什么是徽章 徽章是一种小巧精美的小图标,一般配有相关文字进行辅助说明,富有表现力. 不仅出现于 github 项目主页,凡是能够表现图片的地方都可以出现徽章,本质上是一种 svg 格式的矢量图标. 下面以自定义 github-snowdreams1006-brightgreen.svg 徽章为例,简单认识一下徽章. 在线链接 在线链接: github-snowdreams1006-brightgreen.svg https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg 浏览器效果 打开在线链接,并检查当前网页,豁然开朗,徽章是一种 svg 实现的矢量图标. svg VS png 如果说 svg 是矢量图形而 png 却不是,所以不妨将 png 姑且称之为标量图形. svg 是矢量图形,png 是标量图形,两者均能实现类似效果,只不过矢量图形不论怎么方法都能保持原样,并不会像 png 那样会失真而已. 既然两种均能表现相同的效果,现在我们就来演示一下 png 的实现效果. svg 转 png 在线网站: https://cloudconvert.com/svg-to-svg 左侧的 svg 无论放大多少倍,依然保持原样,清晰度保持不变.右侧的 png 一旦放大,立马变得模糊不清. 如何使用徽章 大多数徽章都是 svg 格式,当然也不排除某些徽章是 png 格式,不论怎么说,一律当成图标使用就可以了. 如果你和我一样,希望在 markdown 文件中使用徽章,那么建议使用在线链接,或者引入本地 svg 相关文件. 徽章格式 : [![图片文字说明](图片源地址)](超链接地址) 即超链接内部嵌套图片 [![github](https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg)](https://github.com/snowdreams1006) 如果你是在 html 文件使用徽章,同样先取得在线徽章地址,然后按照 html 语法插入图片即可. 徽章格式 : 即超链接内部嵌套图片 不论是什么语法,最核心最根本的获得到徽章链接,至于不同语言有着各自的语法,按照语言规则手动拼接就好. Badge URL https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg Markdown [![github](https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg)](https://github.com/snowdreams1006) HTML Textile !https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg!:https://github.com/snowdreams1006 RDOC {}[https://github.com/snowdreams1006] AsciiDoc image:https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg[\"github\", link=\"https://github.com/snowdreams1006\"] RST .. image:: https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg :target: https://github.com/snowdreams1006 徽章分类 如果以徽章的格式为标准,那么可以分为svg 和 png 两类. svg https://badge.fury.io/js/gitbook-plugin-mygitalk.svg png https://badge.fury.io/js/gitbook-plugin-mygitalk.png 如果以徽章的样式为标准,那么可以分为默认样式和自定义样式两类. 默认样式 https://img.shields.io/github/stars/snowdreams1006/snowdreams1006.github.io.svg?style=social 自定义样式 https://img.shields.io/badge/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg 如果以徽章的内容数据是否动态为标准,那么可以分为静态数据和动态数据两类. 静态数据意味着数据本身是不变的,只要在线链接不变,那么生成的徽章永远不会改变,而动态数据意味着生成徽章的数据是动态变化的,即使在线链接不变,当数据本身发现变化时,徽章自然随之更新. 静态数据 https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg 动态数据 https://badge.fury.io/js/gitbook-plugin-mygitalk.svg 静态数据示例中 github-snowdreams1006-brightgreen.svg 数据不会更改,自然生成的徽章也不会变.动态数据示例中 gitbook-plugin-mygitalk.svg 是 npm 的版本号,当项目升级后,版本号会发生更改,那么生成的徽章也会随之更新. 如果以徽章的内容数据来源为标准,那么可以有无数多的分类. GitHub https://badgen.net/github/stars/snowdreams1006/gitbook-plugin-mygitalk Npm https://badgen.net/npm/dt/gitbook-plugin-mygitalk Docker https://badgen.net/docker/stars/library/centos 如果以徽章的内容数据用途为标准,那么也可以有无数多的分类. 构建状态 https://img.shields.io/travis/GitbookIO/gitbook.svg 代码覆盖率 https://img.shields.io/codecov/c/github/vuejs/vue.svg 代码分析 https://img.shields.io/github/languages/top/snowdreams1006/snowdreams1006.github.io.svg 徽章来源 徽章有不同的分类,不管是哪种分类,在线徽章最为简单便捷,下面就简单介绍下提供在线生成徽章的网站. https://shields.io/ https://badgen.net/ https://forthebadge.com/ https://badge.fury.io/ https://github.com/boennemann/badges https://shields.io/ 适用于绝大多数情况,默认按照徽章内容分类,Build,Code Coverage,Analysis 等多主题,同时支持自定义徽章和动态徽章. 如果徽章的主题明确,那么根据网站提供的主题对号入座即可在线生成徽章,下面以 gitbook-plugin-mygitalk 为例,简要说明如何获得相应徽章链接. gitbook-plugin-mygitalk 是 gitbook 的一款评论插件. 打开网站后按照分类,选择其中一个主题,点击进去后填写目标信息,即可在线生成徽章. 浏览已支持的主体,选择 License 许可证主题. 浏览已支持的 License 许可证列表,选择 NPM 许可证. 填写好正确的 npm 包信息并实时预览,然后点击按钮复制徽章链接或者或者特定格式的徽章. ![NPM](https://img.shields.io/npm/l/gitbook-plugin-mygitalk.svg) 按照主题生成徽章真的很简单,首先对号入座,然后按需生成相应徽章即可,唯一的要求就是对号入座! 如果默认提供的徽章主题没有适合自己的徽章,或者想要自定义徽章效果,那么也可以在线制作私人订制徽章. 打开网站后往下拉,找到 Your Badge 区域,准备制作专属徽章. 填写(Label)标签-(Message)信息-(Color)颜色等信息后,点击(Make Badge)生成徽章. 点击生成徽章后默认会在当前标签页面打开该链接,手动复制链接并调整成目标格式即可. ![微信公众号-雪之梦技术驿站-brightgreen.svg](https://img.shields.io/badge/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg) https://badgen.net/ 徽章内容来源种类较多,默认按照平台分类,按照特定规则生成徽章,需要手动拼接在线链接,略显繁琐. https://badgen.net/badge/:subject/:status/:color?icon=github ──┬── ───┬─── ──┬─── ──┬── ────┬────── │ │ │ │ └─ Extra Options (label, list, icon, color) │ │ │ │ │ TEXT TEXT RGB / COLOR_NAME ( optional ) │ \"badge\" - default (static) badge generator 虽然支持颜色,图标以及查询参数等高级用法,但是还是习惯性采用默认设置,下面动手开始制作徽章吧! 切换到默认动态徽章选项卡,选择 GitHUb 徽章. 选择 stars 徽章,将 micromatch 替换成目标信息. /github/stars/micromatch/micromatch 替换成 /stars/snowdreams1006/snowdreams1006.github.io 预览徽章效果并手动修改成目标格式. ![snowdreams1006.github.io](https://badgen.net/github/stars/snowdreams1006/snowdreams1006.github.io) 除了支持动态徽章,同样也支持静态徽章,切换到 STATIC BADGES 选项卡,一起来生成静态徽章吧! ![★★★★☆](https://badgen.net/badge/stars/%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86) 按照徽章的在线链接规则,应该也支持自定义徽章,再次回顾一下链接规则: 规则 : https://badgen.net/badge/:subject/:status/:color ,如果是自定义动态链接,估计不支持吧! ![微信公众号-雪之梦技术驿站](https://badgen.net/badge/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99) https://forthebadge.com/ 扁平化的徽章,支持的徽章数量有限,不支持自定义徽章. 网站首页默认提供了一些预览徽章,左侧是复制 image 链接,右侧是复制 markdown 链接. [![forthebadge](https://forthebadge.com/images/badges/fuck-it-ship-it.svg)](https://forthebadge.com) 网站首页默认展示的徽章毕竟有限,如果找不到理想徽章,岂不是白介绍了这个网站,当然不能够! VIEW ALL 查看目前支持的全部徽章,如果还是找不到徽章,那就真的没有. https://badge.fury.io/ 版本徽章,支持各类平台版本,包括 npm ,Ruby,Python,Go 等平台. 选择目标平台并输入包管理信息,即可在线生成各个类型的徽章版本. [![npm version](https://badge.fury.io/js/gitbook-plugin-mygitalk.svg)](https://badge.fury.io/js/gitbook-plugin-mygitalk) 排版布局 默认 markdown 实现的图片是依次排开的,无法自定义样式,而 markdown 语法同时也兼容 html 语法,因此我们可以用 html 语法实现居中对齐. 抛砖引玉 社交化徽章 ![GitHub followers](https://img.shields.io/github/followers/snowdreams1006.svg?style=social) ![GitHub forks](https://img.shields.io/github/forks/snowdreams1006/snowdreams1006.github.io.svg?style=social) ![GitHub stars](https://img.shields.io/github/stars/snowdreams1006/snowdreams1006.github.io.svg?style=social) ![GitHub watchers](https://img.shields.io/github/watchers/snowdreams1006/snowdreams1006.github.io.svg?style=social) 自定义徽章 [![github](https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg)](https://github.com/snowdreams1006) [![wechat](https://img.shields.io/badge/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](http://weixin.qq.com/r/cy5CWvvE5Kabrb8593th) [![慕课网](https://img.shields.io/badge/%E6%85%95%E8%AF%BE%E7%BD%91-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://www.imooc.com/u/5224488/articles) [![简书](https://img.shields.io/badge/%E7%AE%80%E4%B9%A6-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://www.jianshu.com/u/577b0d76ab87) [![csdn](https://img.shields.io/badge/csdn-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://blog.csdn.net/weixin_38171180) [![博客园](https://img.shields.io/badge/%E5%8D%9A%E5%AE%A2%E5%9B%AD-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://www.cnblogs.com/snowdreams1006/) [![掘金](https://img.shields.io/badge/%E6%8E%98%E9%87%91-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://juejin.im/user/582d5cb667f356006331e586) [![思否](https://img.shields.io/badge/%E6%80%9D%E5%90%A6-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://segmentfault.com/u/snowdreams1006) [![开源中国](https://img.shields.io/badge/%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://my.oschina.net/snowdreams1006) [![腾讯云社区](https://img.shields.io/badge/%E8%85%BE%E8%AE%AF%E4%BA%91%E7%A4%BE%E5%8C%BA-%E9%9B%AA%E4%B9%8B%E6%A2%A6%E6%8A%80%E6%9C%AF%E9%A9%BF%E7%AB%99-brightgreen.svg)](https://cloud.tencent.com/developer/user/2952369/activities) 进度条徽章 [![progress](http://progressed.io/bar/25?title=progress)](https://github.com/fehmicansaglam/progressed.io) [![progress](http://progressed.io/bar/50?title=progress)](https://github.com/fehmicansaglam/progressed.io) [![completed](http://progressed.io/bar/75?title=completed)](https://github.com/fehmicansaglam/progressed.io) [![done](http://progressed.io/bar/100?title=done)](https://github.com/fehmicansaglam/progressed.io) 参考文档 GitHub 项目徽章的添加和设置 玩转 Github 徽章 为你的Github README生成漂亮的徽章和进度条 给python项目在github贴上build和pypi小徽章 https://github.com/igrigorik/ga-beacon https://github.com/boennemann/badges https://ellerbrock.github.io/open-source-badges/ http://githubbadges.com/ 在线网站 https://shields.io/ https://badgen.net/ https://forthebadge.com/ https://badge.fury.io/ https://ellerbrock.github.io/open-source-badges/ http://githubbadges.com/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/github/badge.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/":{"url":"myGitbook/","title":"gitbook 入门教程","keywords":"","body":"gitbook 入门教程 gitBook 是一个基于node.js的命令行工具,使用 github/git 和 markdown/asciiDoc 构建精美的电子书. gitbook 支持输出静态网页和电子书等多种格式,其中默认输出静态网页格式. gitbook 不仅支持本地构建电子书,而且可以托管在 gitbook 官网上,并享受在线发布和托管图书的便利,完整的文档请参考 gitbook 新版文档(需FQ) 或 gitbook 旧版文档(不需FQ) 目前 gitbook 旧版文档已经不可访问,特提供压箱底存货邀君共享 适用场景 不仅适用于软件说明文档的发布更新,同样适用于文本文档的连载更新. 既适合具有一定编程经验的软件开发从业者,也适用于不满足传统书写方式的文学创作者. 简而言之,gitbook 可以条理清晰地整理出零碎知识,打造专属你自己的电子书,漂亮的主题,丰富的插件让你的知识变得从此与众不同! git + markdown = gitbook,其中 git 可以管理书籍内容的变更,并将其托管到云端实现团队协作,而 markdown 简洁的语法特点,使得我们不必关心布局排版问题,专注创作,重拾写作乐趣! 如果你还不了解 git 和 markdown 相关知识,赶紧去学习 markdown 快速入门 和 git 入门教程 吧! 先睹为快 gitbook 教程 gitbook 官网 gitbook 文档 参考文档 gitbook 官网(新) gitbook 官网(旧) gitbook 文档(新) gitbook 文档(旧) gitbook 文档(存货) git 官网 github 官网 gitbook 新版需要FQ,旧版不需要FQ,旧版暂不可用,可访问压箱底存货. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/preparation/prepare.html":{"url":"myGitbook/preparation/prepare.html","title":"准备阶段","keywords":"","body":"准备阶段 主要包括两部分: 前置知识和操作工具. 前置知识主要是涉及到 git 以及 markdown 的相关知识,其中 git 是分布式版本控制系统,方便管理我们的电子书,备份到云端,方便团队共享合作,而 markdown 则是一种简单标记语言,简单情况下可以替代 word 进行排版布局,能完全替换 txt 文本,最终实现媲美 html 的输出效果,简洁高效的书写体验,深受广大软件开发者的喜爱. 正是由于 git + markdown 的搭配组合,使得上手 gitbook 相当简单,带给一种全新的体验. 操作工具主要是环境准备,主要是指 gitbook 环境,因为涉及到 git ,所以也包括 git 环境,至于markdown 语法支持,不一定非要安装相应软件,按照规定的格式书写文档即可,不过新手可能更愿意使用可视化软件,毕竟所见即所得,写着放心,看着舒心! 知识准备 markdown 快速入门 git 入门教程 上述教程中有详细的安装以及使用方法,最好能够完全掌握,如果时间有限,不愿意细读的话,请看下一节,我会挑选出常用命令进行讲解! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/preparation/prepare.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/preparation/front-knowledge.html":{"url":"myGitbook/preparation/front-knowledge.html","title":"前置知识","keywords":"","body":"前置知识 markdown 基本知识 markdown 是一种简化的 html 语法,相比于 txt 无格式文本更强大. 你可以用专门的软件去编辑 markdown 文件,就像需要使用软件编辑 txt 文件一样,当然也可以什么软件也不用,甚至直接在记事本或命令行书写,只不过这样的缺点就是无法实时预览输出效果,安全依赖个人经验和想象力了. markdown 文件后缀名是.md,安装了相应插件的浏览器或专门软件能够看到输出效果. 标题 语法格式: # + 空格 + 文本 大多数markdown编辑器支持 h1~h6 级标题,而富文本编辑器一般仅支持到二级标题. 示例: # 标题1 ## 标题2 效果: 标题1 标题2 列表 列表包括有序列表,无序列表和任务列表,并支持列表嵌套. 大多数 markdown 编辑器和富文本编辑器均支持有序列表和无序列表,而任务列表和列表嵌套支持度就不是很好,存在平台兼容性问题. 有序列表 语法格式：数字 + . + 空格 + 文本 示例: 1. 有序列表1 2. 有序列表2 3. 有序列表3 效果: 有序列表1 有序列表2 有序列表3 无序列表 语法格式：'- 或 * 或 +' + 空格 + 文本 示例: - 无序列表1 * 无序列表2 + 无序列表3 效果: 无序列表1 无序列表2 无序列表3 链接和图片 markdown 编辑器和富文本编辑器均支持链接和图片,值得注意的是有些平台限制或禁止外链. 链接 语法格式：[显示文本] + (链接地址) 示例: [https://snowdreams1006.github.io](https://snowdreams1006.github.io/) 效果: https://snowdreams1006.github.io 图片 语法格式：! + [图片标题] + (图片地址) 示例: ![雪之梦技术驿站的头像](https://upload.jianshu.io/users/upload_avatars/16648241/57aebe62-b5b5-491a-a9fd-f994d5be7dda.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240) 效果: 代码 代码分为单行代码和多行代码,其中多行代码也叫做代码块. 大多数 markdown 编辑器均支持代码,富文本编辑器支持度不一样,有的支持单行代码有的支持代码块. 单行代码 语法格式：` + 单行代码 + ` 示例: `code` 效果: code 多行代码 语法格式：``` + 多行代码 + ``` 示例: ``` function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); ``` 效果: function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); 这里的富文本支持语法指的是 markdown 渲染后的内容能否正常显示,并不是指 markdown语法本身能够正常渲染,更多详情请参考 markdown 快速入门 git 基本知识 git 是全世界最先进的分布式版本控制系统,帮助项目更好地进行管理,支持版本历史管理和多人写作管理等功能. 简单地说,可以理解为一种优雅的文档备份方式,支持云端备份,多人协作等特点. 初始化项目 语法格式: git init 适合从零开始的本地项目,初始化后的项目才是能够被 git 管理的项目. 示例: git init 克隆项目 语法格式: git clone 适合已有远程项目需要下载到本地,作用是将远程项目克隆到本地,和 git init 实现类似的功能. 示例: git clone git@github.com:username/username.github.io.git 添加文件 语法格式: git add 将文件添加到暂存区,支持多次添加文件,相当于写入缓存区. 示例: git add . 提交文件 语法格式: git commit 将暂存区内容提交到版本库,完成一次历史版本. 示例: git commit -m \"写入提交备注,简短说明下提交意图和目标\" 推送文件 语法格式: git push 将本地版本库推送到远程版本库,相当于本地文件备份到云端服务器. 示例: git push origin master 拉取文件 语法格式: git pull 将远程版本库拉取到本地版本库,相当于云端服务器文件恢复到本地. 示例: git pull 查看状态 语法格式: git status 查看当前文件状态,包括文件被新增,被修改,被删除,未提交等等. 示例: git status 比较差异 语法格式: git diff 查看两个文件之间的具体差异 示例: git diff 历史日志 语法格式: git log 查看版本库的提交历史日志 示例: git log 上述仅介绍了 git 的简单命令,实际使用情况远不止这些,更多详情请参考 git 入门教程 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/preparation/front-knowledge.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/preparation/environmental-requirements.html":{"url":"myGitbook/preparation/environmental-requirements.html","title":"环境要求","keywords":"","body":"环境要求 gitbook 是基于 node.js 的命令行工具,首先需要安装并配置好 node.js 环境,然后才能安装gitbook 相关工具. 由于安装工具全部都是国外网站,因此速度可能会很慢,也可能需要FQ,请耐心等待或者学会科学上网. 当然如果安装过程中遇到任何问题,也可以找我要一下安装包或者我帮你免费解决下. 环境预检查 检查 git 环境[可选] git 是免费开源的分布式版本控制系统,主要用于电子书的更新管理和团队协作,如果不需要将电子书托管到github 网站上,则可以不安装 git . 如果打印出 git 版本信息,则表示本机已安装 git 环境,跳过此步骤. $ git --version git 安装配置教程请参考初识 git 检查 node.js 环境[必须] node.js 是 js 在服务端运行的环境基础,从而使得 js 从浏览器端延伸到服务端领域,而 gitbook 则是运行在 node.js 基础之上的命令行工具,因此必须先安装好 node.js 开发环境. 如果打印出 node.js 版本信息,则表示本机已安装 node.js 环境,跳过此步骤. $ node --version nodejs 默认的包安装工具 npm 国内访问速度有点慢,安装完毕后建议 npm install cnpm -g --registry=https://registry.npm.taobao.org 使用淘宝镜像源代替默认的 npm ,详细教程请参考官方 https://nodejs.org/ 检查 gitbook 环境[必须] gitbook-cli 是 gitbook 的脚手架工具,帮助我们更方便构建 gitbook 应用,当然也可以直接安装 gitbook ,只不过那样的话,略显麻烦,不推荐. 如果打印出 gitbook 和 cli 版本信息,则表示本机已安装 gitbook 环境,跳过此步骤. $ gitbook --version 否则的话,本机可能并没有安装 gitbook 环境,则需要安装 gitbook 相关工具. 因为 gitbook 是基于 node.js 环境,而安装好 node.js 后默认提供了 npm 包管理工具,而我们则是通过 npm 来安装其他工具. 安装 gitbook-cli 工具[必须] 假设你已经搭建好 node.js 环境,现在我们开始安装 gitbook 相关工具了! $ sudo npm install -g gitbook-cli 如果使用 cnpm 安装的话,使用 cnpm install -g gitbook-cli 命令. 安装成功后会带有 gitbook 命令,现在再次运行下 gitbook --version 查看版本信息. # 打印出 `CLI` 和 `GitBook` 版本信息即可,安装版本可能已经大于 `2.3.2` $ gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 $ 安装 GitBook Editor 编辑器[可选] gitbook 官方客户端编辑器,支持 windows, mac 和 linux ,主要用于可视化编辑文档,组织文档结构. 下载相应平台的 GitBook Editor,正常安装即可. gitbook 的使用方法大致可以有三种,而 GitBook Editor 编辑器只是其中一种,所以这一步是可选的. 使用 gitbook-cli 脚手架提供的各种命令直接在命令行管理 gitbook,适合一定编程经验的软件从业人员. 使用 GitBook Editor 编辑器管理 gitbook ,适合无任何编程的文学创作者. 使用 gitbook.com 官网在线管理 gitbook ,适合不具备本地开发环境的萌新体验者. 小结 gitbook 基于 node.js 开发环境,因此首先要安装好 nodejs 环境,其次再使用 node.js 提供的 npm 包管理工具来安装 gitbook. 只需运行 sudo npm install -g gitbook-cli 即可安装,接着运行 gitbook -V 查看安装版本信息确认已经安装成功. 至此 gitbook 的必要开发环境已经准备妥当,接下来让我们赶紧体验一下 gitbook 的魅力吧! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/preparation/environmental-requirements.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/experience/preview.html":{"url":"myGitbook/experience/preview.html","title":"快速体验","keywords":"","body":"快速体验 本文主要介绍三种使用 gitbook 的方式,分别是 gitbook 命令行工具,Gitbook Editor 官方编辑器和 gitbook.com 官网. 总体来说,三种途径适合各自不同的人群,找到适合自己的方式就好,基本操作流程都是一样的. 命令行工具更适合具备编程经验开发者,具有简单高效易整合等特点. 编辑器更适合无任何编程经验的文学创作者,不熟悉 markdown 语法,不熟悉 git 工作流,这种情况下也推荐使用图形化操作的编辑器. 官网适合想要快速体验 gitbook 效果的萌新,只有觉得物超所值才能有动力搭建 gitbook 开发环境,不是吗? 当然,如果你想访问官网的话,你可能需要学会科学上网,网址见文章结尾. gitbook 命令行 首先需要创建存放书籍的目录,然后对该目录进行初始化,最后启动本地服务即可体验效果. 初始化项目 语法格式: gitbook init 如果是空目录会自动创建 README.md 和 SUMMARY.md 两个文件,当然也可以手动创建再初始化. 示例: # 创建 `gitbook` 演示项目 $ mkdir gitbook-demo # 初始化项目 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished # 当前目录结构 $ tree . ├── README.md └── SUMMARY.md 0 directories, 2 files $ gitbook init 命令可能会自动生成 README.md 和 SUMMARY.md 两个文件,如已存在则更新. 运行项目 语法格式: gitbook serve 将初始化后的项目启动成为一个本地服务,我们可以直接在浏览器访问项目,预览书籍效果. 示例: # 启动本地服务器 $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 1.2s ! Starting server ... Serving book on http://localhost:4000 如果要停止服务器,只需同时按住 CTRL+C 即可,现在再看一下 gitbook-demo 目录结构. $ tree . ├── README.md ├── SUMMARY.md └── _book ├── gitbook │ ├── fonts │ │ └── fontawesome │ │ ├── FontAwesome.otf │ │ ├── fontawesome-webfont.eot │ │ ├── fontawesome-webfont.svg │ │ ├── fontawesome-webfont.ttf │ │ ├── fontawesome-webfont.woff │ │ └── fontawesome-webfont.woff2 │ ├── gitbook-plugin-fontsettings │ │ ├── fontsettings.js │ │ └── website.css │ ├── gitbook-plugin-highlight │ │ ├── ebook.css │ │ └── website.css │ ├── gitbook-plugin-livereload │ │ └── plugin.js │ ├── gitbook-plugin-lunr │ │ ├── lunr.min.js │ │ └── search-lunr.js │ ├── gitbook-plugin-search │ │ ├── lunr.min.js │ │ ├── search-engine.js │ │ ├── search.css │ │ └── search.js │ ├── gitbook-plugin-sharing │ │ └── buttons.js │ ├── gitbook.js │ ├── images │ │ ├── apple-touch-icon-precomposed-152.png │ │ └── favicon.ico │ ├── style.css │ └── theme.js ├── index.html └── search_index.json 11 directories, 27 files $ gitbook serve 命令可能会自动生成 _book 目录,如已存在则更新. gitbook editor 编辑器 下载 gitbook editor 并安装,如果下载遇到困难,可以找我来帮忙哟! 如果你没有梯子,可以暂不登录(Do that Later),只不过无法与 gitbook.com 保持同步. 更改图书路径 更改默认图书存放位置(Gitbook Editor => Change Library Path...),以后图书目录都在该目录下,比如设置的是 .../gitbook-editor/ 图书目录. 新建图书 新建图书项目,名字仍然是 gitbook-demo,这样方便比较和命令行创建的 gitbook-demo 区别. 图形化操作界面总体来说还是很容易上手的,自己好好研究一下即可,这里仅仅演示默认效果. 启动项目 现在先找到新建图书的具体目录,然后再启动本地服务器,同样地,我们在浏览器中体验电子书效果. 图书项目路径: /workspace/gitbook-editor/Import/gitbook-demo,其中 /workspace/gitbook-editor/ 是上一步更改的图书路径. # 启动本地服务器 $ gitbook serve 这里不再需要运行 gitbook init 命令了,因为已经创建过 README.md 和 SUMMARY.md 这两个文件. Gitbook Editor 编辑器新建的图书项目和 gitbook-cli 创建的图书项目本质上并没有什么不同,只不过编辑器集成了常用功能而已! gitbook.com 网站 由于受网络因素所限,暂时不分享这部分知识了,简单来说就是在线编辑并发布电子书,这一点和 github 的代码托管服务类似. gitbook 新版官网(需要FQ) : https://www.gitbook.com/ gitbook 旧版官网(无需FQ) : https://legacy.gitbook.com 小结 初始化项目 : gitbook init 启动项目 : gitbook serve 默认访问地址: http://localhost:4000 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/experience/preview.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/experience/gitbook-cli.html":{"url":"myGitbook/experience/gitbook-cli.html","title":"gitbook-cli 命令行操作","keywords":"","body":"gitbook-cli 命令行操作 gitbook 生成电子书主要有三种方式: gitbook-cli 命令行操作,简洁高效,适合从事软件开发的相关人员. gitbook-editor 编辑器操作,可视化编辑,适合无编程经验的文学创作者. gitbook.com 官网操作,在线编辑实时发布,适合无本地环境且科学上网的体验者. 本文主要讲解第一种 gitbook-cli 命令行操作流程,其他两种见另外两篇教程. gitbook 的一些常用命令 安装 gitbook-cli 脚手架工具 本机已安装 node.js 开发环境,安装完成后运行 gitbook -V 能够打印出版本信息,则表示安装成功. $ sudo npm install -g gitbook-cli 关于安装配置相关问题请参考 环境要求 初始化 gitbook 项目 初始化项目,按照 gitbook 规范会自动创建 README.md 和 SUMMARY.md 两个文件,具体用途见下文. 其实 SUMMARY.md 是电子书的章节目录,gitbook 会初始化相应的文件目录结构,所以主要是用于开发初始阶段. $ gitbook init 启动 gitbook 项目 启动本地服务,程序无报错则可以在浏览器预览电子书效果: http://localhost:4000 由于能够实时预览电子书效果,并且大多数开发环境搭建在本地而不是远程服务器中,所以主要用于开发调试阶段. $ gitbook serve 构建 gitbook 静态网页 构建静态网页而不启动本地服务器,默认生成文件存放在 _book/ 目录,当然输出目录是可配置的,暂不涉及,见高级部分. 输出静态网页后可打包上传到服务器,也可以上传到 github 等网站进行托管,因而主要用于发布准备阶段. $ gitbook build 章节小结 gitbook init 初始化 README.md 和 SUMMARY.md 两个文件. gitbook build 本地构建但不运行服务,默认输出到 _book/ 目录. gitbook serve 本地构建并运行服务,默认访问 http://localhost:4000 实时预览. # 创建 `gitbook` 演示项目 $ mkdir gitbook-demo # 初始化项目 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished # 启动本地服务器 $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 1.2s ! Starting server ... Serving book on http://localhost:4000 # 查看当前目录结构 $ tree . ├── README.md ├── SUMMARY.md └── _book ├── gitbook │ ├── fonts │ │ └── fontawesome │ │ ├── FontAwesome.otf │ │ ├── fontawesome-webfont.eot │ │ ├── fontawesome-webfont.svg │ │ ├── fontawesome-webfont.ttf │ │ ├── fontawesome-webfont.woff │ │ └── fontawesome-webfont.woff2 │ ├── gitbook-plugin-fontsettings │ │ ├── fontsettings.js │ │ └── website.css │ ├── gitbook-plugin-highlight │ │ ├── ebook.css │ │ └── website.css │ ├── gitbook-plugin-livereload │ │ └── plugin.js │ ├── gitbook-plugin-lunr │ │ ├── lunr.min.js │ │ └── search-lunr.js │ ├── gitbook-plugin-search │ │ ├── lunr.min.js │ │ ├── search-engine.js │ │ ├── search.css │ │ └── search.js │ ├── gitbook-plugin-sharing │ │ └── buttons.js │ ├── gitbook.js │ ├── images │ │ ├── apple-touch-icon-precomposed-152.png │ │ └── favicon.ico │ ├── style.css │ └── theme.js ├── index.html └── search_index.json 11 directories, 27 files $ gitbook 的目录结构说明 既然要书写一本电子书,那么起码的章节介绍和章节详情自然是必不可少的. 当然还有标题,作者和联系方式等个性化信息需要指定,如果不指定的话,一旦采用默认配合,八成不符合我们的预期,说不定都会变成匿名电子书?所以配置文件一般也是需要手动设置的! 真正可选的文件要数词汇表了,毕竟不是每一本电子书都有专业词汇需要去解释说明.如果在章节详情顺便解释下涉及到的专业词汇,那么自然也就不需要词汇表文件了. 简单解释下各个文件的作用: README.md 是默认首页文件,相当于网站的首页 index.html ,一般是介绍文字或相关导航链接. SUMMARY.md 是默认概括文件,主要是根据该文件内容生成相应的目录结构,同 README.md 一样都是被gitbook init 初始化默认创建的重要文件. _book 是默认的输出目录,存放着原始 markdown 渲染完毕后的 html 文件,可以直接打包到服务器充当静态网站使用.一般是执行 gitbook build 或 gitbook serve 自动生成的. book.json 是配置文件,用于个性化调整 gitbook 的相关配置,如定义电子书的标题,封面,作者等信息.虽然是手动创建但一般是必选的. GLOSSARY.md 是默认的词汇表,主要说明专业词汇的详细解释,这样阅读到专业词汇时就会有相应提示信息,也是手动创建但是可选的. LANGS.md 是默认的语言文件,用于国际化版本翻译,和 GLOSSARY.md 一样是手动创建但是可选的. README.md 首页文件[必须] 编辑 README.md 文件,随便写点内容并启动本地服务(gitbook serve)实时预览效果. SUMMARY.md 概括文件[必须] 先停止本地服务,编辑章节目录结构,然后重新再初始化(gitbook init)自动创建相应目录. _book 输出目录[可选] 执行 gitbook build 或 gitbook serve 命令后会自动生成静态网页. # 构建电子书 $ gitbook build info: 7 plugins are installed info: 6 explicitly listed info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 5 pages info: found 0 asset files info: >> generation finished with success in 0.7s ! # 查看输出目录 $ tree _book/ _book/ ├── first │ ├── 01.html │ └── 02.html ├── first.html ├── gitbook │ ├── fonts │ │ └── fontawesome │ │ ├── FontAwesome.otf │ │ ├── fontawesome-webfont.eot │ │ ├── fontawesome-webfont.svg │ │ ├── fontawesome-webfont.ttf │ │ ├── fontawesome-webfont.woff │ │ └── fontawesome-webfont.woff2 │ ├── gitbook-plugin-fontsettings │ │ ├── fontsettings.js │ │ └── website.css │ ├── gitbook-plugin-highlight │ │ ├── ebook.css │ │ └── website.css │ ├── gitbook-plugin-lunr │ │ ├── lunr.min.js │ │ └── search-lunr.js │ ├── gitbook-plugin-search │ │ ├── lunr.min.js │ │ ├── search-engine.js │ │ ├── search.css │ │ └── search.js │ ├── gitbook-plugin-sharing │ │ └── buttons.js │ ├── gitbook.js │ ├── images │ │ ├── apple-touch-icon-precomposed-152.png │ │ └── favicon.ico │ ├── style.css │ └── theme.js ├── index.html ├── search_index.json └── second.html 10 directories, 28 files $ book.json 配置文件[可选] 在根目录下新建 book.json 配置文件,完整的支持项请参考官方文档,下面仅列举常用的一些配置项. title 标题 书籍的标题 示例: \"title\": \"雪之梦技术驿站\" author 作者 书籍的作者 示例: \"author\": \"snowdreams1006\" description 描述 书籍的简要描述 示例: \"description\": \"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.\" isbn 国际标准书号 书籍的国际标准书号 示例: \"isbn\": \"978-0-13-601970-1\" 选填,请参考 ISBN Search language 语言 支持语言项: 默认英语(en),设置成简体中文(zh-hans) en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 示例: \"language\": \"zh-hans\" direction 阅读顺序 阅读顺序,支持从右到左(rtl)或从左到右(ltr),默认值取决于语言值. 示例: \"direction\" : \"ltr\" gitbook 版本 指定 gitbook 版本,支持SemVer规范,接受类似于 >=3.2.3 的条件. 示例: \"gitbook\": \"3.2.3\" root 根目录 指定存放 gitbook 文件(除了book.json文件本身)的根目录 示例: \"root\": \".\" links 侧边栏链接 左侧导航栏添加链接,支持外链 示例; \"links\": { \"sidebar\": { \"我的网站\": \"https://snowdreams1006.cn/\" } } styles 自定义样式 自定义全局样式 示例: \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } plugins 插件 配置额外的插件列表,添加新插件项后需要运行 gitbook install 安装到当前项目. gitbook 默认自带5个插件,分别是: highlight 语法高亮插件 search 搜索插件 sharing 分享插件 font-settings 字体设置插件 livereload 热加载插件 后续会介绍一些常用插件,如需获取更多插件请访问官网插件市场 示例: \"plugins\": [ \"github\", \"pageview-count\", \"mermaid-gb3\", \"-lunr\", \"-search\", \"search-plus\", \"splitter\", \"-sharing\", \"sharing-plus\", \"expandable-chapters-small\", \"anchor-navigation-ex\", \"edit-link\", \"copy-code-button\", \"chart\", \"favicon-plus\", \"donate\" ] pluginsConfig 插件配置 安装插件的相应配置项,具体有哪些配置项是由插件本身提供的,应访问插件官网进行查询. \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" }, \"sharing\": { \"douban\": true, \"facebook\": false, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": true, \"qzone\": true, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": true, \"whatsapp\": false, \"all\": [ \"facebook\", \"google\", \"twitter\", \"weibo\", \"instapaper\", \"linkedin\", \"pocket\", \"stumbleupon\" ] }, \"edit-link\": { \"base\": \"https://github.com/snowdreams1006/snowdreams1006.github.io/blob/master\", \"label\": \"编辑本页\" }, \"chart\": { \"type\": \"c3\" }, \"favicon\": \"/images/favicon.ico\", \"appleTouchIconPrecomposed152\": \"/images/apple-touch-icon-precomposed-152.png\", \"output\": \"_book\", \"donate\": { \"wechat\": \"/images/wechat.jpg\", \"alipay\": \"/images/alipay.jpg\", \"title\": \"赏\", \"button\": \"捐赠\", \"alipayText\": \"支付宝\", \"wechatText\": \"微信\" } } structure 目录结构配置 指定README.md,SUMMARY.md,GLOSSARY.md 和 LANGS.md 文件名称. 配置项 描述 structure.readme readme 文件名(默认值是 README.md) structure.summary summary 文件名(默认值是 SUMMARY.md) structure.glossary glossary 文件名(默认值是 GLOSSARY.md) structure.languages languages 文件名(默认值是 LANGS.md) pdf 配置 定制 pdf 输出格式,可能需要安装 ebook-convert 等相关插件 配置项 描述 pdf.pageNumbers 添加页码(默认值是 true ) pdf.fontSize 字体大小(默认值是 12 ) pdf.fontFamily 字体集(默认值是 Arial ) pdf.paperSize 页面尺寸(默认值是 a4 ),支持a0,a1,a2,a3,a4,a5,a6,b0,b1,b2,b3,b4,b5,b6,legal,letter pdf.margin.top 上边界(默认值是 56 ) pdf.margin.bottom 下边界(默认值是 56 ) pdf.margin.left 左边界(默认值是 62 ) pdf.margin.right 右边界(默认值是 62 ) 电子书封面照片 cover.jpg 和 cover_small.jpg,后续会详细说明. GLOSSARY.md 词汇表文件[可选] 词汇表文件,用于全书的专业词汇解释说明,比如鼠标悬停在专业词汇上会有相应提示. 语法格式: ## + ` +专业词汇` 学习 gitbook 前最好先学习下markdown和git,你知道他们的用途吗? 示例: ## markdown 简洁优雅的排版语言,简化版的 `HTML`,加强版的 `TXT`,详情请参考 [https://snowdreams1006.github.io/markdown/](https://snowdreams1006.github.io/markdown/) ## git 分布式版本控制系统,详情请参考 [https://snowdreams1006.github.io/git/](https://snowdreams1006.github.io/git/) LANGS.md 语言文件[可选] 支持国际化编写图书,一种语言一个单独子目录,同样地,将语言文件放到根目录下. 示例: * [English](en/) * [French](fr/) * [Español](es/) 章节小结 开发初始阶段运行 gitbook init 命令按照 SUMMARY.md 文件内容自动创建对应目录结构,编写各自文件内容后运行 gitbook serve 启动本地服务实时预览效果. 开发到一定程度后打算发布服务,再运行 gitbook build 输出到 _book/ 目录,别忘了配置 book.json 文件,然后就可以将 _book/ 文件夹整个扔到 nginx 等静态服务器上,这样就能联网访问你的电子书了. 是不是很简单,后续还会有如何发布与导出等相关教程,今天先到这里,下次见! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/experience/gitbook-cli.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/experience/gitbook-editor.html":{"url":"myGitbook/experience/gitbook-editor.html","title":"gitbook-editor 编辑器操作","keywords":"","body":"gitbook-editor 编辑器操作 亲测,目前已不再支持旧版 gitbook-editor 编辑器,而官网也没有相应的新版编辑器,如果哪位找到了新版编辑器,还望告知! 现在注册 gitbook 账号会默认重定向到 新版官网,而 旧版官网 的账号应该是可以正常使用的,前提是你必须之前注册过. 遗憾的是,最新注册的账号是无法使用 gitbook-editor 编辑器,不能登录到 gitbook ,也无法同步 github ,充其量只能算本地的 markdown 编辑器,所以这一节不再介绍了. 如果有兴趣了解 gitbook-editor 编辑器的基本使用,请参考 gitbook editor 编辑器. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/experience/gitbook-editor.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/experience/gitbook-com.html":{"url":"myGitbook/experience/gitbook-com.html","title":"gitbook.com 官网操作","keywords":"","body":"gitbook.com 官网操作 gitbook 官网是官方提供的图书托管的在线平台,分为新版官网(需要FQ) https://www.gitbook.com/ 和旧版官网(无需FQ) https://legacy.gitbook.com 两个网站. 目前均正常提供服务,但令人遗憾的是,两个网站的信息相互独立,而且现在注册的账号默认只能在新版官网中使用,而新版官网的访问速度简直比 github 还要慢,所以国内用户在线访问你的电子书真的需要点技术手段了! 本文主要介绍 www.gitbook.com 官网的基本使用,而 legacy.gitbook.com 网站我就算是想介绍也没有账号测试啊. \"巧妇难为无米之炊\",明明你就在那里,可我却什么也做不了. 先大概说一下 gitbook.com 网站的一些个人总结吧. gitbook.com 提供收费和免费服务,有点像早期的 github ,免费账号只能创建一个私有的命名空间,其他命名空间只能是公开的,这里的命名空间可以理解为一本书. 这一点是不是有点像早期的 github.com?免费账号无法创建私有仓库,只能是公开仓库. (现在 github.com 已被微软收购,目前可以创建无限量的私有仓库了!) 再说 gitbook 的账号问题,像 github 一样提供用户名和邮箱登录方式,他们的用户名都可以作为二级域名,比如我的用户名是snowdreams1006,那么我的 gitbook 第一本电子书网址就是 https://snowdreams1006.gitbook.io/index/ ,再看一下我的 github 个人网址 https://snowdreams1006.github.io/ ,这两个是不是很类似?! 如果不仔细看的话,八成你会觉得一样,一个是gitbook.io,另一个是github.io. 所以我严重怀疑他俩是不是有着不为人知的私密关系,太多的相似性,鼓励分享,限制私有等等特点. 无图无真相,趁着这次教程顺便将 github 个人网站项目同步到 gitbook 电子书项目了,这样的好处是本地只需要推送到 github ,自动更新 github.io 网站(利用的是github 静态网站托管服务) ,然后再自动同步到 gitbook.io 网站. 是不是很神奇,一份源码,两个官网! gitbook : https://snowdreams1006.gitbook.io/ github : https://snowdreams1006.github.io/ 注册并登陆 gitbook.com 注册信息主要包括用户名和邮箱,还有一些其他信息,没什么特殊的注意事项. 访问 https://www.gitbook.com/ 需要 FQ 新建命名空间(电子书) 注册账后后会默认生成一个私有的命名空间,因为并不打算将私有电子书托管到 gitbook,所以接下来直接将其转变成公开电子书进行演示. 个性性配置 标题和图片 主题颜色和页面反馈 观众 观众指的是当前电子书面向的受众是谁,公开的和私有的的区别以及设置是否被谷歌搜索收录. 域名 默认域名是 https://snowdreams1006.gitbook.io/,如果需要自定义域名,请保证 dns 能够正确解析到该网站. url 设置的命名空间是 index,因此最终访问路径是 https://snowdreams1006.gitbook.io/index/ 整合 gitbook 默认提供4种整合方式,在下孤陋寡闻只了解 github ,其余三种没接触过,暂不涉及. 选择 github 进行整合 登录 github 并授权 选择列出公开的仓库,然后输入用户名和密码进行登录并授权. 选择目标仓库 授权成功后会列出当前 github 账号下全部的公开仓库,选择目标仓库并点击下一步. 这里以 snowdreams1006.github.io 公开仓库为例,因为该仓库是本人官网源码项目. 同步内容 选择同步分支 根据实际情况选择同步分支,因为我一般是直接推送到 master 分支,所以 master 分支是个人网站的维护分支,因此这一步我选择的是 master. 选择同步内容 选择同步内容的方式,是从 github 同步到 gitbook,还是从 gitbook 同步到 github,因为我的项目已托管到 github ,所以初次同步内容选择的是 github --> gitbook. 显示 github 按钮 生成的电子书网站是否显示 github 按钮,作用是点击该按钮会跳转到关联的github 仓库上. 此时心里在想,万一点进 github ,随手就是一个 star 呢?哈哈! 等待内容导入 根据目标仓库的大小不同,导入内容是的时长自然也不一样,耐心等待... 上线 导入完成,电子书终于正式上线了! 现在赶紧分享一下好消息吧,访问 https://.gitbook.io/ 在线阅读! 小结 本文以如何集成 github 为例,演示了 gitbook.com 发布电子书的基本流程,由于 gitbook 电子书内容来自于 github 项目,因此我们只要更新 github 仓库,我们的 gitbook 电子书网站自然也就相应更新了! gitbook 是 markdown 和 github 的完美结合体,借助 gitbook.com 官网我们很容易发布并托管电子书. 美中不足的是,国内无法正常访问 gitbook.com ,因此并不是很推荐将电子书发布到 gitbook.com 网站. 现在国内也有类似的产品,有一种产品叫做 看云,还不错! 后续还会介绍 gitbook 如何结合 github 发布个人网站,欢迎继续关注 gitbook 系列教程! 如何打造免费的个人官网,想了解 https://snowdreams1006.github.io/ 背后的故事吗? var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/experience/gitbook-com.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/advance/advance.html":{"url":"myGitbook/advance/advance.html","title":"高级进阶","keywords":"","body":"高级进阶 不论是 gitbook-cli 命令行还是 gitbook editor 编辑器都离不开 gitbook 命令的操作使用,所以再次了解下常用命令. 注意 gitbook-cli 是 gitbook 的脚手架工具,是 gitbook 的扩展功能,同时着管理 gitbook. 查看 gitbook 帮助信息 语法格式: gitbook --help 示例: $ gitbook --help Usage: gitbook [options] [command] Options: -v, --gitbook [version] specify GitBook version to use -d, --debug enable verbose error -V, --version Display running versions of gitbook and gitbook-cli -h, --help output usage information Commands: ls List versions installed locally current Display currently activated version ls-remote List remote versions available for install fetch [version] Download and install a alias [folder] [version] Set an alias named pointing to uninstall [version] Uninstall a version update [tag] Update to the latest version of GitBook help List commands for GitBook * run a command with a specific gitbook version $ gitbook ls 列出本地安装版本 语法格式: gitbook ls 示例: # 列出本地已安装 `gitbook` 版本 $ gitbook ls gitbook current 列出当前使用版本 语法格式: gitbook current 示例: # 列出当前正在使用的 `gitbook` 版本 $ gitbook current gitbook ls-remote 列出远程可用版本 语法格式: gitbook ls-remote 示例: # 列出远程可用的 `gitbook` 版本 $ gitbook ls-remote gitbook fetch 安装指定版本 语法格式: gitbook fetch [version] 示例: # 下载并安装指定的 `gitbook` 版本 $ gitbook fetch 2.6.9 gitbook alias 指定文件夹别名 语法格式: gitbook alias [folder] [version] 示例: # 下载并安装指定的 `gitbook` 版本 $ gitbook alias /Users/sunpo/Desktop/book/gitbook/ 1.0.0 gitbook uninstall 卸载指定版本 语法格式: gitbook uninstall [version] 示例: # 卸载指定的 `gitbook` 版本 $ gitbook uninstall 2.6.9 gitbook update 更新指定版本 语法格式: gitbook update [tag] 示例: # 默认更新到最新的 `gitbook` 版本 $ gitbook update # 更新到指定的 `gitbook` 版本 $ gitbook update 2.6.9 列出 gitbook 可用命令 语法格式: gitbook help 示例: $ gitbook help build [book] [output] build a book --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) --format Format to build to (Default is website; Values are website, json, ebook) --[no-]timing Print timing debug information (Default is false) serve [book] [output] serve the book as a website for testing --port Port for server to listen on (Default is 4000) --lrport Port for livereload server to listen on (Default is 35729) --[no-]watch Enable file watcher and live reloading (Default is true) --[no-]live Enable live reloading (Default is true) --[no-]open Enable opening book in browser (Default is false) --browser Specify browser for opening book (Default is ) --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) --format Format to build to (Default is website; Values are website, json, ebook) install [book] install all plugins dependencies --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) parse [book] parse and print debug information about a book --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) init [book] setup and create files for chapters --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) pdf [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) epub [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) mobi [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) $ gitbook build 构建电子书 语法格式: gitbook build [book] [output] 示例: # 默认输出到 `_book/` 目录 $ gitbook build # 指定输出目录 `/Users/sunpo/Desktop/book/` $ gitbook build ./ /Users/sunpo/Desktop/book/ # 指定输出格式 `json` $ gitbook build --format=json gitbook serve 启动本地服务器 语法格式: gitbook serve [book] [output] 示例: # 默认服务端口: `4000`,热部署端口: `35729` $ gitbook serve # 指定输出目录 `/Users/sunpo/Desktop/book/` $ gitbook serve ./ /Users/sunpo/Desktop/book/ # 指定服务端口: `5000` 和热部署端口: `45729` $ gitbook serve --port=5000 --lrport=45729 gitbook install 安装插件 语法格式: gitbook install [book] 示例: # 安装当前项目所需插件 $ gitbook install # 安装指定项目所需插件 `/Users/sunpo/Desktop/gitbook-demo/` $ gitbook install /Users/sunpo/Desktop/gitbook-demo/ # 安装当前项目所需插件且指定日志输出级别: `debug` $ gitbook install --log=debug gitbook parse 解析电子书 语法格式: gitbook parse [book] 示例: # 解析并输出当前项目的 `debug` 级别日志信息 $ gitbook parse # 解析并输出指定项目的 `/Users/sunpo/Desktop/gitbook-demo/` 的 `debug` 级别日志信息 $ gitbook parse /Users/sunpo/Desktop/gitbook-demo/ # 解析并输出当前项目的 `info` 级别日志信息 $ gitbook parse --log=info gitbook pdf 输出 PDF 电子书 语法格式: gitbook pdf [book] [output] 示例: # 默认输出到当前项目 $ gitbook pdf # 指定输出文件 `/Users/sunpo/Desktop/book.pdf` $ gitbook pdf ./ /Users/sunpo/Desktop/book.pdf # 指定输出日志级别: `debug` $ gitbook pdf --log=debug 可能需要安装 ebook-convert 相关插件,详情见相关系列教程. gitbook epub 输出 epub 电子书 语法格式: gitbook epub [book] [output] 示例: # 默认输出到当前项目 $ gitbook epub # 指定输出文件 `/Users/sunpo/Desktop/book.epub` $ gitbook epub ./ /Users/sunpo/Desktop/book.epub # 指定输出日志级别: `debug` $ gitbook epub --log=debug 可能需要安装 ebook-convert 相关插件,详情见相关系列教程. gitbook mobi 输出 mobi 电子书 语法格式: gitbook mobi [book] [output] 示例: # 默认输出到当前项目 $ gitbook mobi # 指定输出文件 `/Users/sunpo/Desktop/book.mobi` $ gitbook mobi ./ /Users/sunpo/Desktop/book.mobi # 指定输出日志级别: `debug` $ gitbook mobi --log=debug 可能需要安装 ebook-convert 相关插件,详情见相关系列教程. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/advance/advance.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/advance/plugin.html":{"url":"myGitbook/advance/plugin.html","title":"插件介绍","keywords":"","body":"插件介绍 插件是 gitbook 的扩展功能,很多炫酷有用的功能都是通过插件完成的,其中插件有官方插件和第三方插件之分. 推荐官方插件市场 https://plugins.gitbook.com/ 寻找或下载相应的插件. 当然也可以去 npm 市场搜索 gitbook 插件,根据 gitbook 插件规范, gitbook-plugin- 是功能插件,gitbook-theme- 是主体插件. 如果没有按照规范命名,还是直接百度搜索吧! npm 安装后再 gitbook 安装 语法格式: npm install gitbook-plugin- 安装到本地: npm install gitbook-plugin-advanced-emoji 激活安装插件: 配置 book.json 中 plugins 节点 安装到项目: gitbook install 启动并测试测试: gitbook serve 示例: # 安装 gitbook-plugin-advanced-emoji 插件 $ npm install gitbook-plugin-advanced-emoji # 安装 gitbook-plugin-advanced-emoji 插件 $ gitbook install npm 安装速度慢的话,可以使用 cnpm 加速安装(npm install cnpm),表情插件下载地址 Advanced Emoji gitbook 直接安装 语法格式: gitbook install 激活安装插件: 配置 book.json 中 plugins 节点 安装到项目: gitbook install 启动并测试测试: gitbook serve 示例: # 安装 gitbook-plugin-advanced-emoji 插件 $ gitbook install 表情插件下载地址 Advanced Emoji 插件示例 Advanced Emoji表情列表 Advanced Emoji下载地址 book.json 配置文件: \"plugins\": [ \"advanced-emoji\" ] 安装插件: $ gitbook install 使用示例: :bowtie: :laughing: :relaxed: var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/advance/plugin.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/advance/plugin-practical.html":{"url":"myGitbook/advance/plugin-practical.html","title":"实用插件","keywords":"","body":"实用插件 tbfed-pagefooter 页脚插件 激活插件配置 安装 tbfed-pagefooter 插件 测试 tbfed-pagefooter 插件 disqus 评论插件 注册 disqus.com 账号 注册并绑定域名 选择服务类型 安装并配置 disqus 到网站 安装并配置 disqus 插件 激活插件配置 安装 disqus 插件 测试 disqus 插件 gitalk 评论插件 申请 GitHub Application 授权 安装并集成到网站 测试集成效果 进一步思考 小结 mygitalk 评论插件 激活插件配置 安装 mygitalk 插件 测试 mygitalk 插件 copyright 版权保护插件 激活插件配置 安装 copyright 插件 测试 copyright 插件 readmore 阅读更多插件 激活插件配置 安装 readmore 插件 测试 readmore 插件 github 插件 激活插件配置 安装 github 插件 测试 github 插件 edit-link 编辑链接插件 激活插件配置 安装 edit-link 插件 测试 edit-link 插件 github 插件 激活插件配置 安装 github 插件 测试 github 插件 search-plus 中文搜索插件 激活插件配置 安装 search-plus 插件 测试 search-plus 插件 tbfed-pagefooter 页脚插件 如果希望将网页源码暴露出去并接受公众的监督校准的话,使用edit-link插件可以直接链接到源码文件. 链接地址: https://plugins.gitbook.com/plugin/tbfed-pagefooter 激活插件配置 在 book.json 中配置 tbfed-pagefooter 插件,详细说明请参考 tbfed-pagefooter 插件. 示例: { \"plugins\": [\"tbfed-pagefooter\"], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"&copy snowdreams1006\", \"modify_label\": \"文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } 安装 tbfed-pagefooter 插件 示例: $ gitbook install 测试 tbfed-pagefooter 插件 启动本地服务后,每个页面的页脚处都会自动生成版权信息以及当前文件的最后更新时间. 功能慎用: 如果文档频繁更新适合生成最后更新时间,如果长时间不更新文档,岂不是最后更新时间还是几年前,给读者的感觉像是不再维护了一样! 示例: $ gitbook serve disqus 评论插件 discus 是一款集成评论的插件,可以为静态网站添加动态评论,让你的网站动起来! 遗憾的是,discus 插件只有 FQ 才能正常使用,暂时没找到其他较好的替代方案. 注册 disqus.com 账号 gitbook 集成 disqus 插件中最重要的配置项就是注册 disqus.com 网站唯一标识. 注册并绑定域名 如果没有注册账号请先注册,否则直接登录,当然也支持第三方账号登录(我使用的是谷歌账号). 人机验证时,选出符合条件的全部图形,直到没有新的图形为止,这一点和国内的静态图片验证是不同的! 选择安装 disqus 插件(I want to install Disqus on my site),接下来会绑定集成网站的域名. 接下来设置网站的相关信息,其中网站名称(snodreams1006)是唯一标示,接下来集成到 gitbook 用的就是这个简短名称,而分类和语言按照实际情况选择即可. 选择服务类型 disqus 网站提供的服务类型,有基础班(basic),加强版(plus),专业版(pro)和免费版(free). 每个版本计划有不同的收费标准以及相应的服务,可以根据实际情况选择适合自己的服务类型. 接下来以免费版为例进行有关演示 安装并配置 disqus 到网站 估计是这些网站提供了默认的集成方式,这里并没看到 gitbook 相关的网站,因此选择最后一个自定义网站. 填写网站的基本信息,其中网站缩写名称仍然是 snowdreams1006,网址填写 https://snowdreams1006.github.io/ ,至于其他信息根据实际情况填写即可. 至此 disqus.com 网站配置完成,接下来我们配置 gitbook 集成 disqus 插件. 安装并配置 disqus 插件 上一步我们已经获取到唯一的标识: snowdreams1006 ,接下来可以继续配置 disqus 插件了. 链接地址: https://plugins.gitbook.com/plugin/disqus 激活插件配置 在 book.json 中配置 disqus 插件,根据实际情况修改成自己的缩写名称(shortName). 示例: { \"plugins\": [\"disqus\"], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"snowdreams1006\" } } } 安装 disqus 插件 示例: $ gitbook install 测试 disqus 插件 示例: $ gitbook serve 正常情况下(FQ),disqus 插件已经成功集成到 gitbook 网站了,因此推送到实际服务器上时看到的效果是这样的. 如果你不具备条件(FQ),那么你看到的仍然是这样的. gitalk 评论插件 本篇文章发表在开源中国后得到网友 @八一菜刀 的评论,让我推荐了gitalk 评论插件,初始使用了一下,确实不错,因此在这里更新下. 上述 disqus 评论插件虽然比较好用,但是注册是在 disqus.com 官网,需要特殊手段才能访问,即便成功配置了国内一般也是访问不到的,因此功能相当鸡肋. gitalk 评论插件解决了这一痛点,利用 github 的开发者接口授权,将讨论区的 issue 变成评论区,和 github 结合的如此紧密,适合用源码托管到 github 这类情况. 先混个脸熟,看一下 gitalk 官网 是如何介绍自己的呢. 看着效果确实不错,并且评论区的内容直接作为 github 仓库的 issue,这么好的想法我咋没想到呢! 好了,现在让我们开始集成到我们自己的项目中,遇到新鲜事物,当然先要参考官网介绍了. 申请 GitHub Application 授权 登录 github 账号,点击 在线申请 授权应用. 看到这一步,想必读者已经有个大概印象了,gitalk 插件是利用 github 的开发者服务,进行授权进而调用 issue 相关接口从而显示评论功能. 这种由官网提供的开发者服务还是比较好的,至少感觉比手动模拟提交要靠谱些,更何况走的是 OAuth 授权模式. 比如第三方应用提供微信登录,走的也是 OAuth 协议,这里的第三方应用当然就是现在说的 Gitalk 插件,微信就是我们的 github . 新建应用,首页 url 和授权回调 url 填写相同的首页链接即可,其他情况自定义填写. 应用登记成功后会生成 token 令牌,clientId 和 clientSecret 需要重点保存下来,待会需要用到. 安装并集成到网站 在需要添加评论的页面,添加下述内容引入 gitalk 插件,其中参数来自我们上一步获取的 clientId 和 clientSecret . 默认应该添加到 .html 页面,当然也可以添加到 .md 页面,毕竟 markdown 语法也支持 html 标签. var gitalk = new Gitalk({ \"clientID\": \"clientId\", \"clientSecret\": \"clientSecret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo admin\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 稍微解释下参数的含义: \"clientID\" : [必选] GitHub Application Client ID \"clientSecret\" : [必选] GitHub Application Client Secret \"repo\" : [必选] GitHub repository \"owner\" : [必选] GitHub repository 所有者，可以是个人或者组织 \"admin\" : [必选] GitHub repository 的所有者和合作者 (对这个 repository有写权限的用户) \"id\" : [可选] 页面的唯一标识,默认值: location.href, 长度必须小于50,否则会报错! \"distractionFreeMode\": [可选] 类似 Facebook 评论框的全屏遮罩效果,默认值: false 上述配置只是最简配置,如果想要了解更多高级配置,请参考 官方文档 测试集成效果 按照上述安装步骤,将代码复制到首页(README.md)文件中,然后推送到 github ,体验下集成效果. 注意: 这里必须推送到服务器,因为申请应用时填写的域名是线上地址,因而本地测试是不会成功的,会报错,这一点和微信支付的回调地址类似. 示例: var gitalk = new Gitalk({ \"clientID\": \"3f62415a283d19cbd696\", \"clientSecret\": \"aed0e1db0620bf5d0e3a3f0225f801997ad74e58\", \"repo\": \"snowdreams1006.github.io\", \"owner\": \"snowdreams1006\", \"admin\": [\"snowdreams1006\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 上述参数仅供参考,实际使用中请替换成自己的配置,不然你也没有我仓库的权限,肯定会报错的啊! 心心相念的 gitalk 评论区呢?是不是哪里配置错了,为啥没有出来? 别急,要淡定,看一下提示说\"未找到的 Issue 进行评论,请联系 @snowdreams1006 初始化创建\",既然如此,那我们就操作一下吧! 点击下方的按钮 使用 Github登录 ,会跳转到相应的仓库,然后按照提示确定. 再次返回首页,刷新一下看看发生什么神奇的事情了? 终于集成了评论功能,而且还支持 markdown 格式的评论呢! 进一步思考 确实不错,心中自然是欣喜万分,但别高兴太早了,因为你会发现其他页面并没有评论区,也很好理解,我们目前仅仅在首页(README.md) 集成了 gitalk 插件,也就是说使用 gitbook build 输出的 index.html 首页才支持评论区,其他页面没有插入上述代码,自然是没有评论区功能的啊! 那如果想要实现全网站的所有页面都集成评论区功能,应该怎么办呢? 百度搜索了一下,并没有找到优雅的解决方案,如果有人能够提供更好的解决方案,还望不吝赐教,在此谢过. 既然网上找不到优雅的解决方案,那寻求专业人士的帮助也是一种好办法,我去哪找 gitalk 的使用者呢? 聪明的你或许已经想到了,解铃还须系铃人,当然是向推荐给我插件的大牛提问了! 他确实提供了一种思路,以下是网友@八一菜刀原话: 文档里面我用的是tbfed-pagefooter插件，不过我是在本地使用gitbook install后重写了该插件的js，无非就是在js里面加一段Gitalk的调用代码，这样使用gitbook build命令的时候，所有的页面都会有Gitalk的评论调用 人家既然已经提供了思路,不太好意思继续麻烦人家要源码,既然如此,那就自己动手吧! tbfed-pagefooter 插件很熟悉,一般是用于注明版权以及文章的修订时间的,而且作用于每个页面,这一点就满足了集成 gitalk 相关代码的基本要求. 大体方向确定后,目前就是解决如何在 tbfed-pagefooter 插件构建的相关生命周期内顺便执行我们的代码? 正常当前项目安装 tbfed-pagefooter 插件后应该存放于 /node_modules/gitbook-plugin-tbfed-pagefooter 目录,大致看一下插件的项目结构. gitbook-plugin-tbfed-pagefooter ├── LICENSE ├── README.md ├── assets │ └── footer.css ├── index.js └── package.json 1 directory, 5 files $ 为了基本看懂项目文件作用,特意去看了下 gitbook 插件开发文档,目标锁定在 index.js . 截取重要片段,原来是电子书构建前动态增加了 html 片段啊,这就好办了! hooks: { 'page:before': function(page) { var _label = '最后更新时间: ', _format = 'YYYY-MM-DD', _copy = 'powered by snowdreams1006' if(this.options.pluginsConfig['tbfed-pagefooter']) { _label = this.options.pluginsConfig['tbfed-pagefooter']['modify_label'] || _label; _format = this.options.pluginsConfig['tbfed-pagefooter']['modify_format'] || _format; var _c = this.options.pluginsConfig['tbfed-pagefooter']['copyright']; _copy = _c ? _c + ' all right reserved，' + _copy : _copy; } var _copy = ''+_copy+''; var str = ' \\n\\n' + _copy + '' + _label + '\\n{{file.mtime | date(\"' + _format + '\")}}\\n'; str += '\\n\\n'+ '\\n\\n'+ '\\n\\n'+ '\\n\\n'; page.content = page.content + str; return page; } } 看懂基本原理后顺便修改了版权说明以及修订时间格式,然后追加了集成 gitalk 的相关代码. 这里为了方便修改 gitalk 配置,特意将相关配置项单独托管到 github 专门的 gitalk-config.js 文件. 至于配置文件的内容,并没什么特殊之处,还是顺便贴一下吧! var gitalk = new Gitalk({ \"clientID\": \"3f62415a283d19cbd696\", \"clientSecret\": \"aed0e1db0620bf5d0e3a3f0225f801997ad74e58\", \"repo\": \"snowdreams1006.github.io\", \"owner\": \"snowdreams1006\", \"admin\": [\"snowdreams1006\"], \"id\": window.location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 至此,之后再本地构建电子书时(gitbook build),gitbook-plugin-tbfed-pagefooter 自然会顺便帮我们运行集成 gitalk 的相关代码,这才是相对来说比较优雅的做法. 当然也不一定非要借助 gitbook-plugin-tbfed-pagefooter 插件帮忙,也可以借助别的插件进行集成,甚至自己写个更好的插件. 小结 gitalk 插件相对 disqus 插件来说,更符合基本国情,只不过默认的集成方式只能一个页面一个页面去集成,当数量比较多时,工作量不敢想象. 因此,通过 gitbook 插件开发的方式,在源码文件输出为目标文件时加入相关集成代码,相当于手写100条输出语句和循环写100条输出语句. 其实本质上并没有改变什么,仍然是集成到每个页面中,但是简化了人工操作的工作量就是效率的提升. 如果有更高效更优雅的集成方式,欢迎大家一起探讨. mygitalk 评论插件 如果你正在苦恼于 Gitbook 静态博客无法添加动态交互功能,如果你渴望接收用户的评论反馈,如果你看过 gitalk 插件却苦于没有现成的 Gitbook 插件,那么 mygitalk 插件值得一试! 链接地址: https://snowdreams1006.github.io/gitbook-plugin-mygitalk/ gitbook-plugin-mygitalk 是全网最早发布的基于 gitalk 实现评论插件,用于给 Gitbook 博客网站集成评论功能. 激活插件配置 在 book.json 中配置 mygitalk 插件,详细说明请参考 mygitalk 插件. 示例: { \"plugins\" : [\"mygitalk\"], \"pluginsConfig\": { \"mygitalk\": { \"clientID\": \"GitHub Application Client ID\", \"clientSecret\": \"GitHub Application Client Secret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo owner and collaborators, only these guys can initialize github issues\"], \"distractionFreeMode\": false } } } 安装 mygitalk 插件 示例: $ gitbook install 测试 mygitalk 插件 启动本地服务器后可能会提示联系管理员,只需要 gitbook build 上传到目标服务器上即可正常开启评论功能. 示例: $ gitbook serve copyright 版权保护插件 如果你的博客不希望被别人随意转载或者文章希望保留首发网站信息,那么推荐使用copyright插件帮助你进行版权保护. 链接地址: https://snowdreams1006.github.io/gitbook-plugin-copyright/ gitbook-plugin-copyright 版权保护插件实现复制文章时自动追加版权保护信息,并在文章结尾处追加来源信息. 激活插件配置 在 book.json 中配置 copyright 插件,详细说明请参考 copyright 插件. 示例: { \"plugins\": [\"copyright\"], \"pluginsConfig\": { \"copyright\": { \"site\": \"https://snowdreams1006.github.io/gitbook-plugin-copyright\", \"author\": \"雪之梦技术驿站\", \"website\": \"雪之梦技术驿站\", \"image\": \"https://snowdreams1006.github.io/snowdreams1006-wechat-open.png\" } } } 安装 copyright 插件 示例: $ gitbook install 测试 copyright 插件 默认情况下,版权保护信息是英文,如果 book.json 配置文件中指定中文语言 \"language\": \"zh-hans\" 时,内容复制以及文章末尾均为中文. 示例: $ gitbook serve readmore 阅读更多插件 如果 Gitbook 个人博客流量不错的话,可以考虑转化成公众号流量,readmore 插件是集成OpenWrite提供引流工具,通过关注公众号解锁博客文章,实现粉丝转换! 链接地址: https://snowdreams1006.github.io/gitbook-plugin-readmore/ 激活插件配置 在 book.json 中配置 readmore 插件,详细说明请参考 readmore 插件. 示例: { \"plugins\": [\"readmore\"], \"pluginsConfig\": { \"readmore\":{ \"blogId\": \"15702-1569305559839-744\", \"name\": \"雪之梦技术驿站\", \"qrcode\": \"https://snowdreams1006.github.io/snowdreams1006-wechat-public.jpeg\", \"keyword\": \"vip\" } } } 安装 readmore 插件 示例: $ gitbook install 测试 readmore 插件 readmore 插件暂未验证绑定域名,本地测试也能正常运行,如果后续开启了域名验证,只有部署到线上服务器才能生效,这一点和 mygitalk 插件原理类似. 示例: $ gitbook serve github 插件 添加 github 图标链接,方便直接跳转到 github 指定仓库. 链接地址: https://plugins.gitbook.com/plugin/github 激活插件配置 在 book.json 中配置 github 插件,详细说明请参考 github 插件. 示例: { \"plugins\": [\"github\"], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" } } } 安装 github 插件 示例: $ gitbook install 测试 github 插件 示例: $ gitbook serve edit-link 编辑链接插件 如果希望将网页源码暴露出去并接受公众的监督校准的话,使用edit-link插件可以直接链接到源码文件. 链接地址: https://plugins.gitbook.com/plugin/edit-link 激活插件配置 在 book.json 中配置 edit-link 插件,详细说明请参考 edit-link 插件. 示例: { \"plugins\": [\"edit-link\"], \"pluginsConfig\": { \"edit-link\": { \"base\": \"https://github.com/snowdreams1006/snowdreams1006.github.io/blob/master\", \"label\": \"编辑本页\" } } } 安装 edit-link 插件 示例: $ gitbook install 测试 edit-link 插件 如果不能正常跳转到源码文件,多次试验后重新更改 edit-link.base 节点内容,重新 gitbook serve 即可正常跳转源码文件. 示例: $ gitbook serve github 插件 添加 github 图标链接,方便直接跳转到 github 指定仓库. 链接地址: https://plugins.gitbook.com/plugin/github 激活插件配置 在 book.json 中配置 github 插件,详细说明请参考 github 插件. 示例: { \"plugins\": [\"github\"], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" } } } 安装 github 插件 示例: $ gitbook install 测试 github 插件 示例: $ gitbook serve search-plus 中文搜索插件 默认的 search 搜索插件是不支持中文搜索的,而 search-plus 则功能更强大些,两者不能共存,需要禁用或移除 search 插件. 链接地址: https://plugins.gitbook.com/plugin/search-plus 激活插件配置 在 book.json 中配置 github 插件,详细说明请参考 github 插件. 示例: { \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\" ] } 安装 search-plus 插件 示例: $ gitbook install 测试 search-plus 插件 测试是否能够进行中文搜索,如果不能,请确保已移除默认的 \"lunr\" 和 \"search\" 插件. 示例: $ gitbook serve var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/advance/plugin-practical.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/advance/plugin-theme.html":{"url":"myGitbook/advance/plugin-theme.html","title":"主题插件","keywords":"","body":"主题插件 Book 文档 theme-default 主题 theme-comscore 主题 API 文档 theme-api 插件 FAQ 文档 theme-faq 插件 小结 目前 gitbook 提供三类文档: Book 文档,API 文档和 FAQ 文档. 其中,默认的也是最常使用的就是 Book 文档,如果想要了解其他两种文档模式,需要引入相应的主题插件. 官方主题插件文档: https://toolchain.gitbook.com/themes/ Book 文档 theme-default 主题 插件地址: https://plugins.gitbook.com/plugin/theme-default theme-default 是 3.0.0 引入的默认主题,大多数插件针对的都是默认主题,如果切换到其他主题或者自定义主题,可能会造成某些情况下不兼容,甚至报错. 默认情况下,左侧菜单不显示层级属性,如果将 showLevel 属性设置为 true 可以显示层级数字. 示例: \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true } } 效果: 默认情况下左侧菜单树不显示目录层级 开启层级显示设置后,左侧菜单树显示当前目录层级 theme-comscore 主题 插件地址: https://plugins.gitbook.com/plugin/theme-comscore default 默认主题是黑白的,而 comscore 主题是彩色的,即标题和正文颜色有所区分. 示例: \"plugins\": [ \"theme-comscore\" ] 效果: 默认情况下各级标题颜色均是黑色,不同级别的标题仅仅是大小区别. 设置 comscore 主题后,各级标题颜色不同,不仅仅是大小不同. API 文档 theme-api 插件 插件地址: https://plugins.gitbook.com/plugin/theme-api 如果文档本身是普普通文档模式,切换成 api 文档模式后并不会有太大变化,除非一开始就是接口文档,那样使用 theme-api 插件才能看出效果. 示例: { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"theme\": \"dark\" } } } 语法: 方法区 语法区 示例: 效果: 添加 api 相关方法后的文档效果,正常会两列显示并在右上角增加语言切换工具. FAQ 文档 theme-faq 插件 插件地址: https://plugins.gitbook.com/plugin/theme-faq theme-faq 可以帮助我们构建问答中心,预设好常见问题以及相应答案模式,同时为了方便搜索到问题或答案,一般需要搜索插件的配合. 示例: { \"plugins\": [ \"theme-faq\", \"-fontsettings\", \"-sharing\", \"-search\", \"search-plus\" ] } 帮助中心没有工具栏,因此涉及到工具类的插件一律失效或主动移除,同时默认搜索插件也会失效. 语法: 增加文章间的关联 --- related: - some/other/page.md - another_related_article.md --- Content of my article! 在当前页面底部显示延伸阅读,支持 yaml 语法关联到其他页面. 增加头部 logo 新建 _layouts/website/page.html 文件,用于扩展当前主题插件来增加自定义 logo. 增加导航栏链接 新建 _layouts/website/page.html 文件,用于扩展当前主题插件来增加自定义导航栏链接. 示例: 新建 _layouts/website/page.html 文件,增加自定义 logo 和导航栏链接. 效果: 小结 本节主要讲解了常用的三种文档模式,其中 default 主题插件,适合一般的博客类网站或静态网站,api 主题插件适合接口文档的编写,faq 主题插件则适合帮助中心. 三种主题插件分别对应不同的应用场景,默认情况下使用的是 default 主题插件,平时介绍的大多数功能插件也大多适合这种主题,另外两种主题可能就不能很好兼容第三方插件,需要亲身体验. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/advance/plugin-theme.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/advance/plugin-develop.html":{"url":"myGitbook/advance/plugin-develop.html","title":"开发插件","keywords":"","body":"开发插件 什么是插件 Gitbook 插件是扩展 GitBook 功能(电子书和网站)的最佳方式. 只要是 Gitbook 默认没有提供的功能,基于插件机制都可以自行扩展,是插件让 Gitbook 变得更加强大. 本文将全面介绍插件的相关知识并重点介绍插件开发的全流程,只有熟悉插件开发流程才能做到有的放矢,心中有数,进而开发出自己的插件. 关于插件请参考 Gitbook 入门教程高级进阶系列文章,本文重点讲解开发 Gitbook 的基本流程. gitbook 入门教程之插件介绍 gitbook 入门教程之实用插件 gitbook 入门教程之主题插件 如何发现插件 您可以在Gitbook官网轻松搜索插件,也可以在npmjs 官网搜索 gitbook-plugin- 插件. 目前 Gitbook 官方已不再为维护插件网站,只能通过 npmjs 发现 Gitbook 插件. 如何安装插件 一旦你找到你想要安装的插件,你需要将它添加到你的 book.json 配置文件,如果没有该文件则自行创建. { \"plugins\": [\"myPlugin\", \"anotherPlugin\"] } 您还可以使用以下命令指定特定版本: myPlugin@0.3.1 . 默认不填写版本的情况下,GitBook 使用最新版本(兼容版本)的插件. 安装插件 如果是官网在线环境,网站会自动帮你安装插件. 如果是在本地环境,直接运行 gitbook install 来安装插件. $ gitbook install 或者使用 npm 提前下载插件再安装到本地项目: $ npm install gitbook-plugin- $ gitbook install 配置插件 插件的配置在 book.json 配置文件中的 pluginsConfig 属性中(如果没有该属性请自行创建), 安装插件时,最好浏览插件的文档了解相关选项的详细信息. { \"plugins\": [\"github\"], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" } } } 有些插件并未提供插件配置项,可以省略该步骤,有的插件会提供配置项,以插件介绍文档为准. 如何开发插件 GitBook 插件是在 npm 上发布的遵循传统定义的 node 包,除了标准的 node 规范外还有一些 Gitbook 自身定义的相关规范. 目录结构 Gitbook 插件最基本的项目结构至少包括配置文件 package.json 和入口文件 index.js ,其他目录文件根据插件用途自行增减. . ├── index.js └── package.json 实际插件项目略有不同,可能还会有 _layouts 布局目录, asset 资源目录以及自定义 example 示例目录和 docs 文档目录等等. package.json package.json 是nodejs的配置文件,Gitbook 插件同样遵循该规范,配置文件声明了插件的版本描述性信息,除此之外还有 Gitbook 相关字段,遵循schema准则,基本示例如下: { \"name\": \"gitbook-plugin-mytest\", \"version\": \"0.0.1\", \"description\": \"This is my first GitBook plugin\", \"engines\": { \"gitbook\": \">1.x.x\" }, \"gitbook\": { \"properties\": { \"myConfigKey\": { \"type\": \"string\", \"default\": \"it's the default value\", \"description\": \"It defines my awesome config!\" } } } } 值得注意的是,包名称必须以 gitbook-plugin-开头，包引擎应该包含gitbook.如需了解 package.json 的规范,可参考官方文档 index.js index.js 是插件运行时的入口,基本示例如下: module.exports = { // 钩子函数 hooks: {}, // 代码块 blocks: {}, // 过滤器 filters: {} }; 发布插件 GitBook 插件可以在npmjs官网上发布. 如需发布插件,首先需要在npmjs官网上注册帐户,然后通过命令行发布. $ npm publish 专用插件 专用插件可以托管在 GitHub 上,并使用 git urls: { \"plugins\": [ \"myplugin@git+https://github.com/MyCompany/mygitbookplugin.git#1.0.0\" ] } 本地测试插件 使用 npm link 可以在发布之前测试你的插件,命令详情参考官方文档 在插件的文件夹中,运行： $ npm link 然后在您的书或者文档的文件夹中执行: $ npm link gitbook-plugin- 单元测试插件 gitbook-tester可以方便地为你的插件编写Node.js/Mocha单元测试. 使用Travis.可以对每个提交/标签运行测试. 插件总结 Gitbook 插件是扩展 Gitbook 功能的不二之选,如果熟悉 nodejs 项目的开发流程,只要稍微熟悉下 Gitbook 提供的接口文档,开发出自己的插件应该不是难事! 希望本文能够对你理解 Gitbook 插件有所帮助,了解并熟练掌握插件开发的全流程,如果本文对你有所帮助,别忘了给我一个正面反馈以鼓励我继续创作哟! 阅读延伸 什么是Gitbook插件 如何创建Gitbook插件 如何测试Gitbook插件 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/advance/plugin-develop.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/advance/export.html":{"url":"myGitbook/advance/export.html","title":"导出电子书","keywords":"","body":"导出电子书 gitbook 既可以将源码文件单独输出,也可以仅输出单个文件,常见的导出电子书格式主要有三种(ePub, Mobi, PDF),而这三种格式都依赖于系统本身提供的 ebook-convert 工具. 安装依赖 如果直接运行 gitbook pdf 相关命令,可能会报错,提示需要安装 ebook-convert 插件,根据提示本地需要安装 calibre 软件,这样 gitbook 才能正常导出电子书. calibre 官网: https://calibre-ebook.com/ linux 系统 下载地址: https://calibre-ebook.com/download_linux 下载应用 $ sudo -v && wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin 配置软链接 $ sudo ln -s /usr/bin/nodejs /usr/bin/node mac 系统 下载地址: https://calibre-ebook.com/download_osx 下载应用 将 calibre.app 移动到应用程序文件,然后尝试是否能正常打开应用. 配置软链接 $ sudo ln -s ~/Applications/calibre.app/Contents/MacOS/ebook-convert /usr/bin 测试命令 $ ebook-convert --version 如果没有输出 ebook-convert 版本信息,可能需要配置环境变量. windows 系统 下载地址 : https://calibre-ebook.com/download_windows 和一般的应用下载安装方式一样,无外乎选择一下软件安装位置和书籍存放目录,安装过程略过,动图演示. 软件安装前如果使用命令行运行 ebook-convert 相关命令会提示无法查找该命令,安装后需要重新打开新的命令行工具再次运行 ebook-convert --version 就能输出版本信息,表示安装成功. 只有新打开的命令行窗口运行 ebook-convert 才会生效1,原来的命令行窗口依旧没有会报错的呢,记住啦! 示例: Administrator@snowdreams1006 MINGW64 /f/workspace/snowdreams1006.github.io (master) $ ebook-convert --version ebook-convert.exe (calibre 3.46.0) Created by: Kovid Goyal 配置封面 所有格式的电子书都可以配置自定义封面,在项目的根目录下提供 cover.jpg 和 cover_small.jpg 两种封面图片时,生成电子书会自动增加封面页. 当然你也可以使用 autocover 插件 自动生成封面,不过本人才疏学浅,几经尝试始终没有成功,如果有人成功了记得给我留言下哈! 封面的基本要求: cover.jpg 尺寸大小: 1800X2360 px,cover_small.jpg 尺寸大小: 200x262 px; 无边界 清晰可见的书名 任何重要的文字在小版本封面图片中也要清晰可见 更多封面相关规范请参考 https://toolchain.gitbook.com/ebook.html 基本命令 语法格式: gitbook pdf 或 gitbook epub 或 gitbook mobi 示例: # 生成 `pdf` 文件并输出 `debug` 级别日志 $ gitbook pdf ./ ./myBook.pdf --log=debug # 生成 `epub` 文件并输出 `debug` 级别日志 $ gitbook epub ./ ./myBook.epub --log=debug # 生成 `mobi` 文件并输出 `debug` 级别日志 $ gitbook mobi ./ ./myBook.mobi --log=debug 相信大家对 PDF 格式比较熟悉,其余两种格式只是不同电子书格式,因而需要相应软件支持. 生成 PDF 文件 示例: $ gitbook pdf 默认在当前项目的根目录下生成 book.pdf 文件名,如果配有封面,则首页显示封面,否则无封面. 生成 ePub 文件 示例: $ gitbook epub 默认在当前项目的根目录下生成 book.epub 文件名,如果配有封面,则首页显示封面,否则无封面. 生成 mobi 文件 示例: $ gitbook mobi 默认在当前项目的根目录下生成 book.mobi 文件名,如果配有封面,则首页显示封面,否则无封面. 小结 本节主要介绍了如何导出电子书,概括来说,首先系统需要安装 ebook-convert 工具,然后配置电子书封面,最后直接导出为目标格式(ePub, Mobi, PDF)进行输出. 随着电子书内容越来越多,生成电子书所花费的时间也越来越久,实属正常,耐心等待即可. 输出 PDF 文件并输出 debug 日志: gitbook pdf --log=debug var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/advance/export.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/advance/publish.html":{"url":"myGitbook/advance/publish.html","title":"发布电子书","keywords":"","body":"发布电子书 输出目标文件 语法格式: gitbook build [book] [output] 默认情况下,gitbook 输出方式是静态网站,其实 gitbook 的输出方式有三种: website, json,和 ebook. 只不过另外两种不是很常用,更多情况下我们是使用静态网页搭建个人官网,或托管到第三方平台,或部署到私有云服务器,但不管怎么样,还是离不开生成这一步. 示例: # 默认输出格式: `website` $ gitbook build --format=website # 更改输出格式: `json` $ gitbook build --format=json # 更改输出格式: `ebook` $ gitbook build --format=ebook 默认情况下输出目录: _book/,整个项目的入口文件是: index.html 集成 github 网站 本教程的电子书源码和输出文件均托管到 github 网站,所以这里介绍下如何利用 Github Pages 静态网页服务与 gitbook 进行集成. 什么是 GitHub Pages ? Github Pages 是 github 网站推出的一种免费的静态网页托管服务,适合搭建静态的项目主页或个人官网. 其中,网站项目的源码直接托管在 github 仓库中,当仓库文件更新后,该仓库所关联的网站自动更新,从而实现了源码与官网的联动更新. 如果想了解更多详情,请参考官网: https://pages.github.com/ 怎么做 GitHub Pages ? 每个账号有且只有一个主页站点,但允许无限制多的项目站点. 啥是主页站点,项目站点又是啥? 别急,让我先举个例子看一下最终效果. 假如用户名: zhangsan 名下有四个公开仓库,一个仓库名叫做: zhangsan.github.io,另外三种分别是: project01,project02,project03 . 如果想要对外暴露上述四个仓库作为我们的静态网站,那么最终效果就是下面这样的. 主页站点: https://zhangsan.github.io 项目01站点: https://zhangsan.github.io/project01 项目02站点: https://zhangsan.github.io/project02 项目03站点: https://zhangsan.github.io/project03 注意将 zhangsan 替换成自己的 github 用户名,否则八成是打不开网站,除非真的有 zhangsan 这个用户. 其实上述规则很好理解,github 网站作为一个托管中心,有成千上万的用户在使用 github 并且每个用户的用户名都是唯一并且不同的,因此 *.github.io 通配符域名刚好充当命名空间. 可以预料的是,不仅仅有 .github.io 这种二级域名,说不定还有 api.github.io,docs.github.io 等等,毕竟只需要购买 *.github.io 通配符域名证书就可以支持任意多的二级域名了,感谢 github 赠送我们免费的 https 网站. 说到这里,不得不吐槽下 gitbook 的命名空间策略了,gitbook 也有自己的电子书托管服务,但访问地址是 .gitbook.io/ . 很显然,gitbook 没有区分主页站点和项目站点,相当于全部都是项目站点,缺少主次之分. 闲言少叙,既然知道了输入内容和输出效果,那么接下来的任务就是了解中间过程了,让我们一起探讨下怎么发布网站吧! 主页站点 创建 .github.io 公开仓库 前往 https://github.com/ 网站创建名为 .github.io 的公开仓库. 比如我的用户名是: snowdreams1006 ,那么我的主页站点仓库就是: snowdreams1006.github.io 创建首页 index.html 文件 不管是在线直接创建 index.html 还是克隆到本地创建 index.html ,最终的 .github.io 仓库一定要有 index.html 首页文件. 示例: # 克隆到本地 $ git clone https://github.com/username/username.github.io # 切换到项目 $ cd username.github.io # 创建 `index.html` 文件 $ echo \"Hello World\" > index.html # 推送到远程仓库 $ git add --all $ git commit -m \"Initial commit\" $ git push -u origin master 访问主页站点 https://username.github.io 打开浏览器,输入网址: https://username.github.io 访问主页站点,显示的内容正是我们刚刚提交的 index.html 文件内容. 如果没有正常显示,清除浏览器缓存强制刷新试试看! 项目站点 相比主页站点来说,项目站点命名比较随意了,作为静态网站不可或缺的文件仍然是 index.html. 创建首页 index.html 文件 创建首页文件并添加测试内容,方便待会在线访问项目站点测试是否部署成功. 设置 GitHub Pages 选项 点击仓库首页右上方设置(Settings)选项卡,往下翻到 GitHub Pages 选项,选择源码目录,根据实际情况选择源码来源于 master 分支还是其他分支或者docs/ 目录. 方便起见,选择第一个 master 分支即可,注意下面的主题和这一步的来源只能两者选其一,否则主题优先级更高! 访问主页站点 https://username.github.io/ 打开浏览器,输入网址: https://username.github.io/repository 访问项目站点,显示的内容正是我们刚刚提交的 index.html 文件内容. 如果没有正常显示,清除浏览器缓存强制刷新试试看! 如何集成 gitbook ? 我们已经知道 Github Pages 是提供静态网站的免费托管,而 gitbook 默认生成的内容就是静态网站,两者如何结合自然不用我多说了吧? gitbook 默认输出目录 _book/ 包括了静态网站所需的全部资源,其中就包括 index.html 首页文件. 因此我们只需要每次生成后将 _book/ 整个目录复制到项目根目录,那么推送到远程仓库时自然就是输出后静态网站了啊! 示例: # 生成静态网站 $ gitbook build # 复制到项目根目录 $ cp -r _book/* . # 添加到本地版本库 $ git add . $ git commit -m \"publish\" # 推送到远程仓库 $ git push origin master 现在登录 github 网站看一下静态网站是否成功上传以及访问主页站点或项目站点看一下最新内容是否成功渲染吧! 小结 本节我们学习 gitbook 有三种输出方式,其中默认的网页输出最为常用. 除此之外,还讲解了如何与 github pages 进行结合,从而实现源码和网站的自动更新维护. 如果源码没有托管到 github 这种第三方服务商,你也可以搭建自己的服务器,比如将 _book/ 目录全部扔到 nginx 服务器做静态资源服务器等. 毕竟,源码和输出内容都在你手中,想怎么玩还不是自己说了算? var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/advance/publish.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/openwrite/":{"url":"myGitbook/openwrite/","title":"公众号引流","keywords":"","body":"公众号引流 相信大多数博客作者都或多或少有过这样想法: 现在各种平台这么多,想要实现全平台发布就要到处复制粘贴,等我有空一定做统一平台一次性全部解决! 不知道正在阅读文章的你,有没有这样的想法? 反正我确实这么想过,甚至 github 上相关项目早已创建,可一直迟迟没有下一步,要么是工作忙,要么是技术储备不够,总有一大堆借口自我安慰! 如果只是专注于某一两家平台,这种需求可能不会那么强烈,可是如果你和我一样曾经手动复制粘贴过下面这么多平台,那么我相信你一定可以体会一文多发的迫切性! 幸运的是,在一文多发探索的路上并不孤单,不堪其扰的大佬们早已说干就干动手解决了这个问题,有的是开源平台,有的是 SAAS 服务,大家都在努力... 其中,SAAS 服务可能是最简单上手的方式了,这就是今天的主角: OpenWrite 一文多发平台! 如果你热衷于写文记录点滴、分享心得 如果你钟情于 markdown 的简洁、流畅与纯粹 如果你专注于内容创作,而对很多网络抄袭无可奈何 那么,希望 https://openwrite.cn/ 可以帮助你！ 一文多发 OpenWrite 提供的众多功能中最吸引我的地方莫过于一文多发功能了: 我在用的平台它都有,我没用的平台它也有! 还是熟悉的 markdown 编辑器,便捷的自动认证功能,发布文章再也不用一处编辑,到处复制了,顺便解决了一直令人困扰的图片上传问题. 目前已提供的平台中涵盖了绝大部分技术博客平台,相信以后会支持更多平台的吧,再也不用复制粘贴那么多次了呢! 平台整体上使用体验非常不错,大致步骤是先提前登陆各大目标平台,然后通过 OpenWrite 提供的插件自动进行渠道认证,配置各大渠道后就可以愉快发文啦! 稍微摸索下就能很快上手,在这里不再赘述了,不了解的小伙伴们可以看看 技术文章博客，互联网运营平台 OpenWrite 公众号引流 如果你有自己独立博客,也在运营者微信公众号,但是苦于没有很好的手段引导读者关注公众号,那么Openwrite 推出的 ReadMore 工具绝对可以解决燃眉之急,真的可以说是良心之作! 效果怎么样看了就知道 静态博客网站集成 ReadMore 工具后,全站博客文章内容自动隐藏一半,同时浮现出阅读全文的按钮引导读者点击解锁. 一旦读者想要阅读全文就会主动点击按钮,此时就会自动弹出引导用户关注公众号的弹窗. 此时,用户有三种选择,要么扫码关注公众号解锁全站文章,要么掉头走人不再阅读,或者以其人之道还治其人之身,技术绕过直接解锁! 当然,我们自然是希望所有的读者都可以转换成公众号粉丝,所以接下来读者应该是关注公众号回复关键字获取验证码进而解锁文章. 读者关注公众号后,发送关键字获取文字链接并点击该链接,此时就会获取验证码,离成功只差一步! 再次回到博客平台的受限文章,输入刚刚获取到的验证码,不仅解锁了当前文章,博客内的其他文章也全部自动解锁,并不会造成不好体验,完美! 从陌生读者成公众号粉丝,整个操作流程一气呵成,没有丝毫卡顿也没有任何门槛,一切都是这么自然! 所以,如果你有自主运营的个人博客,想要转换成公众号粉丝,那么 ReadMore 工具简直就是躺增粉丝利器啊! 自主集成 ReadMore 工具集成步骤比较简单,按照相关官方教程说明,大致可以分为两步: 如果博客文章比较少的话,这么设置是任何没有问题的,大不了多复制一下就可以了. 但是如果博客文章比较多,肯定不能手动复制粘贴了,此时应该将该规则自动应用到全部文章中,如此一来,个人博客文章全部拥有该功能. 插件集成 熟悉了自主集成的基本思路后,不难发现,集成 ReadMore 工具只需要保证个人博客支持运行 Js 代码即可! 这个要求确实不高,哪怕是 Gitbook + Github Pages 搭建的静态网站也是支持运行 Js 代码的,更何况整合 Github 后还提供了免费域名,刚好满足 ReadMore 的条件. 说干就干,于是乎,花了一整晚的时间弄了 gitbook 插件来集成 ReadMore 工具. 安装 openwrite 插件 在 book.json 配置文件中,添加 openwrite 插件到 plugins 数组中,示例如下: { \"plugins\" : [\"openwrite\"] } 声明插件后需要添加相关配置信息,来源于 OpenWrite 后台,务必修改成自己真正的配置信息! { \"pluginsConfig\":{ \"openwrite\":{ \"blogId\": \"15702-1569305559839-744\", \"name\": \"雪之梦技术驿站\", \"qrcode\": \"https://snowdreams1006.github.io/snowdreams1006-wechat-public.jpeg\", \"keyword\": \"vip\" } } } 插件声明并配置后,通过 gitbook 或 npm 命令行方式安装 openwrite 插件到本地. $ gitbook install 或者 $ npm install gitbook-plugin-openwrite 运行 openwrite 插件 本地运行 gitbook serve 命令后,赶快验证下是否成功通过 gitbook-plugin-openwrite 插件集成 ReadMore 工具吧! 如果没有问题的话,运行 gitbook build 生成的目标文件上传到 github 或其他静态服务器就能轻松集成 ReadMore 工具! 如果可以的话,欢迎给 https://github.com/snowdreams1006/gitbook-plugin-openwrite 一个 Star ,告诉我的确有人在用! 集成思路 按照 OpenWrite 官方 ReadMore工具 集成指南,关于博客设置部分只需要将自己的专属配置信息插入到具体博客文章中即可实现集成. 但是,大多数博客平台编写博客文章时都是编写 markdown 而不是 html,因而 不太方便直接插入 js 代码,比较方便的做法是修改全局性质的模板文件. 而关于 gitbook 的模板文件位于根目录下的 _layouts/website/page.html ,所以要么直接修改模板,要么通过插件方式自定义模板! 本来打算直接修改 gitbook 模板文件,但是独乐乐不如众乐乐,所以还是采用插件的方式扩展吧! 核心代码如下,修改模板文件,在文章内容外面包裹一层 div 作为目标区域并运行集成 Js 代码片段. {% extends template.self %} {% block page %} {{ page.content|safe }} {% endblock %} {% block javascript %} {{ super() }} const btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"{{ config.pluginsConfig.openwrite.blogId }}\", \"name\": \"{{ config.pluginsConfig.openwrite.name }}\", \"qrcode\": \"{{ config.pluginsConfig.openwrite.qrcode }}\", \"keyword\": \"{{ config.pluginsConfig.openwrite.keyword }}\" }); {% endblock %} 实现思路还是比较简单明确的,这里简单对其中的细节做些解释说明. 构建目标区域 {% block page %} {{ page.content|safe }} {% endblock %} page.content 是每个页面当前的文件内容,不再是原生的 markdown 类型而是 html 类型,这一点非常重要,因为 gitbook 并不会处理 div 内嵌的 markdown 内容! 之前一直尝试想通过 Js 方式直接嵌套一层目标区域 div,但是只找到 markdown 异步转 html 的 api 导致无法集成,最后只能采用修改模板的方式. 而 {{ page.content|safe }} 表示的是当前页面的 html 内容,最后在原始内容外面嵌套一层 div 充当目标区域,其中 id=\"vip-container\". 插入集成代码 const btw = new BTWPlugin(); btw.init({ \"id\": \"vip-container\", \"blogId\": \"{{ config.pluginsConfig.openwrite.blogId }}\", \"name\": \"{{ config.pluginsConfig.openwrite.name }}\", \"qrcode\": \"{{ config.pluginsConfig.openwrite.qrcode }}\", \"keyword\": \"{{ config.pluginsConfig.openwrite.keyword }}\" }); {{ config.pluginsConfig.openwrite.blogId }} 表示读取的是 gitbook 关于 openwrite 插件的配置信息,这样一来集成代码就会自动插入到每一个页面中,从而省去了手动插入的麻烦,达到了自动化集成的目的. 上一步构建目标区域时设置了 id=\"vip-container\" ,在这一步直接使用了该区域唯一标示,所以该配置项不必暴露给外部用户,因此配置项中没有 id . 使用者集成参考 关于插件原理部分的相关介绍,如果不懂的话也没有关系,直接上手能够用就好,下面提供非常基础的示例: { \"title\": \"雪之梦技术驿站\", \"author\": \"snowdreams1006\", \"description\": \"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.3\", \"plugins\": [ \"openwrite\" ], \"pluginsConfig\": { \"openwrite\":{ \"blogId\": \"15702-1569305559839-744\", \"name\": \"雪之梦技术驿站\", \"qrcode\": \"https://snowdreams1006.github.io/snowdreams1006-wechat-public.jpeg\", \"keyword\": \"vip\" } } } book.json 配置文件中的其他项可能省略了,这里只保留关于插件部分相关代码,完整示例参考: https://github.com/snowdreams1006/gitbook-plugin-openwrite/tree/master/example 虽然本教程基于 gitbook 提供的插件机制进行集成 ReadMore 工具,但基本思路也适合其他平台: 最方便的做法是基于模板固定目标区域,然后配置相应的 Js 集成代码. 当然,直接集成是非常简单的,如果是基于插件等集成形式以提供给更多人使用的话,那可能就要研究一下博客平台的接口文档了. 懒人直达 声明并配置 openwrite 插件 { \"plugins\": [ \"openwrite\" ], \"pluginsConfig\": { \"openwrite\":{ \"blogId\": \"your blogId\", \"name\": \"your name\", \"qrcode\": \"your qrcode\", \"keyword\": \"your keyword\" } } } 注意修改成自己的配置信息,来源于 OpenWrite 后台,点击使用后第二步关于博客设置! 安装 openwrite 插件到本地 $ gitbook install 运行本地服务 $ gitbook serve 如果本地运行发现没有问题的话,恭喜你成功集成了公众号引流功能,稍后运行 gitbook build 命令后就可以上传静态网站到目标服务器了呢! 总结寄语 总体来说,OpenWrite 作为一文多发平台是非常优秀的,对于多平台发布的小伙伴来说简直就是福音,但是假如你并没有一文多发的需求,那可能对你的帮助并不是很大,因为连复制粘贴都不需要了啊! 但是,作为一个有追求的技术分享者,个人博客用户转换成微信公众号粉丝这一需求应该说更加普遍,再次感谢 OpenWrite 提供的 ReadMore 工具,原以为只有动态博客才能玩的套路没想到也可以用到静态博客身上! 最后考虑到基于 Gitbook 搭建的静态博客市面上并不少,其他小伙伴可能也有类似需求,所以做成了 gitbook 插件共享给大家,gitbook-plugin-openwrite 希望对大家有所帮助! 项目地址: https://github.com/snowdreams1006/gitbook-plugin-openwrite 演示地址: https://github.com/snowdreams1006/gitbook-plugin-openwrite/tree/master/example 参考链接 https://openwrite.cn/ 还在搞公众号互推涨粉？OpenWrite推出增长神器，助你实现粉丝躺增！ WordPress 博客整合导流工具，博客导流到微信公众号 谈一谈博客的关注解锁文章功能 牛掰！我是这么把博客粉丝转到公众号的 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/openwrite/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/issue/":{"url":"myGitbook/issue/","title":"常见问题","keywords":"","body":"常见问题 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/issue/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/issue/rm-output-directory.html":{"url":"myGitbook/issue/rm-output-directory.html","title":"热加载失败治标之法","keywords":"","body":"热加载失败治标之法 破镜如何贴花黄 gitbook 在 Windows 系统无法热加载,总是报错! gitbook 是一款文档编写利器,可以方便地 markdown 输出成美观优雅的 html ,gitbook serve 启动服务器后,原来相貌平平的 markdown 丑小鸭摇身一变就成了倾国倾城的 html 绝色佳人. 如果源文件发生更改,Windows 却无法按照预期那样重启服务器,直接抛出一个异常,立即终止了 markdown 的化妆. Restart after change in file README.md Stopping server events.js:183 throw er; // Unhandled 'error' event ^ Error: EPERM: operation not permitted, lstat 'F:\\workspace\\private-cloud-backup\\gitbook-test\\_book' 对镜贴花黄 现在看一下 markdown 灰姑娘变身 html 小姐姐的神奇过程吧! $ gitbook serve --log=debug Live reload server started on port: 35729 Press CTRL+C to quit ... debug: readme found at README.md debug: summary file found at SUMMARY.md debug: cleanup folder \"G:\\sublime\\gitbook-test\\_book\" info: 7 plugins are installed info: loading plugin \"livereload\"... OK ... info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files debug: calling hook \"config\" debug: calling hook \"init\" debug: copy assets from theme C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-theme-default\\_assets\\website ... debug: copy resources from plugin C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-livereload\\book debug: generate page \"README.md\" debug: calling hook \"page:before\" debug: calling hook \"page\" debug: index page README.md debug: calling hook \"finish:before\" debug: calling hook \"finish\" debug: write search index info: >> generation finished with success in 1.5s ! Starting server ... Serving book on http://localhost:4000 根据上述输出日志,我们可以分析出 gitbook 的基本运行流程. 加载 readme 和 summary 文件,若存在 glossary 文件也会加载,并删除 _book 目录 debug: readme found at README.md debug: summary file found at SUMMARY.md debug: cleanup folder \"G:\\sublime\\gitbook-test\\_book\" 加载依赖插件,若没有找到相应插件会报错,提示运行 gitbook install 安装插件. info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK 扫描页面和静态资源文件 info: found 1 pages info: found 0 asset files 读取配置文件并初始化 debug: calling hook \"config\" debug: calling hook \"init\" 拷贝样式资源和插件资源 debug: copy assets from theme C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-theme-default\\_assets\\website debug: copy resources from plugin C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-fontsettings\\assets debug: copy resources from plugin C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-sharing\\assets debug: copy resources from plugin C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-lunr\\assets debug: copy resources from plugin C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-search\\assets debug: copy resources from plugin C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-highlight\\css debug: copy resources from plugin C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\gitbook-plugin-livereload\\book 开始生成单独页面,依次执行 page:before ,page 回调函数,全部页面执行完毕后执行 finish:before 和 finish 回调函数. debug: generate page \"README.md\" debug: calling hook \"page:before\" debug: calling hook \"page\" debug: index page README.md debug: calling hook \"finish:before\" debug: calling hook \"finish\" 生成搜索文件 debug: write search index 启动完毕,输出成功信息 Starting server ... Serving book on http://localhost:4000 默认情况下服务器启动后会占用两个端口,一个是对外暴露的 4000 端口,用于浏览器访问项目. 另外一个是 35729 端口,用于监听本地文件变化,重启服务器进而实现热加载功能. 本地服务器启动后我们就可以访问 http://localhost:4000 预览静态网站效果,markdown 源文件华丽演变成 html 富文本文件. 破镜怎化妆 不幸的是,Windows 热加载可能会有问题,也就是说如果启动服务器后,本地文件发生改变,此时会触发热加载功能而报错 Error: EPERM: operation not permitted ,这样一来浏览器又无法访问了. 刚刚变身的 markdown 瞬间又被打回原形,无法欣赏化妆后的容颜了,这样的体验相当不好! 边化妆边照镜子才是做到心中有谱,随时调整,如果不照镜子而直接化妆,那不是一般人能做到的. gitbook 启动本地服务器给我们提供了镜子,但热加载失败又把镜子摔碎了,还怎么愉快的化妆? Restart after change in file README.md Stopping server debug: readme found at README.md debug: summary file found at SUMMARY.md debug: cleanup folder \"G:\\sublime\\gitbook-test\\_book\" events.js:174 throw er; // Unhandled 'error' event ^ Error: EPERM: operation not permitted, lstat 'G:\\sublime\\gitbook-test\\_book' Emitted 'error' event at: at FSWatcher._handleError (C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\index.js:236:10) at ReaddirpReadable.emit (events.js:189:13) at Immediate. (C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\node_modules\\readdirp\\stream-api.js:82:32) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) at processImmediate (timers.js:658:5) 寻医问诊修破镜 现在问题已经复现,接下来就要开始寻医问诊,试图让破镜重圆,好让 markdown 灰姑娘变成人见人爱的 html 小姐姐. 根据报错信息描述,定位到删除 _book 目录再次创建该目录时,提示 EPERM: operation not permitted ,即无权操作. 柯南附体 既然说是操作权限的问题,那我们看一下 _book 目录现在是怎样状态吧! $ ls gitbook-errorforwindows-preview.png README.md SUMMARY.md 当前项目已经没有 _book 目录,证明发生报错时确实已经删除了 _book 目录,但是某种原因无权再次创建该文件夹而重启失败. 然而,这只是表现现象,老师告诉我们,要透过现象看本质,即使现在没有 _book 文件再次启动服务器还是会启动成功并创建 _book 文件的,所以真想只有一个! 那就是,gitbook 控制台在说谎! 虽然排除了 gitbook 无权创建 _book 目录的嫌疑,那又怎么解释重启服务器却没能创建 _book目录这件事呢? debug: cleanup folder \"G:\\sublime\\gitbook-test\\_book\" events.js:174 throw er; // Unhandled 'error' event ^ Error: EPERM: operation not permitted, lstat 'G:\\sublime\\gitbook-test\\_book' Emitted 'error' event at: at FSWatcher._handleError (C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\index.js:236:10) at ReaddirpReadable.emit (events.js:189:13) at Immediate. (C:\\Users\\snowdreams1006\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\node_modules\\readdirp\\stream-api.js:82:32) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) at processImmediate (timers.js:658:5) 先看一下 FSWatcher._handleError 异常信息: sed -n \"223,239p\" ~/.gitbook/versions/3.2.3/node_modules/chokidar/index.js . 分析发现: FSWatcher._handleError 是私有方法,作用是处理异常信息,和这起事故关联不大. Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master) $ sed -n \"223,239p\" ~/.gitbook/versions/3.2.3/node_modules/chokidar/index.js // Private method: Common handler for errors // // * error - object, Error instance // // Returns the error if defined, otherwise the value of the // FSWatcher instance's `closed` flag FSWatcher.prototype._handleError = function(error) { var code = error && error.code; var ipe = this.options.ignorePermissionErrors; if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!ipe || (code !== 'EPERM' && code !== 'EACCES')) ) this.emit('error', error); return error || this.closed; }; 我们接着往下找,再看一下 ReaddirpReadable.emit (events.js:189:13) ,这里没有给出文件的具体路径,所以暂时无法定位. 那我们再看下一个 Immediate. : sed -n \"78,96p\" ~/.gitbook/versions/3.2.3/node_modules/chokidar/node_modules/readdirp/stream-api.js Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master) $ sed -n \"78,96p\" ~/.gitbook/versions/3.2.3/node_modules/chokidar/node_modules/readdirp/stream-api.js proto._handleFatalError = function (err) { var self = this; setImmediate(function () { if (self._paused) return self._errors.push(err); if (!self._destroyed) self.emit('error', err); }); } function createStreamAPI () { var stream = new ReaddirpReadable(); return { stream : stream , processEntry : stream._processEntry.bind(stream) , done : stream._done.bind(stream) , handleError : stream._handleError.bind(stream) , handleFatalError : stream._handleFatalError.bind(stream) }; } 遗憾的是,仍然没有找到具体问题,那就继续看一下一条线索. timers.js:705:18 和 events.js:189:13 都没有显示具体的文件位置,如果也在 chokidar 模块的话就好了. Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master) $ tree -P \"events.js\" --prune ~/.gitbook/versions/3.2.3/ /c/Users/Administrator/.gitbook/versions/3.2.3/ └── node_modules ├── cheerio │ └── node_modules │ └── jsdom │ └── lib │ └── jsdom │ └── level2 │ └── events.js └── gitbook-plugin-theme-default └── src └── js └── core └── events.js 11 directories, 2 files Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master) $ tree -P \"timers.js\" --prune ~/.gitbook/versions/3.2.3/ /c/Users/Administrator/.gitbook/versions/3.2.3/ 0 directories, 0 files git-bash 命令行正常没有 tree 命令,如需扩展参考我另外一篇文章. 经过肉眼验证,发现 events.js 根本就没有 174 行文件,所以这两个文件大都不是目标文件. 既然命令行中无法找到目标文件,那就请专业的搜索工具全系统查找这两个文件吧,这里使用的是 Everything 搜索工具. 然并卵,依然没有找到目标文件. 毕竟不是柯南,没有发现真相 求助官方 gitbook 可是开源产品,出现问题的应该不止我一个,所以去 github 看看有没有遇到和我一样的问题. 虽然找到了志同道合的小伙伴,但是并没有提供解决方案,连官方都放弃了,那我还有什么可留恋的? 点击查看 gitbook serve livereload error 自己动手 最害怕的不是 bug,而是发现了 bug 却无法定位,虽然控制台有报错信息但是没有找到真正的文件! 首先确认下当前系统版本,然后采取版本切换方式测试其他版本是否存在该问题. $ gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 升级到最新版 gitbook ls 是列出当前已安装的版本,而 gitbook ls-remote 则是列出远程服务器版本. # 列出本地已安装版本 $ gitbook ls GitBook Versions Installed: * 3.2.3 Run \"gitbook update\" to update to the latest version. # 列出远程可用版本 $ gitbook ls-remote Available GitBook Versions: 4.0.0-alpha.6, 4.0.0-alpha.5, 4.0.0-alpha.4, 4.0.0-alpha.3, 4.0.0-alpha.2, 4.0.0-alpha.1, 3.2.3, 3.2.2, 3.2.1, 3.2.0, 3.2.0-pre.1, 3.2.0-pre.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-pre.15, 3.0.0-pre.14, 3.0.0-pre.13, 3.0.0-pre.12, 3.0.0-pre.11, 3.0.0-pre.10, 3.0.0-pre.9, 3.0.0-pre.8, 3.0.0-pre.7, 3.0.0-pre.6, 3.0.0-pre.5, 3.0.0-pre.4, 3.0.0-pre.3, 3.0.0-pre.2, 3.0.0-pre.1, 2.6.9, 2.6.8, 2.6.7, 2.6.6, 2.6.5, 2.6.4, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.2, 2.5.1, 2.5.0, 2.5.0-beta.7, 2.5.0-beta.6, 2.5.0-beta.5, 2.5.0-beta.4, 2.5.0-beta.3, 2.5.0-beta.2, 2.5.0-beta.1, 2.4.3, 2.4.2, 2.4.1, 2.4.0, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-beta.5, 2.0.0-beta.4, 2.0.0-beta.3, 2.0.0-beta.2, 2.0.0-beta.1, 2.0.0-alpha.9, 2.0.0-alpha.8, 2.0.0-alpha.7, 2.0.0-alpha.6, 2.0.0-alpha.5, 2.0.0-alpha.4, 2.0.0-alpha.3, 2.0.0-alpha.2, 2.0.0-alpha.1 Tags: latest : 2.6.9 pre : 4.0.0-alpha.6 目前最新发布版本是 3.2.3 ,而我们本地已安装的版本正是该版本,所以现在应该测试 4.0.0-alpha.6 版. 看到 4.0.0-alpha.6 心里有些忐忑,根据版本管理约定,版本号一般有三部分组成,第一部分代表不兼容的重大升级,第二部分代表主干兼容的功能升级,第三部分是小版本修复. 由 3.2.3 直接跨度到 4.0.0-alpha.6 意味着 gitbook 发生了重大重构! 算了,先下载试试看! gitbook fetch 下载 和 gitbook update升级,两种方式都可以体验最新版本,这里选择下载方式方便进行不同版本的切换. # 下载 `4.0.0-alpha.6` 版本 $ gitbook fetch 4.0.0-alpha.6 Installing GitBook 4.0.0-alpha.6 gitbook@4.0.0-alpha.6 C:\\Users\\SNOWDR~1\\AppData\\Local\\Temp\\tmp-8912hSrxNvTCrFEH\\node_modules\\gitbook ├── escape-html@1.0.3 ├── escape-string-regexp@1.0.5 ├── destroy@1.0.4 ├── ignore@3.1.2 └── ied@2.3.6 (lodash.memoize@4.1.2, lodash.frompairs@4.0.1, force-symlink@0.0.2, semver@5.7.0, minimist@1.2.0, node-uuid@1.4.8, npm-package-arg@4.2.1, source-map-support@0.4.18, ora@0.2.3, easy-table@1.1.1, rimraf@2.6.3, tar-fs@1.16.3, gunzip-maybe@1.4.1, init-package-json@1.10.3, rxjs@5.0.0-rc.1, needle@1.0.0, node-pre-gyp@0.6.39, node-gyp@3.8.0) GitBook 4.0.0-alpha.6 has been installed 先看一下本地安装 gitbook 版本,确保待会运行时使用最新的 4.0.0-alpha.6 版本. # 列出本地已安装版本 $ gitbook ls GitBook Versions Installed: * 4.0.0-alpha.6 3.2.3 Run \"gitbook update\" to update to the latest version. # 列出当前正在使用版本 $ gitbook current GitBook version is 3.2.3 gitbook serve --gitbook=4.0.0-alpha.6 --log=debug 运行 4.0.0-alpha.6 版本并打印 debug 级别日志. 意外的是,竟然没有连启动都没启动成功,提示无法打开 ~\\.gitbook\\versions\\4.0.0-alpha.6\\node_modules\\gitbook-plugin-livereload\\_assets\\plugin.js 文件. 回想到版本号规范,可能 v3 到 v4 更改比较大,版本不兼容吧,重新初始化项目试试看! # 初始化项目并指定 `gitbook` 运行版本 $ gitbook init --gitbook=4.0.0-alpha.6 Warning: Accessing PropTypes via the main React package is deprecated, and will be removed in React v16.0. Use the latest available v15.* prop-types package from npm instead. For info on usage, compatibility, migration and more, see https://fb.me/prop-types-docs info: create SUMMARY.md info: initialization is finished 然而,仍然还是同样的报错,依旧无法启动. $ gitbook serve --gitbook=4.0.0-alpha.6 --log=debug Warning: Accessing PropTypes via the main React package is deprecated, and will be removed in React v16.0. Use the latest available v15.* prop-types package from npm instead. For info on usage, compatibility, migration and more, see https://fb.me/prop-types-docs Live reload server started on port: 35729 Press CTRL+C to quit ... ... Error: ENOENT: no such file or directory, open 'C:\\Users\\snowdreams1006\\.gitbook\\versions\\4.0.0-alpha.6\\node_modules\\gitbook-plugin-livereload\\_assets\\plugin.js' 此路不通,再换一条,既然向上无法处理,那向下回退会不会有结果呢? 回退版本 当前系统版本是 3.2.3,最新测试版本是 4.0.0-alpha.6 ,然而最近一次提交的版本却是 2.6.9 ? 为什么 gitbook-ci 管理的 gitbook 版本号会突然跳水,会不会有什么猫腻,难不成修复了什么 bug ? $ gitbook ls-remote Available GitBook Versions: 4.0.0-alpha.6, 4.0.0-alpha.5, 4.0.0-alpha.4, 4.0.0-alpha.3, 4.0.0-alpha.2, 4.0.0-alpha.1, 3.2.3, 3.2.2, 3.2.1, 3.2.0, 3.2.0-pre.1, 3.2.0-pre.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-pre.15, 3.0.0-pre.14, 3.0.0-pre.13, 3.0.0-pre.12, 3.0.0-pre.11, 3.0.0-pre.10, 3.0.0-pre.9, 3.0.0-pre.8, 3.0.0-pre.7, 3.0.0-pre.6, 3.0.0-pre.5, 3.0.0-pre.4, 3.0.0-pre.3, 3.0.0-pre.2, 3.0.0-pre.1, 2.6.9, 2.6.8, 2.6.7, 2.6.6, 2.6.5, 2.6.4, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.2, 2.5.1, 2.5.0, 2.5.0-beta.7, 2.5.0-beta.6, 2.5.0-beta.5, 2.5.0-beta.4, 2.5.0-beta.3, 2.5.0-beta.2, 2.5.0-beta.1, 2.4.3, 2.4.2, 2.4.1, 2.4.0, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-beta.5, 2.0.0-beta.4, 2.0.0-beta.3, 2.0.0-beta.2, 2.0.0-beta.1, 2.0.0-alpha.9, 2.0.0-alpha.8, 2.0.0-alpha.7, 2.0.0-alpha.6, 2.0.0-alpha.5, 2.0.0-alpha.4, 2.0.0-alpha.3, 2.0.0-alpha.2, 2.0.0-alpha.1 Tags: latest : 2.6.9 pre : 4.0.0-alpha.6 带着这些疑问,不妨下载 2.6.9 版本试试,看一下能否热加载? gitbook serve --log=debug --gitbook=2.6.9 指定 gitbook 版本,依旧失败! $ gitbook serve --log=debug --gitbook=2.6.9 Error loading version latest: Error: Cannot find module 'q' at Function.Module._resolveFilename (internal/modules/cjs/loader.js:582:15) at Function.Module._load (internal/modules/cjs/loader.js:508:25) at Module.require (internal/modules/cjs/loader.js:637:17) at require (internal/modules/cjs/helpers.js:22:18) at Object. (C:\\Users\\myHome\\.gitbook\\versions\\2.6.9\\lib\\index.js:3:9) at Module._compile (internal/modules/cjs/loader.js:701:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10) at Module.load (internal/modules/cjs/loader.js:600:32) at tryModuleLoad (internal/modules/cjs/loader.js:539:12) at Function.Module._load (internal/modules/cjs/loader.js:531:3) TypeError: Cannot read property 'commands' of null 重回现场 现在把目光再次聚焦到最初的案发现场,这一次只能背水一战了,自己动手要么丰衣足食要么饿死冻死! Stopping server debug: readme found at README.md debug: summary file found at SUMMARY.md debug: cleanup folder \"G:\\sublime\\private-cloud-backup\\gitbook-test\\_book\" events.js:174 throw er; // Unhandled 'error' event ^ Error: EPERM: operation not permitted, lstat 'G:\\sublime\\private-cloud-backup\\gitbook-test\\_book' Emitted 'error' event at: at FSWatcher._handleError (C:\\Users\\myHome\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\index.js:236:10) at ReaddirpReadable.emit (events.js:189:13) at Immediate. (C:\\Users\\myHome\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\node_modules\\readdirp\\stream-api.js:82:32) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) at processImmediate (timers.js:658:5) 关于上述错误描述中,在真相只有一个章节中已经探讨过,当时得出的结论是 gitbook 是删除 _book 文件夹再新建 _book 文件夹时发生了意外. 如果这个行为不是由 gitbook 发生而是由我们手动干预的话,也就是说,当成功启动本地服务器后并在即将发生热加载之前,此时人为删除 _book 文件夹,会发生什么? 我的猜想是: 因为 gitbook 的热加载机制是监听本地文件目录系统发生改变,进而停止服务器再重新启动服务器. 当我们手动删除了 _book 文件夹,对于 gitbook 来说,再触发重启服务器的那一刻来说,突然发现没有 _book 文件夹,此时就不会删除也不会新建时发生异常,相当于直接新建 _book 文件夹,变相把热加载弄成了初始启动模式! 希望苍天不负我,如若不行,只能看源码逻辑找 bug 了! 你猜猜会怎么样? it works ! 在实验中,gitbook serve --log=debug 启动本地服务器后,如果本地文件发生修改会重启失败! 但是,如果在启动本地服务器后立即删除 _book 目录,当本地文件发生修改时重启服务就能成功了. 到此为止,总算找到一个解决方案,那就是启动服务后立即删除 _book 目录. 不算完美的总结 windows 系统上启动 gitbook 服务后,如果本地文件发生更改,热加会失败. 如果启动服务器后立即删除 _book 目录,那么之后再怎么修改本地文件都能顺利重启. 目前还没有找到问题的根源,下一次将深入源码继续探讨到底是哪里出问题导致 Windows 系统无法重启. 虽然及时删除 _book 目录并不算是很好的解决方案,但至少 markdown 灰姑娘又能化妆成 html 小姐姐了呢! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/issue/rm-output-directory.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"myGitbook/issue/modify-default-fold.html":{"url":"myGitbook/issue/modify-default-fold.html","title":"初始化默认折叠效果","keywords":"","body":"初始化默认折叠效果 Gitbook 是一款产品文档构建工具,也可以用于构建个人博客,默认情况下电脑端访问时左侧菜单是展开状态,可偏偏有人想要实现默认折叠效果,于是诞生了这篇文章! 善良的我选择帮助别人 可能是网上关于 Gitbook 的教程相对来说有些落后,加上写文章时分享了不少关于 gitbook 系列教程,因此关注我的粉丝好友中有不少是来源于 Gitbook. 所以上个月有个好友问我能不能配置 Gitbook 默认折叠的效果,心里有些犯难,作为 gitbook 的忠实粉丝,我都不知道 gitbook 还有这方面的配置?! 但是,善良的我总是有求必应,不忍心拒绝小白用户,于是我便抱着试一试的心态开始研究一下如何默认折叠? 当然,解决问题前还是要先复现一下问题,然后在命令行中熟练敲入了 gitbook serve 命令来启动本地服务器,为了排除缓存等影响,特意打开了 Chrome 浏览器的无痕模式,果不其然默认左侧菜单是展开的! 「雪之梦技术驿站」: 不能复现的问题都不是我的问题,拒绝解决此类问题,搞不好是你自己环境搭建问题呢! 蓦然回首官方文档已走 问题复现后就要开始寻求解决之道,虽然印象中并没有相关配置,但是难保记忆混乱遗漏了某些配置项,所以还是先看看官方文档怎么说的吧! 但是,当你在浏览器中输入 gitbook 官方文档 时,并找不到想象中的官方文档而是新版官网,不信你自己去搜一下,肯定是新版官网. 当你自以为找到了官网时,点击进去查看文档部分,很遗憾,这是新版文档并不是老版文档,你还会继续百度一下寻求可用链接期待找到官方文档. 为了节省宝贵时间,这里推荐访问个人维护的 gitbook 文档,点击访问: gitbook 原版文档 目前提供了中英文两个语言版本的文档,相信可以满足大多数用户的需求了,选择任意一种语言后点击进入翻阅相关设置. 实际上,官方文档也并没有什么用,因为根本就没有提到过如何更改相关配置使其默认折叠而非展开状态. 「雪之梦技术驿站」: 官方不再维护旧版文档,费尽心机找到旧版文档也无济于事,因为并没有提及到相关配置,所以猜测很可能并未提供有关配置项! 百度一下你就知道了吗 俗话说:\"互联网上绝大多数问题别人都已经遇到过并提供了解决方案,我们唯一要做的就是找到它!\" 这也是面向搜索编程的核心思想,遇到默认折叠问题应该也不会例外,那就搜索一下吧! 虽然百度搜索出现了一些相关文章,但是却不是我们想要的效果,大多数是基于 gitbook 插件实现的目录折叠效果,并不是默认折叠左侧菜单效果. 不管是换关键词重新搜索还是谷歌搜索,均未发现有关默认折叠左侧菜单的解决方案,难不成面向搜索失败了,要做解决问题的第一人吗?! 「雪之梦技术驿站」: 多次重复搜索操作均为找到解决方案,由此可见真的很少有人想要默认折叠左侧菜单,我也是很佩服提出该问题的小伙伴骨骼惊奇啊! 自力更生找寻蛛丝马迹 既然依靠别人无法解决问题,那么只能自力更生独自解决问题,是时候考验真正的技术了! 为了排除无关干扰,不能再用自己的 gitbook 项目了,毕竟文件太多不方便后续调试,那么不妨重新创建一个测试项目. 创建测试项目 $ mkdir test && cd test 初始化测试项目 $ gitbook init 启动测试项目 $ gitbook serve 虽然一片空白,并没有什么实质性内容,但是大道至简,对于我们复现并测试问题来说,足够了! 打开 Chrome 浏览器并按下 F12 开启调试模式,鼠标选中左侧的 Elements 元素选项卡并点亮左侧的小鼠标,然后在页面上找到左侧图标按钮,于是选中元素高亮了. 单独摘录 Html 关键代码如下: 稍微熟悉前端的小伙伴可能很轻松就能明白 a 标签的 class 属性表示的含义,见名知意,可以这么解释: btn 应该是控制外观的样式,表现得像是按钮效果. pull-left 应该是控制元素的位置,拉倒左边. js-toolbar-action 应该是控制元素的行为,js 工具栏行为动作. 由此可见,点击该图标实现左侧菜单折叠/展开效果应该是 .js-toolbar-action 在起作用,也就是说某一段 js 肯定是针对该 class 进行了监听! 此时,点击右侧的 Event Listeners 选项卡查看该元素已监听的 click 事件,定位到是哪一个具体的 js 文件在起作用. 果不其然,元素上存在 click 点击事件监听并且发现执行监听的逻辑代码出现在 theme.js 文件,点击进入文件查看具体内容. 压缩后的 js 代码不具备可读性,点击左下方的 {} 图标可以进行代码格式化,但是可能不是单纯的压缩而是进行了丑化或者混淆代码之类的逻辑,格式化后的代码仍然不可读! 「雪之梦技术驿站」: 终于发现了蛛丝马迹,修改的代码逻辑就隐藏在 theme.js 文件中,只要找到相关源码重新编译输出 theme.js 文件并替换应该就能实现默认折叠效果! 不要担心黎明前的黑暗 根据目前已掌握的线索,可以肯定的是有用线索主要有两个: 监听元素 .js-toolbar-action 输出文件 theme.js 一个是源码文件,另一个是输出文件,想要在庞大的 gitbook 项目中迅速定位到相关代码逻辑,个人能力有限,并不熟悉前端开发调试流程,因此采用最简单粗暴傻瓜式搜索方式进行排查! 「雪之梦技术驿站」: 如果读者对于现代前端开发流程比较属性的话,大概过一遍项目结构应该就可以调试定位问题了,用不着像我这样傻瓜式搜索排查! 查看当前 gitbook 版本 $ gitbook current GitBook version is 3.2.3 找到 gitbook 安装位置 gitbook 一般安装在 ~/.gitbook/versions/3.2.3 目录,其中 ~ 表示用户家目录. $ open ~/.gitbook/versions/3.2.3 选择一款熟悉的编辑器并打开 Gitbook 安装目录,这里以 sublime 编辑器为例,选中项目后右键全局搜索关键字 js-toolbar-action 期望找到相关源码文件. 全局搜索后主要出现两个文件包含 js-toolbar-action 关键字,一个是输出文件 theme.js ,另一个是源码文件 toolbar.js . Searching 19744 files for \"js-toolbar-action\" /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/_assets/website/theme.js: ... /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/js/theme/toolbar.js: ... 4 matches across 2 files 可想而知,源码文件肯定是经过编译处理后统一打包输出,因此不仅仅要找到源码文件还要掌握如何编译. 「雪之梦技术驿站」: 定位到当前 gitbook 目录后借助全局搜索功能定位到具体的文件路径,起作用的是 gitbook-plugin-theme-default 项目,其实这就是 Gitbook 的默认主题. 源码在哪 /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/js/theme/toolbar.js : // Update a button function updateButton(opts) { var $result; var $toolbar = $('.book-header'); var $title = $toolbar.find('h1'); // Build class name var positionClass = 'pull-'+opts.position; // Create button var $btn = $('', { 'class': 'btn', 'text': opts.text? ' ' + opts.text : '', 'aria-label': opts.label, 'href': '#' }); // Bind click $btn.click(opts.onClick); // Prepend icon if (opts.icon) { $('', { 'class': opts.icon }).prependTo($btn); } // Prepare dropdown if (opts.dropdown) { var $container = $('', { 'class': 'dropdown '+positionClass+' '+opts.className }); // Add button to container $btn.addClass('toggle-dropdown'); $container.append($btn); // Create inner menu var $menu = createDropdownMenu(opts.dropdown); // Menu position $menu.addClass('dropdown-'+(opts.position == 'right'? 'left' : 'right')); $container.append($menu); $result = $container; } else { $btn.addClass(positionClass); $btn.addClass(opts.className); $result = $btn; } $result.addClass('js-toolbar-action'); if ($.isNumeric(opts.index) && opts.index >= 0) { insertAt($toolbar, '.btn, .dropdown, h1', opts.index, $result); } else { $result.insertBefore($title); } } // Update all buttons function updateAllButtons() { $('.js-toolbar-action').remove(); buttons.forEach(updateButton); } 粗略看一下,上述代码是实现触发左侧图标折叠/展开菜单的逻辑实现,这里只是具体实现还不知道谁是使用者,也就是说这种逻辑是在哪里调用的? 只能继续顺藤摸瓜,往上翻看,根据基本开发常识,在该文件的同级目录中存在如下文件,其中的 index.js 应该就是入口文件: snowdreams1006s-MacBook-Pro:theme snowdreams1006$ tree . . ├── dropdown.js ├── index.js ├── keyboard.js ├── loading.js ├── navigation.js ├── platform.js ├── sidebar.js └── toolbar.js 0 directories, 8 files snowdreams1006s-MacBook-Pro:theme snowdreams1006$ ` 打开 index.js 文件,根据注释我们可以看到 init() 函数是入门函数,其中 sidebar.init() 和 sidebar.toggle() 函数无不说明 sidebar.js 和 toolbar.js 关系密切,完全有理由猜想 sidebar.js 是 toolbar.js 的使用者! function init() { // Init sidebar sidebar.init(); // Init keyboard keyboard.init(); // Bind dropdown dropdown.init(); // Init navigation navigation.init(); // Add action to toggle sidebar toolbar.createButton({ index: 0, icon: 'fa fa-align-justify', onClick: function(e) { e.preventDefault(); sidebar.toggle(); } }); } 打开 sidebar.js 文件并查看 init() 初始化函数和 toggle() 触发函数,可以验证我们的猜想,这里就是控制中心! // Prepare sidebar: state and toggle button function init() { // Init last state if not mobile if (!platform.isMobile()) { toggleSidebar(gitbook.storage.get('sidebar', true), false); } // Close sidebar after clicking a link on mobile $(document).on('click', '.book-summary li.chapter a', function(e) { if (platform.isMobile()) toggleSidebar(false, false); }); } 「雪之梦技术驿站」: 非手机端初始化上次状态,默认展开侧边栏,如果是手机端则折叠侧边栏.其中 toggleSidebar() 接收两个参数,第一次参数表示是展开还是折叠,第二个参数暂不可知. // Toggle sidebar with or withour animation function toggleSidebar(_state, animation) { if (gitbook.state != null && isOpen() == _state) return; if (animation == null) animation = true; gitbook.state.$book.toggleClass('without-animation', !animation); gitbook.state.$book.toggleClass('with-summary', _state); gitbook.storage.set('sidebar', isOpen()); } 「雪之梦技术驿站」: 第一个参数确实表示状态而第二个参数表示是否有动画效果,不用看具体代码逻辑而是看注释就能猜出大概逻辑了. 通过上述分析,我们可以得知 init() 初始化函数决定了默认行为是折叠还是展开,同时 gitbook.storage.set('sidebar', isOpen()) 和 gitbook.storage.get('sidebar', true) 应该是设置和获取是否展开菜单的标志! 由此,如果想要默认折叠左侧菜单,那么只需要设置成 gitbook.storage.set('sidebar', false) 应该就会生效! 如何编译 说干就干,于是乎在 init() 函数插入 gitbook.storage.set('sidebar', false) 默认折叠逻辑,接着看一下是否需要重新编译才能生效? // Prepare sidebar: state and toggle button function init() { // Close sidebar as default state gitbook.storage.set('sidebar', false); // Init last state if not mobile if (!platform.isMobile()) { toggleSidebar(gitbook.storage.get('sidebar', true), false); } // Close sidebar after clicking a link on mobile $(document).on('click', '.book-summary li.chapter a', function(e) { if (platform.isMobile()) toggleSidebar(false, false); }); } 接着切换到测试项目再次运行 gitbook serve 启动本地服务器,发现并没有任何变化,很有可能改变源码文件需要重新编译才会生效或者说更改的源码项目也没有生效? 「雪之梦技术驿站」: 该源码文件所在的项目是 gitbook-plugin-theme-default ,根据 gitbook 插件命名规范我们知道,gitbook-plugin-* 一般是功能性插件,这一类的插件有 gitbook-plugin-readmore 阅读更多插件和 gitbook-plugin-copyright 版权保护插件等等. 但是如果插件名以 gitbook-plugin-theme 开头的话,这一类插件就是主题插件,比如 gitbook-plugin-theme-default 就是默认主题. 除此之外,只要遵守该命名规则的插件引入时无需添加 gitbook-plugin- 前缀,可以直接在 gitbook.json 文件中引入剩余的简称作为插件名. 摘录自 Gitbook 项目的配置文件,可以佐证上述规则的正确性. \"plugins\": [ \"toc\", \"pageview-count\", \"mermaid-gb3\", \"-lunr\", \"-search\", \"search-plus\", \"splitter\", \"-sharing\", \"sharing-plus\", \"expandable-chapters-small\", \"anchor-navigation-ex\", \"edit-link\", \"copy-code-button\", \"chart\", \"favicon-custom\", \"github-buttons\", \"advanced-emoji\", \"rss\", \"readmore\", \"copyright\", \"tbfed-pagefooter\", \"mygitalk\", \"donate\" ] 作为普通的 nodejs 包,开发规范规定了 package.json 提供了插件的配置信息,而 Gitbook 插件除了是标准的 nodejs 包之外还有自己的约束,主要体现在提供了 gitbook 节点属性: \"gitbook\": { \"properties\": { \"styles\": { \"type\": \"object\", \"title\": \"Custom Stylesheets\", \"properties\": { \"website\": { \"title\": \"Stylesheet for website output\", \"default\": \"styles/website.css\" }, \"pdf\": { \"title\": \"Stylesheet for PDF output\", \"default\": \"styles/pdf.css\" }, \"epub\": { \"title\": \"Stylesheet for ePub output\", \"default\": \"styles/epub.css\" }, \"mobi\": { \"title\": \"Stylesheet for Mobi output\", \"default\": \"styles/mobi.css\" }, \"ebook\": { \"title\": \"Stylesheet for ebook outputs (PDF, ePub, Mobi)\", \"default\": \"styles/ebook.css\" }, \"print\": { \"title\": \"Stylesheet to replace default ebook css\", \"default\": \"styles/print.css\" } } }, \"showLevel\": { \"type\": \"boolean\", \"title\": \"Show level indicator in TOC\", \"default\": false } } } 默认主题仅仅提供了两个配置项,分别是 styles 样式文件位置和 showLevel 是否显示层级配置. 再一次验证了猜想的正确性,真的需要修改源码才能实现默认折叠左侧菜单的效果,紧着继续在 package.json 中找到项目源码的托管地址,看一下有没有提供二次开发文档. \"repository\": { \"type\": \"git\", \"url\": \"git+https://github.com/GitbookIO/theme-default.git\" } 令人遗憾的是,项目介绍空空如也,除了一张主题预览图,别的什么都没有?! 既然没有二次开发文档,那就看看项目源码有没有别的蛛丝马迹教我们如何编译? 「雪之梦技术驿站」: 绕了这么多,其实还不是因为比较菜,人家都提供给源码都不会编译,留下来没有技术的眼泪! 视角再一次切换到源码目录,除了 js 和 less 目录外,竟然还有一个 build.sh 构建脚本! snowdreams1006s-MacBook-Pro:src snowdreams1006$ tree . ├── build.sh ├── js │ ├── core │ └── theme │ ├── dropdown.js │ ├── index.js │ ├── keyboard.js │ ├── loading.js │ ├── navigation.js │ ├── platform.js │ ├── sidebar.js │ └── toolbar.js └── less 7 directories, 37 files snowdreams1006s-MacBook-Pro:src snowdreams1006$ 这一刻,仿佛看到了九点钟升起的太阳,未来是你们的也是我们的! snowdreams1006s-MacBook-Pro:gitbook-plugin-theme-default snowdreams1006$ cat src/build.sh #! /bin/bash # Cleanup folder rm -rf _assets # Recreate folder mkdir -p _assets/website/ mkdir -p _assets/ebook/ # Compile JS browserify src/js/core/index.js | uglifyjs -mc > _assets/website/gitbook.js browserify src/js/theme/index.js | uglifyjs -mc > _assets/website/theme.js # Compile Website CSS lessc -clean-css src/less/website.less _assets/website/style.css # Compile eBook CSS lessc -clean-css src/less/ebook.less _assets/ebook/ebook.css lessc -clean-css src/less/pdf.less _assets/ebook/pdf.css lessc -clean-css src/less/mobi.less _assets/ebook/mobi.css lessc -clean-css src/less/epub.less _assets/ebook/epub.css # Copy fonts mkdir -p _assets/website/fonts cp -R node_modules/font-awesome/fonts/ _assets/website/fonts/fontawesome/ # Copy icons mkdir -p _assets/website/images cp node_modules/gitbook-logos/output/favicon.ico _assets/website/images/ cp node_modules/gitbook-logos/output/apple-touch-icon-152.png _assets/website/images/apple-touch-icon-precomposed-152.png snowdreams1006s-MacBook-Pro:gitbook-plugin-theme-default snowdreams1006$ 这一段脚本中除了看不懂 browserify,uglifyjs,lessc -clean-css 命令外,剩下部分都很简单,大致是编译源码文件并输出到 _assets 目录. 编译 js 的命令主要有以下两条,而我们关心的 theme.js 仅涉及到一条,除此之外没有任何别的依赖,这一点非常好! # Compile JS browserify src/js/core/index.js | uglifyjs -mc > _assets/website/gitbook.js browserify src/js/theme/index.js | uglifyjs -mc > _assets/website/theme.js 接下来的重点就是如何运行 browserify src/js/theme/index.js | uglifyjs -mc > _assets/website/theme.js 命令了! 摇身一变重新编译源码 browserify src/js/theme/index.js | uglifyjs -mc > _assets/website/theme.js 百度一下 browserify 再一次打开熟悉的浏览器输入关键字 browserify 后出现一系列相关文章,很好奇为啥排名第一个都不会是官网呢?不管怎么样,找到 browserify 的 github 项目地址也是不错的! 这里并不关心 browserify 到底是什么,只在乎如何安装基本环境而已! $ npm install -g browserify 「雪之梦技术驿站」: 如果是 mac 电脑,全局安装需要管理员权限,应该运行 sudo npm install -g browserify ,如果嫌弃安装速度慢也可以运行 cnpm install -g browserify ,前提是已安装 cnpm 命令. 谷歌一下 uglifyjs 不吹不黑,少走一点弯路,直接就找到了 github 项目网址,同样的也不关心项目介绍,直接翻看如何安装部分. $ npm install -g uglify-js 重新编译 others 涉及到 browserify src/js/theme/index.js | uglifyjs -mc > _assets/website/theme.js 命令的两个插件均已安装完毕,理所应当开始重新编译源码了,但是竟然报错了? 当出现报错时,开始怀疑人生,难道推论不正确,难道环境没有安装成功吗,为啥提示找不到 mousetrap 模块? $ browserify src/js/theme/index.js | uglifyjs -mc > _assets/website/theme.js Error: Cannot find module 'mousetrap' from '/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/js/theme' at /usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:46:17 at process (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:173:43) at ondir (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:188:17) at load (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:69:43) at onex (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:92:31) at /usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:22:47 at FSReqCallback.oncomplete (fs.js:158:21) 算了吧,与其费尽心思猜测为啥无法加载 mousetrap 模块,不如继续安装剩余依赖,最大可能性排除环境问题. 那就先把 src/build.sh 构建脚本涉及到的其他命令全部安装一遍,然后再试一下吧! 除了编译 Js 的命令外,还有编译 Css 的命令,关于构建脚本 build.sh 的其他内容就是基本的复制粘贴之类的操作了. # Compile Website CSS lessc -clean-css src/less/website.less _assets/website/style.css 这里省略面向搜索编程的中间过程,安装命令如下: $ npm install -g less less-plugin-clean-css 当我再一次运行构建脚本时,满心期待会编译成功,没想到现实再一次打脸,这时候错误更多了呢,真的是没想到! snowdreams1006s-MacBook-Pro:gitbook-plugin-theme-default snowdreams1006$ src/build.sh Error: Cannot find module 'jquery' from '/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/js/core' at /usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:46:17 at process (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:173:43) at ondir (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:188:17) at load (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:69:43) at onex (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:92:31) at /usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:22:47 at FSReqCallback.oncomplete (fs.js:158:21) Error: Cannot find module 'mousetrap' from '/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/js/theme' at /usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:46:17 at process (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:173:43) at ondir (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:188:17) at load (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:69:43) at onex (/usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:92:31) at /usr/local/lib/node_modules/browserify/node_modules/_resolve@1.1.7@resolve/lib/async.js:22:47 at FSReqCallback.oncomplete (fs.js:158:21) FileError: '../../node_modules/font-awesome/less/font-awesome.less' wasn't found. Tried - /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/node_modules/font-awesome/less/font-awesome.less,/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/node_modules/font-awesome/less/font-awesome.less,../../node_modules/font-awesome/less/font-awesome.less in /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/less/website.less on line 2, column 1: 1 @import \"base/all.less\"; 2 @import \"../../node_modules/font-awesome/less/font-awesome.less\"; 3 @import \"../../node_modules/preboot/less/preboot.less\"; FileError: '../../../node_modules/gitbook-markdown-css/less/mixin.less' wasn't found. Tried - /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/node_modules/gitbook-markdown-css/less/mixin.less,/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/node_modules/gitbook-markdown-css/less/mixin.less,../../../node_modules/gitbook-markdown-css/less/mixin.less in /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/less/base/mixins.less on line 1, column 1: 1 @import \"../../../node_modules/gitbook-markdown-css/less/mixin.less\"; 2 FileError: '../../../node_modules/gitbook-markdown-css/less/mixin.less' wasn't found. Tried - /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/node_modules/gitbook-markdown-css/less/mixin.less,/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/node_modules/gitbook-markdown-css/less/mixin.less,../../../node_modules/gitbook-markdown-css/less/mixin.less in /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/less/base/mixins.less on line 1, column 1: 1 @import \"../../../node_modules/gitbook-markdown-css/less/mixin.less\"; 2 FileError: '../../../node_modules/gitbook-markdown-css/less/mixin.less' wasn't found. Tried - /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/node_modules/gitbook-markdown-css/less/mixin.less,/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/node_modules/gitbook-markdown-css/less/mixin.less,../../../node_modules/gitbook-markdown-css/less/mixin.less in /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/less/base/mixins.less on line 1, column 1: 1 @import \"../../../node_modules/gitbook-markdown-css/less/mixin.less\"; 2 FileError: '../../../node_modules/gitbook-markdown-css/less/mixin.less' wasn't found. Tried - /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/node_modules/gitbook-markdown-css/less/mixin.less,/Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/node_modules/gitbook-markdown-css/less/mixin.less,../../../node_modules/gitbook-markdown-css/less/mixin.less in /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/src/less/base/mixins.less on line 1, column 1: 1 @import \"../../../node_modules/gitbook-markdown-css/less/mixin.less\"; 2 cp: directory _assets/website/fonts/fontawesome does not exist cp: node_modules/gitbook-logos/output/favicon.ico: No such file or directory cp: node_modules/gitbook-logos/output/apple-touch-icon-152.png: No such file or directory 那就继续扩大安装环境范围,这时候对整个 gitbook-plugin-theme-default 进行 npm install 安装相关依赖,这一次会发生什么情况呢? $ npm install 让我们拭目以待! snowdreams1006s-MacBook-Pro:gitbook-plugin-theme-default snowdreams1006$ src/build.sh snowdreams1006s-MacBook-Pro:gitbook-plugin-theme-default snowdreams1006$ 命令行没有了乱七八糟的输出,世界变得安静了! linux 命令行哲学告诉我们,没有消息就是好消息,全部安装项目环境后再次运行 src/build.sh 脚本命令行瞬间安静了! 怀着忐忑不安的心,切换到测试项目运行 gitbook serve 命令后,那一瞬间,感觉世界都静止了,奇迹就这么发生了? 终于成功了,实现默认折叠效果了吗? 为了验证是否成功实现默认折叠失效,做一次反向测试,既然默认折叠左侧菜单设置的是 false,如果设置成 true 的话,默认应该是展开状态. // Prepare sidebar: state and toggle button function init() { // Close sidebar as default state // gitbook.storage.set('sidebar', false); // Open sidebar as default state gitbook.storage.set('sidebar', true); // Init last state if not mobile if (!platform.isMobile()) { toggleSidebar(gitbook.storage.get('sidebar', true), false); } // Close sidebar after clicking a link on mobile $(document).on('click', '.book-summary li.chapter a', function(e) { if (platform.isMobile()) toggleSidebar(false, false); }); } 重新编译后再次启动本地测试项目,如果是展开状态,那就说明成功不是偶然而是靠技巧和努力! 重新编译源码 $ src/build.sh /Users/snowdreams1006/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default 启动本地项目 $ gitbook serve /Users/snowdreams1006/Documents/workspace/test 「雪之梦技术驿站」: 苦心人天不负,不是昙花一现的巧合而是货真价实的现实,就这么实现了默认折叠左侧菜单功能! 懒人直达以及回顾总结 如果你是 Gitbook 普通用户或者懒得折腾,那么推荐你直接替换掉 theme.js 文件: 查看正在使用的 gitbook 版本信息 $ gitbook current GitBook version is 3.2.3 打开正在使用的 gitbook 安装位置 $ open ~/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/ 新文件替换掉原来的 _assets/website/theme.js 文件 可以关注微信公众号回复 \"gitbook\" 获取重新编译后的新文件 theme.js. 切换到测试项目验证默认折叠是否已生效 $ gitbook serve 如果你不怕麻烦,喜欢折腾,那么不妨体验一下如何重新编译源码文件. 查看正在使用的 gitbook 版本信息 $ gitbook current GitBook version is 3.2.3 打开正在使用的 gitbook 安装位置 $ open ~/.gitbook/versions/3.2.3/node_modules/gitbook-plugin-theme-default/ 安装 theme-default 默认主题项目所需依赖 $ npm install 安装 build.sh 构建脚本所需依赖 $ sudo npm install -g browserify uglify-js less less-plugin-clean-css 运行 build.sh 构建脚本重新编译 $ src/build.sh 切换到测试项目验证默认折叠是否已生效 $ gitbook serve 值得注意的是,实现默认折叠左侧菜单功能仅仅需要添加一行代码,但是也很有可能和项目中已引入插件存在冲突,毕竟 sidebar 的状态也可以被未知代码所更改! // Prepare sidebar: state and toggle button function init() { // Close sidebar as default state gitbook.storage.set('sidebar', false); // Open sidebar as default state // gitbook.storage.set('sidebar', true); // Init last state if not mobile if (!platform.isMobile()) { toggleSidebar(gitbook.storage.get('sidebar', true), false); } // Close sidebar after clicking a link on mobile $(document).on('click', '.book-summary li.chapter a', function(e) { if (platform.isMobile()) toggleSidebar(false, false); }); } 最后希望本文对你有所帮助,面向搜索编程变得不可用时,自力更生也未尝不可,如果大家在使用 Gitbook 中遇到任何问题,欢迎留言评论告诉我,当然我也不一定保证解决,万一哪天心血来潮翻看一下源码就解决了呢! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/issue/modify-default-fold.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-10 13:29:01 "},"myGitbook/reference/":{"url":"myGitbook/reference/","title":"参考更多","keywords":"","body":"更多学习笔记 gitbook 简体中文官方文档 gitbook 繁体中文官方文档 敖小剑的 gitbook 学习笔记 gitbook 插件使用笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/myGitbook/reference/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"java8/":{"url":"java8/","title":"java8新特性","keywords":"","body":"java8新特性 java8作为 java的一个重要版本,目前为大多数企业和个人所接受,了解其本身为我们提供了哪些改变有助于我们去解决实际问题,窥探其今后可能的发展方向. 接下来本教程将从java语言本身入手,结合笔者实际经验,带你了解常用的新特性以及日常工作中如何应用. 最好拥有一定的java基础,只有经历过痛苦的折磨才能感受到新特性的愉快 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/java8/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"java8/lambda.html":{"url":"java8/lambda.html","title":"lambda表达式","keywords":"","body":"lambda表达式 下面通过对比 java8 之前的普通实现和 java8 引入lambda 表达式的实现,帮助读者快速了解代码差异性,眼见为实,赶紧开始吧! 求给定数组最小值 public static void main(String[] args) { // 方法1: jdk8以前的实现 int[] nums = {33, 55, -55, 90, -666, 90}; int min = Integer.MAX_VALUE; for (int i : nums) { if (i 方法1体现的是命令式编程的思维,需要明确编程细节,如果细节拿捏不准,那么结果自然不对. 而方法2则是函数式编程,只关注目标和结果,忽略过程,思路清晰更容易理解. 小结 命令式编程 强调过程,注重如何实现的细节,一步错,满盘皆输! 函数式编程 关注结果,不在乎实现细节,分配任务让下属去处理! lambda 表达式 是函数式编程 的重要体现,简洁易于理解. 创建线程运行任务 public static void main(String[] args) { // 方法1: jdk8以前一般写法 new Thread(new Runnable() { @Override public void run() { System.out.println(\"ok\"); } }).start(); // 方法2: jdk8采用 lambda 表达式写法 new Thread(() -> System.out.println(\"ok\")).start(); } 从上例可以看出,这里的lambda 表达式 返回的是实现了指定接口的对象实例. 小结 lambda 表达式 实现指定接口方法并返回该接口实例对象 lambda 表达式 由输入和输出以及实现过程三部分组成,不在乎方法名. 初体验 // 定义只有一个方法的接口 interface TestInterface { int doubleNum(int i); } public static void main(String[] args) { // 方法1: 实现doubleNum方法,实现过程是输入i返回 i*2,最终得到实现了该接口的实例对象 TestInterface i1 = i -> i * 2; System.out.println(i1.doubleNum(1)); // 方法2: 多个入参时需要用()包围起来,只有一个入参时可省略,见方法1 TestInterface i2 = (i) -> i * 2; System.out.println(i2.doubleNum(1)); // 方法3: 入参可指定类型,没有明确指定类型时自动推断,如方法1和方法2均未指定入参类型 TestInterface i3 = (int i) -> i * 2; System.out.println(i3.doubleNum(1)); // 方法4: 实现体不止一句代码时,需要用{}包围起来,并在实现体内部处理出参,当然实际情况中也可能并没有返回值 TestInterface i4 = (int i) -> { System.out.println(\"regular lambda expression\"); return i * 2; }; System.out.println(i4.doubleNum(1)); } lambda 表达式 实现的接口有且仅有一个要实现的接口,体现了 java 的单一职责原则. 这一点也很好理解,如果不止一个接口需要实现,那实现的具体是哪一个方法呢?所以这样的情况在 ide 中一般都会有相应的提示. 此外,java8 引入新的注解 @FunctionInterface 来支持lambda 表达式,也可用于ide 自动提示. 而上例中,我们的接口并没有标注过该注解,不是也能正常工作吗?是的,确实是这样的,所以@FunctionInterface 只是声明式注解,并没有实际作用,不过实际工作中最好加上@FunctionInterface 该注解,万一以后有用呢? 小结 lambda 表达式 实现的接口需要有 @FunctionInterface 注解,并且要实现的方法有且仅有一个. 日常工作中也应该学习单一职责原则,接口设计要足够细,方便使用lambda 表达式,术业有专攻. 利用接口多继承特性,做到接口的集大成者. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/java8/lambda.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"java8/functionInterface.html":{"url":"java8/functionInterface.html","title":"函数式接口","keywords":"","body":"函数式接口 接口允许有默认实现 @FunctionalInterface interface TestInterface { // 要实现的方法 int doubleNum(int i); // 默认实现方法 default int add(int x, int y) { return x + y; } } public static void main(String[] args) { // lambda 表达式实现doubleNum方法并返回该接口的实例对象 TestInterface interface1 = i -> i * 2; // 调用接口的doubleNum方法和add方法 System.out.println(interface1.doubleNum(1)); System.out.println(interface1.add(1,2)); } 小结 值得说明的是,默认接口实现应该是对所有的实现类来说有价值的默认实现,接口是对行为的规范,对接口的定义必须相当谨慎.那我们熟悉的 List 来说,查询源码,搜索@since发现,大多 api 是1.2,1.3,1.4...竟然没有,而1.8新增的也是 default 接口,为什么? 因为增加接口就需要实现,所以轻易不会新增接口,但是 jdk8允许有默认接口实现,这就解决了需要重新实现接口方法的问题,这也是为什么我们认为这是 jdk8的重大更新; 这里需要说明下 jdk8新增了默认接口实现方法,我们称之为默认接口实现方法,而 lambda 表达式实现的接口方法,我们称之为默认方法吧; 默认接口实现方法可以认为是内部实现类,也可以使用 this; @FunctionalInterface interface Interface1 { int doubleNum(int i); default int add(int x, int y) { System.out.println(this.doubleNum(1)); return x + y; } } public static void main(String[] args) { Interface1 interface1 = i -> i * 2; System.out.println(interface1.add(1, 2)); } 接口多继承时,需要指明具体覆盖哪一个默认实现方法 @FunctionalInterface interface Interface1 { int doubleNum(int i); default int add(int x, int y) { System.out.println(\"Interface1 add\"); return x + y; } } @FunctionalInterface interface Interface2 { int doubleNum(int i); default int add(int x, int y) { System.out.println(\"Interface2 add\"); return x + y; } } @FunctionalInterface interface Interface3 extends Interface2, Interface1 { @Override default int add(int x, int y) { System.out.println(\"Interface3 add\"); return Interface1.super.add(x, y); } } public static void main(String[] args) { Interface3 interface3 = i -> i * 2; System.out.println(interface3.add(1, 2)); } 接口真的需要吗,有没有更简洁的方法 public class MyMoneyDemo { public static void main(String[] args) { MyMoney myMoney = new MyMoney(9999999); myMoney.printMoney(i -> new DecimalFormat(\"#,###\").format(i)); } } interface IMoneyFormat { String format(int money); } class MyMoney { private final int money; public MyMoney(int money) { this.money = money; } public void printMoney(IMoneyFormat moneyFormat) { System.out.println(\"MyMoney is \" + moneyFormat.format(this.money)); } } 以上例子,定义一个接口,然后 lambda 表达式生成接口的实现类,从而实现接口功能; 其实不难发现,lambda 表达式实现的过程中,我们并不关心接口的参数以及方法名,我们仅仅关心入参和出参,那让我们进一步简化吧; public class MyMoneyDemo { public static void main(String[] args) { MyMoney myMoney = new MyMoney(9999999); myMoney.printMoney(i -> new DecimalFormat(\"#,###\").format(i)); } } class MyMoney { private final int money; public MyMoney(int money) { this.money = money; } public void printMoney(Function moneyFormat) { System.out.println(\"MyMoney is \" + moneyFormat.apply(this.money)); } } 这就是函数式编程,不必定义那么多接口,此外函数式接口还支持链式操作; public class MyMoneyDemo { public static void main(String[] args) { MyMoney myMoney = new MyMoney(9999999); Function moneyFormat = i -> new DecimalFormat(\"#,###\").format(i); myMoney.printMoney(moneyFormat.andThen(s -> \"RMB: \" + s)); } } class MyMoney { private final int money; public MyMoney(int money) { this.money = money; } public void printMoney(Function moneyFormat) { System.out.println(\"MyMoney is \" + moneyFormat.apply(this.money)); } } 小结 接口 输入参数 返回类型 说明 Predicate T boolean 断言 Consumer T / 消费一个数据 Function T R 输入T输出R的函数 Supplier / R 提供一个数据 UnaryOperator T T 一元函数(输出输入类型相同) BiFunction R 两个输入的函数 BinaryOperator T 两元函数(输出输入类型相同) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/java8/functionInterface.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"php/":{"url":"php/","title":"php 学习笔记","keywords":"","body":"php 学习笔记 php 是世界上最好的语言,我正在学习 php,多多指教! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/php/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"php/php-setup-environment-mac.html":{"url":"php/php-setup-environment-mac.html","title":"搭建开发环境( mac 版)","keywords":"","body":"搭建开发环境( mac 版) Mac 系统默认集成了很多开发工具,其中就包括 php 所需要的一些软件工具. 下面我们将搭建最简单的 php 开发环境,每一步都会验证上一步的操作结构,请一步一步跟我一起搭建吧! web 服务器之 apache apache 是一款 web 服务器,用于运行 php 文件,除了 apache 外也可以是 nginx 服务器. 默认情况下 mac 已经预装了 apach 服务,自然不用 nginx 服务器了. 现在什么也没有配置的情况下,直接启动 apache 服务器看一下能否正常运行. $ sudo apachectl start 常用命令 查看 apache 版本 语法: apachectl -v 示例: $ apachectl -v Server version: Apache/2.4.34 (Unix) Server built: Feb 22 2019 19:30:04 启动 apache 服务 语法: sudo apachectl start 示例: $ sudo apachectl start Password: 停止 apache 服务 语法: sudo apachectl stop 示例: $ sudo apachectl stop 重启 apache 服务 语法: sudo apachectl restart 示例: $ sudo apachectl restart 安装路径 apache 默认安装于 /private/etc/apache2 目录,属于系统隐藏目录,可以在终端中直接进入也可以在访达中直接前往文件夹. 示例: $ tree /private/etc/apache2 /private/etc/apache2 ├── extra │ ├── httpd-autoindex.conf │ ├── httpd-autoindex.conf~previous │ ├── httpd-dav.conf │ ├── httpd-dav.conf~previous │ ├── httpd-default.conf │ ├── httpd-default.conf~previous │ ├── httpd-info.conf │ ├── httpd-info.conf~previous │ ├── httpd-languages.conf │ ├── httpd-languages.conf~previous │ ├── httpd-manual.conf │ ├── httpd-manual.conf~previous │ ├── httpd-mpm.conf │ ├── httpd-mpm.conf~previous │ ├── httpd-multilang-errordoc.conf │ ├── httpd-multilang-errordoc.conf~previous │ ├── httpd-ssl.conf │ ├── httpd-ssl.conf~previous │ ├── httpd-userdir.conf │ ├── httpd-userdir.conf~previous │ ├── httpd-vhosts.conf │ ├── httpd-vhosts.conf~previous │ └── proxy-html.conf ├── httpd.conf ├── httpd.conf.pre-update ├── httpd.conf~previous ├── magic ├── mime.types ├── original │ ├── extra │ │ ├── httpd-autoindex.conf │ │ ├── httpd-dav.conf │ │ ├── httpd-default.conf │ │ ├── httpd-info.conf │ │ ├── httpd-languages.conf │ │ ├── httpd-manual.conf │ │ ├── httpd-mpm.conf │ │ ├── httpd-multilang-errordoc.conf │ │ ├── httpd-ssl.conf │ │ ├── httpd-userdir.conf │ │ ├── httpd-vhosts.conf │ │ └── proxy-html.conf │ └── httpd.conf ├── other │ └── php7.conf └── users └── Guest.conf 5 directories, 43 files 如果想要修改项目部署路径以及服务器端口等自定义配置,可打开 /private/etc/apache2/httpd.conf 文件进行编辑,如果权限不足,要么提升权限要么复制到别处修改好再替换掉原来的配置文件. 配置文件一旦修改,请一定要重启服务器,不然并不会生效! vim 搜索文件内容时临时高亮设置: :set hlsearch ,取消高亮设置: :set nohlsearch . 修改项目部署路径 DocumentRoot : 默认部署路径于 /Library/WebServer/Documents 终端输入 vim 命令查找并编辑目标节点. $ vim /private/etc/apache2/httpd.conf 输入 vim /private/etc/apache2/httpd.conf 进入命令行模式,输入 :/DocumentRoot 从头搜索文件内容,紧接着输入 n 表示查找下一项匹配字符,N 表示查找上一项匹配内容. 如果不熟悉 vim 语法也可以选择熟悉的编辑器打开 httpd.conf 配置文件进行修改配置. 修改项目部署端口 Listen : 默认监听端口 80 如果端口冲突的话,可以修改成其他端口,80 端口的好处在于可以直接访问服务器地址而不用显示带上端口号. # 等价于 http://localhost:80 http://localhost # 等价于 http://127.0.0.1:80 http://127.0.0.1 部署路径 默认情况下,apache 的部署路径位于 /Library/WebServer/Documents ,除非你更改了 httpd.conf#DocumentRoot 的节点配置. $ tree /Library/WebServer/Documents /Library/WebServer/Documents ├── PoweredByMacOSX.gif ├── PoweredByMacOSXLarge.gif ├── index.html.en └── index.html.en~orig 0 directories, 4 files 当然你可以通过访达直接前往 /Library/WebServer/Documents 目录或者 open /Library/WebServer/Documents 直接调用内置程序打开目录. 如果非要一步一步找到部署路径,打开 访达 后选择左侧最下方的本地光盘(个人用户名称),然后依次选择 Machintosh HD > 资源库 (Library) > WebServer > Documents 世界上最好的语言之 php php 在行业内赢得\"世界上最好的语言\"称号,自嘲为\"拍簧片\".不管怎样,既然我们决定 pai(拍)huang(簧)pian(片) ,那总要配置一下 php 的基本环境吧! Mac 系统一如既往内置了 php 环境,不用我们费心去安装 php 了,现在看一下 php 的基本信息吧! $ php -version PHP 7.1.23 (cli) (built: Feb 22 2019 22:08:13) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies php 是一种服务端脚本解释性语言,依赖于 web 服务器进行解析,所以 php 想要正常工作离不开上一步配置的 apache 服务器. 还记得 apache 配置文件的位置吗? apache 配置文件路径 : /private/etc/apache2/httpd.conf 打开 httpd.conf 配置文件并搜索 LoadModule php 字符串,将前面的 # 去掉即可引入 php 支持,配置文件修改后记得重启才能生效哟! 是时候展示真正的技术了,现在万事俱备只待测试 php 到底有没有配置成功?! 在项目部署根目录下新建 info.php 测试文件,启动服务器后访问 http://localhost/info.php 如果能正常打印出 php 相关信息,那就证明 php 和 apache 整合无误,否则可能是某一步配置有误! phpinfo(); 持久化存储之 mysql 数 Mac 系统并没有默认安装 mysql 服务,因此我们需要手动安装 mysql . 一般来说,我们谈到 mysql 数据库指的是 mysql 的服务端,作为生产环境服务端足够了并不需要客户端. 但是,日常开发中如果没有客户端我们很难直观管理数据,所以一般来说,我们还会安装 mysql 客户端,当然一般是各种功能强大的图形化工具. mysql 服务端 下载链接: macOS 10.14 (x86, 64-bit), DMG Archive 和正常的软件安装一样,将安装文件移动到应用里即可完成,比 Windows 的下一步下一步安装还要方便快捷! 安装完成后,可以在系统偏好设置中找到 MySQL 图标,查看管理 mysql 服务端. 点击 MySQL 图标,可以进行简单的设置以及重启服务等操作. 但是如果想要在终端中无痛连接上 mysql 服务端,那么还需要一步设置软链接,类似于 Windows 的快捷方式. $ sudo ln -fs /usr/local/mysql/bin/mysql /usr/local/bin/mysql 现在我们就可以在终端内愉快的连接上 mysql 服务端了呢! # 登录 `mysql` 服务端 $ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 29 Server version: 5.7.24 MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. # 查看当前数据库列表 mysql> show databases; +---------------------+ | Database | +---------------------+ | information_schema | | mysql | | performance_schema | | security-plus | | sys | | test | +---------------------+ 6 rows in set (0.00 sec) # 退出当前数据库会话 mysql> exit Bye $ 查看 mysql 服务端版本 语法: mysql --version 示例: $ mysql --version mysql Ver 14.14 Distrib 5.7.24, for macos10.14 (x86_64) using EditLine wrapper 查看 mysql 服务端状态 语法: sudo /usr/local/mysql/support-files/mysql.server status 示例: $ sudo /usr/local/mysql/support-files/mysql.server status SUCCESS! MySQL running (73088) 启动 mysql 服务端 语法: sudo /usr/local/mysql/support-files/mysql.server start 示例: $ sudo /usr/local/mysql/support-files/mysql.server start Starting MySQL . SUCCESS! 停止 mysql 服务端 语法: sudo /usr/local/mysql/support-files/mysql.server stop 示例: $ sudo /usr/local/mysql/support-files/mysql.server stop Shutting down MySQL .. SUCCESS! 重启 mysql 服务端 语法: sudo /usr/local/mysql/support-files/mysql.server restart 示例: $ sudo /usr/local/mysql/support-files/mysql.server restart Shutting down MySQL . SUCCESS! Starting MySQL . SUCCESS! mysql 客户端 如果说生产环境没有 mysql 的图形化工具也就罢了,但是如果日常开发时也不没有图形化工具的话,那就真的太不方便了. 这里推荐两个客户端工具,一个是人畜无害的 Sequel Pro,另一个则是 php 专属的 phpMyAdmin. BS 架构的 phpMyAdmin 下载地址 : phpMyAdmin phpMyAdmin 是一款 web 版数据款管理软件,可以在浏览器中在线访问,像访问你的网站一样访问数据库. 下载完成后解压并重命名为 phpMyAdmin,然后移动到 apache 的项目部署路径下,如果没有更改过默认的部署路径,那么应该是 /Library/WebServer/Documents 目录. 现在部署路径下不仅有个 info.php 文件还有 phpMyAdmin 文件夹. # 仅仅显示两级文件目录 $ tree -L 2 . ├── PoweredByMacOSX.gif ├── PoweredByMacOSXLarge.gif ├── index.html.en ├── index.html.en~orig ├── info.php └── phpMyAdmin ├── CODE_OF_CONDUCT.md ├── CONTRIBUTING.md ├── export.php ├── favicon.ico ├── gis_data_editor.php ├── import.php ├── import_status.php ├── index.php ├── view_operations.php └── yarn.lock 11 directories, 108 files 移动完成后先复制一份 config.sample.inc.php 文件并重命名为 config.inc.php 文件. 执行 vim /Library/WebServer/Documents/phpMyAdmin/config.inc.php 搜索并编辑 host 节点内容,将 localhost 更改成 127.0.0.1 . 示例: # 修改前 $cfg['Servers'][$i]['host'] = 'localhost'; # 修改后: 将 `localhost` 更改成 `127.0.0.1` $cfg['Servers'][$i]['host'] = '127.0.0.1'; 重启 apache 服务,访问 http://localhost/phpMyAdmin/ 开始登陆数据库吧! 输入 mysql 的用户名和密码登录成功后就能管理本地数据库了. CS 架构的 Sequel Pro 下载地址 : v1.1.2 OS X 10.6 or Higher Sequel Pro 是简单易用的数据库管理工具,与上述的 phpMyAdmin 不同之处在于并不依赖 php 环境,可以独立安装部署. 安装完成后输入数据库连接信息连接到本地数据库,参考信息如下. 点击连接(Connect) 连接到本地服务器,由于刚才并没有选择数据库,因此登陆后需要选定数据库,这里根据实际情况选择即可. php 集成 mysql 如果没有数据库提供持久化存储能力,那么 php 只能临时运行而没有记忆功能,所以想要记住网站大量信息自然离不开数据库. 准备数据 为了接下来演示 php 集成 mysql 数据库,现在先创建一个测试数据库并插入一些测试数据. 下面主要是通过终端方式进行操作,小伙伴们也可以使用上述安装的图形化工具进行可视化编辑. 连接到本地服务器 语法 : mysql -u -p 示例: # 连接到本地数据库,用户名 `root`,密码自定义 $ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 109 Server version: 5.7.24 MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. 列出当前数据库列表 语法 : show databases 示例: mysql> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | security-plus | | sys | +--------------------+ 5 rows in set (0.00 sec) 创建测试数据库 语法 : create database 示例: # 创建 `test` 数据库并指定编码格式为 `utf8` mysql> create database IF NOT EXISTS test default charset utf8 COLLATE utf8_general_ci; Query OK, 1 row affected (0.00 sec) # 再次查询当前数据库列表,新增 `test` 数据库 mysql> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | security-plus | | sys | | test | +--------------------+ 6 rows in set (0.00 sec) 列出当前数据表列表 语法 : show tables 示例: # 使用 `test` 测试数据库 mysql> use test; Database changed # 列出当前全部数据表 mysql> show tables; Empty set (0.00 sec) 创建测试数据表 语法 : create tabel ( )) # 创建 `user` 用户表 mysql> CREATE TABLE `test`.`user` ( `id` BIGINT(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户 id', `name` VARCHAR(45) NOT NULL DEFAULT '' COMMENT '姓名', PRIMARY KEY (`id`), UNIQUE INDEX `id_UNIQUE` (`id` ASC)) ENGINE = InnoDB DEFAULT CHARACTER SET = utf8 COMMENT = '用户表'; Query OK, 0 rows affected (0.01 sec) # 再次列出当前数据表列表 mysql> show tables; +----------------+ | Tables_in_test | +----------------+ | user | +----------------+ 1 row in set (0.00 sec) 查看数据表结构 语法 : desc 示例: mysql> desc user; +-------+---------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+---------------------+------+-----+---------+----------------+ | id | bigint(11) unsigned | NO | PRI | NULL | auto_increment | | name | varchar(45) | NO | | | | +-------+---------------------+------+-----+---------+----------------+ 2 rows in set (0.00 sec) 查看数据表创建语句 语法 : show create table 示例: mysql> show create table user \\G *************************** 1. row *************************** Table: user Create Table: CREATE TABLE `user` ( `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户 id', `name` varchar(45) NOT NULL DEFAULT '' COMMENT '姓名', PRIMARY KEY (`id`), UNIQUE KEY `id_UNIQUE` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表' 1 row in set (0.00 sec) 查询数据 语法 : select [fields] from tableName [where condition] [limit N][ offset M] 示例: mysql> select id,name from user; Empty set (0.00 sec) 插入数据 语法 : insert into ([fields]) VALUES ([values]) 示例: mysql> INSERT INTO `test`.`user` (`name`) VALUES ('snowdreams1006'); Query OK, 1 row affected (0.00 sec) mysql> INSERT INTO `test`.`user` (`name`) VALUES ('雪之梦技术驿站'); Query OK, 1 row affected (0.00 sec) mysql> INSERT INTO `test`.`user` (`name`) VALUES ('测试用户姓名'); Query OK, 1 row affected (0.00 sec) mysql> select id,name from user; +----+-----------------------+ | id | name | +----+-----------------------+ | 1 | snowdreams1006 | | 2 | 雪之梦技术驿站 | | 3 | 测试用户姓名 | +----+-----------------------+ 3 rows in set (0.00 sec) 退出数据库 语法 : exit 示例: mysql> exit Bye $ 导出数据 语法 : mysqldump -u -p > exportName.sql 备份数据用到的是 mysqldump 工具,默认情况下该命令位于 /usr/local/mysql/bin 目录下,正常情况下需要指定该路径才能调用 mysqldump 命令. $ tree /usr/local/mysql/bin /usr/local/mysql/bin ├── innochecksum ├── lz4_decompress ├── my_print_defaults ├── myisam_ftdump ├── myisamchk ├── myisamlog ├── myisampack ├── mysql ├── mysql_client_test_embedded ├── mysql_config ├── mysql_config_editor ├── mysql_embedded ├── mysql_install_db ├── mysql_plugin ├── mysql_secure_installation ├── mysql_ssl_rsa_setup ├── mysql_tzinfo_to_sql ├── mysql_upgrade ├── mysqladmin ├── mysqlbinlog ├── mysqlcheck ├── mysqld ├── mysqld-debug ├── mysqld_multi ├── mysqld_safe ├── mysqldump ├── mysqldumpslow ├── mysqlimport ├── mysqlpump ├── mysqlshow ├── mysqlslap ├── mysqltest_embedded ├── mysqlxtest ├── perror ├── replace ├── resolve_stack_dump ├── resolveip └── zlib_decompress 0 directories, 38 files 所以,应该是如下命令才能调用 mysqldump 命令. $ /usr/local/mysql/bin/mysqldump --version mysqldump Ver 10.13 Distrib 5.7.24, for macos10.14 (x86_64) 不过这也太长了吧,肯定不是很不变,一劳永逸的方法是将 /usr/local/mysql/bin 加入到环境变量中就不用添加额外的路径信息了. 还记得 mysql 服务端刚安装完毕,我们想要通过终端连接到本地数据库服务器时设置了 mysql 的软链接,所以才能直接使用 mysql -u root -p 进行登录. mac 的软链接方式相当于 windows 系统的快捷方式,只针对具体命令,现在需要 mysqldump 命令,继续使用软链接还要添加类似的快捷方式. $ sudo ln -fs /usr/local/mysql/bin/mysql /usr/local/bin/mysql $ sudo ln -fs /usr/local/mysql/bin/mysqldump /usr/local/bin/mysqldump 实测可用,但是这并不是优雅的操作方式,/usr/local/mysql/bin/ 目录下那么多命令,下次需要用到其他命令岂不是要设置很多软链接? $ mysqldump --version mysqldump Ver 10.13 Distrib 5.7.24, for macos10.14 (x86_64) 所以,现在我们考虑将 /usr/local/mysql/bin 加入到系统环境变量中,这样一来就能一劳永逸不用频繁设置软链接了! # mysql export PATH=$PATH:/usr/local/mysql/bin 设置完毕后下次重启电脑就会生效,或者运行下述命令立即生效. $ source ~/.bash_profile 为了测试环境变量是否生效,我们先删除原来的软链接. $ rm -rf /usr/local/bin/mysql $ rm -rf /usr/local/bin/mysqldump 依然能够正常调用 mysql 相关命令. # `mysql` 版本信息 $ mysql --version mysql Ver 14.14 Distrib 5.7.24, for macos10.14 (x86_64) using EditLine wrapper # `mysqldump` 版本信息 $ mysqldump --version mysqldump Ver 10.13 Distrib 5.7.24, for macos10.14 (x86_64) 示例: $ mysqldump -u root -p test > database_test.sql; Enter password: $ 注意 : mysqldump 和 mysql 相互独立的命令行程序,并不是在 mysql 会话中执行的 sql. 查看当前备份文件内容: # 备份文件位于当前目录 $ cat $(pwd)/database_test.sql 备份 sql 文件内容,可以直接复制执行. -- MySQL dump 10.13 Distrib 5.7.24, for macos10.14 (x86_64) -- -- Host: localhost Database: test -- ------------------------------------------------------ -- Server version 5.7.24 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */; /*!40101 SET NAMES utf8 */; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */; /*!40103 SET TIME_ZONE='+00:00' */; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; -- -- Table structure for table `user` -- DROP TABLE IF EXISTS `user`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `user` ( `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户 id', `name` varchar(45) NOT NULL DEFAULT '' COMMENT '姓名', PRIMARY KEY (`id`), UNIQUE KEY `id_UNIQUE` (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='用户表'; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `user` -- LOCK TABLES `user` WRITE; /*!40000 ALTER TABLE `user` DISABLE KEYS */; INSERT INTO `user` VALUES (1,'snowdreams1006'),(2,'雪之梦技术驿站'),(3,'测试用户姓名'); /*!40000 ALTER TABLE `user` ENABLE KEYS */; UNLOCK TABLES; /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */; /*!40101 SET SQL_MODE=@OLD_SQL_MODE */; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; -- Dump completed on 2019-05-19 12:49:35 导入数据 语法 : source 示例: # 创建 `test_import` 数据库 mysql> create database test_import; # 使用 `test_import` 数据库 mysql> use test_import; # 导入 `database_test.sql` 文件 mysql> source /Users/sunpo/Documents/workspace/snowdreams1006.github.io/database_test.sql 删除数据库 语法 : drop database 示例: mysql> drop database test_import; Query OK, 1 row affected (0.01 sec) 编程连接 如果没有更改过项目的部署路径,那么我们之前有个测试 php 环境的文件,即 /Library/WebServer/Documents/info.php ,现在我们继续编写该文件,通过编码的方式连接到 mysql 数据库. $username=\"root\"; $userpass=\"root\"; $dbhost=\"127.0.0.1\"; $dbdatabase=\"test\"; // 连接到本地服务器 $db=new mysqli($dbhost,$username,$userpass,$dbdatabase); $db->set_charset(\"utf8\"); if(mysqli_connect_error()){ echo \"连接失败: \" . mysqli_connect_error(); exit; } # 查询用户列表 $result = $db->query(\"SELECT id,name FROM user\"); if ($result->num_rows > 0) { // 输出数据 while($row = $result->fetch_assoc()) { echo var_dump($row). \"\"; } } # 关闭数据库连接 $db->close(); phpinfo(); 现在再次启动 apache 服务器,访问 http://localhost/info.php 测试成功! 环境搭建要点总结 apache 服务默认已安装,启动服务器后,在浏览器中访问 http://localhost/ 会显示It works!,表明 apache 能正常使用. 查看 apache 服务器版本 : apachectl -v 启动 apache 服务器 : sudo apachectl start 停止 apache 服务器 : sudo apachectl stop 重启 apache 服务器 : sudo apachectl restart apache 服务器安装路径 : /private/etc/apache2 apache 服务器部署路径 : /Library/WebServer/Documents php 服务默认已安装,集成到 apache 服务器只需要在 /private/etc/apache2/httpd.conf 配置文件中启用 LoadModule php7_module libexec/apache2/libphp7.so 模块即可,重启 apache 服务器即可支持 php 环境. 查看 php 版本信息 : php -version php 默认配置文件路径 : /private/etc/php.ini.default mysql 数据库默认没有安装,需要手动前往 https://www.mysql.com/downloads/ 官网进行下载安装. 如果需要在终端命令行内访问 mysql 服务端,最好将 mysql 的安装路径添加到系统环境中,或者添加软链接也可以. mysql 安装路径 : /usr/local/mysql 系统环境变量路径 : ~/.bash_profile mysql 二进制文件添加到系统环境变量 : export PATH=$PATH:/usr/local/mysql/bin 刷新系统环境变量配置 : source ~/.bash_profile mysql 命令添加软链接 : sudo ln -fs /usr/local/mysql/bin/mysql /usr/local/bin/mysql 查看 mysql 服务器状态 : sudo mysql.server status 启动 mysql 服务器 : sudo mysql.server start 停止 mysql 服务器 : sudo mysql.server stop 重启 mysql 服务器 : sudo mysql.server restart 查看 mysql 版本信息 : mysql --version 登录 mysql 服务器 : mysql -u root -p 退出 mysql 服务器 : exit 最后,php 不仅仅可以面向过程也可以面向对象,虽然是拍簧片,但真的很强大,魅力不小呢! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/php/php-setup-environment-mac.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"php/set-timezone-method.html":{"url":"php/set-timezone-method.html","title":"关于时区的那点事","keywords":"","body":"关于时区的那点事 科普一下什么是时区 众所周知,地球绕着太阳转的同时也会自转,因此同一时刻不同地区所接收到太阳照射的情况不同,所以有的地区是日出,有的地区是日落,还有的地区可能是黑夜. 既然地球上的不同地区时间不同,那总要有统一的时间刻度才能方便文化科技交流吧,不然大家说的都是当地时间,这样岂不是乱套了? 有问题就要解决问题,不同地区时间不同就要统一时间标准,而统一时间标准的前提就是要弄清楚全球的时间差异到底在哪以及各地的当地时间如何互相转换. 原来的时间标准是格林尼治标准时间,随着精确计时的发展需要,已被新的时间标准所取代,目前的时间标准是世界协调时. 现在有了统一的时间标准,不同地区的时间就可以统一换算成世界协调时再转换成当地时间了,再也不会出现同一时刻不同时间了! 示例: 北京时间(UTC+8) : 2019-05-30 13:30:00 世界时间(UTC) : 2019-05-30 05:30:00 东部时间(UTC-5) : 2019-05-30 00:30:00 格林尼治标准时间 格林尼治标准时间(又称格林威治平均时间或格林威治标准时间,英文是GreenwichMeanTime,简称GMT ),格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时(也就是在格林尼治时)的时间. 格林尼治是英国伦敦的一个小镇,是地理经度的起点,本初子午线所在的经度是零度经度,所在的时区是零时区. 我们知道一天共有 24 小时,对应着全球 24 个时区,而地球自西向东自转,零时区后依次是东一区到东十一区,然后是东十二区.紧接着是西十二区,西十一区到西一区,最后又回到零时区. 其中东十二区和西十二区是同一个时区,又被称为东西十二区. 总的来说,时区分为东十二区和西十二区以及零时区,其中东西十二区是同一个时区,因此共有 24 个时区. 示例: 由于北京位于东八区,比零时区多个 8 个时区,意味着北京时间比格林标准时间快 8 个小时. 所以,北京时间中午 12 点整的时候,格林尼治才清早 4 点钟,估计还在睡觉呢! ( GMT+8 就是北京时间) 格林尼治标准时间与地球自转有关,不能满足精确计时的需求,因此不再作为标准时间,取而代之的是协调世界时. 协调世界时 协调世界时(又称世界统一时间或世界标准时间或国际协调时间,英文是Coordinated Universal Time,简称UTC ),协调世界时是以原子时秒长为基础,在时刻上尽量接近于格林尼治标准时间的一种时间计量系统. 在不需要精确到秒的情况下, GMT 和 UTC 基本一致,但 UTC 是以更加精确的原子时为基础,因此常用于科学计算领域,也是目前时间计量的统一标准. 示例: 北京时间 12:00 ,换算成 GMT 或 UTC 时间都是 04:00 ( UTC+8 也是北京时间) 北京时间 北京时间(又称中国标准时间),是首都北京所在的时区作为中国的标准时间,比格林尼治标准时间快8小时. 我国幅员辽阔,从西到东横跨东五,东六,东七,东八和东九等五个时区.所以全国统一采用首都北京所在的东八时区的区时作为标准时间,也就是北京时间. 时区信息数据库 时区信息数据库,又称 Olson数据库,是一个主要应用于电脑程序以及操作系统的可协作编辑世界时区信息的数据库. 时区信息数据库采用按“区域/位置”命名规范,方便应用于计算机世界,其中英文地名中的空格用下划线“_”代替,连词符“-”只在英文地名本身包含时使用. 示例: Asia/Hong_Kong : 亚洲/香港 Asia/Macau : 亚洲/澳门 Asia/Shanghai : 亚洲/上海 Asia/Taipei : 亚洲/台北 Asia/Urumqi : 亚洲/乌鲁木齐 上述时区主要是 php 中所支持的中国时区,参考 亚洲所支持的时区列表 关于时区的编程实现 时区不仅仅是现实生活的问题,计算机编程世界也有时间,自然也离不开时区的概念. 在计算机世界中,一切都是数据,最好时区的概念也能体现在相关数据库中,幸运的是已经有前辈为我们提供了时区信息数据库,而各类语言基本都会提供时区的工具类. php 中的日期时间函数库是 php 内置函数库,我们可以方便地操作时间,设置时区等. 正常情况下, date 扩展默认是启用的,我们可以输入 phpinfo 打印出 php 的基本信息,然后搜索关键字 date 就可以找到关于 date 扩展的相关信息. 示例 \"; // 获取当前时区 echo \"当前时区: \".date_default_timezone_get().\"\"; // 当前时间 echo \"当前时间: \".date(\"Y-m-d H:i:s\").\"\"; // 打印 php 信息 phpinfo(); ?> 结果 默认时区: 当前时区: UTC 当前时间: 2019-05-30 05:30:00 选项 值 date/time support(日期时间支持情况) enabled(已启用) timelib version(时间库版本) 2016.05(2016.05) \"Olson\" Timezone Database Version(Olson 时区数据库版本) 2018.5(2018.5) Timezone Database(时区数据库) internal(内部的) Default timezone(默认时区) UTC(协调世界时) 由此可见,假设不设置时区的话,默认时区是协调世界时,该时区和北京时间相比慢 8 个小时! 设置时区的三种姿势 翻阅 php 开发文档中可以找到目前所有支持时区列表,下面整理出关于中国的主要时区. Asia/Hong_Kong : 亚洲/香港 Asia/Macau : 亚洲/澳门 Asia/Shanghai : 亚洲/上海 Asia/Taipei : 亚洲/台北 Asia/Urumqi : 亚洲/乌鲁木齐 常用时区是上海,并没有北京,当然也可以设置成 PRC (中华人民共和国)! 如果没有设置时区的话,默认时区应该是协调世界时(UTC),虽说是通用的时间标准,但转换成当地时间还是需要一定换算的,而且看起来也不太舒服. 所以最好还是修改一下时区的设置项,如果业务不考虑国际化需求,那么永久性把时区固定就可以了,如果有国际化的业务场景,那么最好能够动态设置时区,这样就能清楚知道当地时间了. 因此,下面主要提供两种方式来设置时区,分别是静态设置和动态设置,其中动态设置又提供了两种方法. 静态修改 php 配置 php 的配置文件默认位于 : /private/etc/php.ini ,打开文件后修改 date.timezone 选项. 由于这种方法是直接修改配置文件,因此时区设置后适用于所有脚本,只不过需要重启服务器方可生效. 示例 [Date] ; Defines the default timezone used by the date functions ; http://php.net/date.timezone ;date.timezone = ; http://php.net/date.default-latitude ;date.default_latitude = 31.7667 ; http://php.net/date.default-longitude ;date.default_longitude = 35.2333 ; http://php.net/date.sunrise-zenith ;date.sunrise_zenith = 90.583333 ; http://php.net/date.sunset-zenith ;date.sunset_zenith = 90.583333 结果 # 去掉;并设置时区,取值可以是PRC,也可以是Asia/Shanghai等时区 date.timezone = PRC 详情请参考: http://php.net/date.timezone 动态设置 php 配置 ini_set 支持设置当前脚本的默认时区选项. 静态设置时区仅仅适合时区固定的情况,如果需要动态切换时区,修改配置文件就不能满足这种情况了. 因此,php 中还提供了动态修改 php.ini 配置文件的方法,ini_set() 方法刚好支持动态设置时区. 不用重启服务器,但仅仅针对当前脚本生效,其中 ini_set 方法支持的 php.ini 配置选项列表 示例 // 设置当前时区 ini_set(\"date.timezone\", \"Asia/Tokyo\"); // 获取默认时区 echo \"当前时区: \".ini_get(\"date.timezone\").\"\"; // 当前时间 echo \"当前时间: \".date(\"Y-m-d H:i:s\").\"\"; 结果 当前时区: Asia/Tokyo 当前时间: 2019-05-30 14:30:00 动态设置 php 时区 date_default_timezone_set 方法用于设置当前脚本的默认时区. ini_set 虽然支持设置时区选项,但毕竟不是专业设置时区的方法,date_default_timezone_set 才是专门设置时区的方法. 这两个方法都属于动态设置时区,也都是针对当前脚本生效,也都不用重启服务器就能立马生效. 示例 // 获取当前时区 echo \"当前时区: \".date_default_timezone_get().\"\"; // 设置当前时区 date_default_timezone_set(\"UTC\"); // 获取当前时区 echo \"当前时区: \".date_default_timezone_get().\"\"; // 当前时间 echo \"当前时间: \".date(\"Y-m-d H:i:s\").\"\"; 结果 当前时区: Asia/Tokyo 当前时区: UTC 当前时间: 2019-05-30 05:30:00 关于时区的一些总结 时区和时间密切相关,统一时间说的其实是统一时间的标准,这样一个地区的当地时间就可以轻易转换成另一个地区的当地时间了. 目前世界上统一的时间标准是协调时间时(UTC),中国的时间标准是北京时间,北京时间比协调时间时快 8 个小时. 现实世界的时区也要反映到计算机世界,其中时区信息数据库就是用于表示现实世界的时区概念. 由此可见,时区是一个通用概念,不仅 php 有时区,java 和 js 等语言也有时区概念,可以说只要有时间的地方都离不开时区. 关于时区的小技能,你 get 到了吗? 美剧>当地时间是星期二晚上八点开播,请问北京时间何时开播? 英剧>北京时间凌晨四点半开播,请问当地时间是何时开播? 泰剧>当地时间是晚上九点二十开播,请问北京时间是何时? 参考资料 时区相关知识扫盲 时区时差时间换算 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/php/set-timezone-method.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"php/datetime-overview.html":{"url":"php/datetime-overview.html","title":"日期时间操作一箩筐","keywords":"","body":"日期时间操作一箩筐 格式化日期时间 date : 格式化日期时间 场景 将当前日期时间或者特定日期时间格式化输出为特定格式的字符串,常用于人性化展示信息. 说明 返回给定时间戳格式化后所产生的日期时间字符串,如果没有给出时间戳则默认使用本地当前时间. 备注 格式 说明 返回值示例 Y 4 位数字完整表示的年份 2019 y 2 位数字表示的年份 19 M 三个字母缩写表示的月份 Jan 到 Dec m 数字表示的月份,有前导零 01 到 12 D 星期中的第几天,文本表示,3个字母 Mon 到 Sun d 月份中的第几天,有前导零的 2 位数字 01 到 31 H 小时,24 小时格式,有前导零 00 到 23 h 小时,12 小时格式,有前导零 01 到 12 I 是否为夏令时 如果是夏令时为1 ,否则为 0 i 有前导零的分钟数 00 到 59 S 每月天数后面的英文后缀,2 个字符 st,nd,rd 或者 th ,可以和 j 一起用 s 秒数,有前导零 00 到 59 常用格式 // 形如 2019-05-31 12:00:00 echo date(\"Y-m-d H:i:s\"); // 形如 2019/05/31 12:00:00 echo date(\"Y/m/d H:i:s\"); // 形如 2019年05月31日 12时00分00秒 echo date(\"Y年m月d日 H时i分s秒\"); 示例 // 设置当前时区为上海时区 date_default_timezone_set(\"Asia/Shanghai\"); // 获取当前时区 : Asia/Shanghai echo \"当前时区 : \".date_default_timezone_get().\"\"; // `Y年m月d日 H时i分s秒` 格式化当前时间 : 2019年05月30日 22时32分46秒 echo \"当前时间 : \".date(\"Y年m月d日 H时i分s秒\").\"\"; // `Y-m-d H:i:s` 格式化当前时间 : 2019-05-30 22:32:46 echo \"当前时间 : \".date(\"Y-m-d H:i:s\").\"\"; // `w` 星期中的第几天,数字表示: 0（表示星期天）到 6（表示星期六） switch (date(\"w\")) { case '0': $dayStr = \"日\"; break; case '1': $dayStr = \"一\"; break; case '2': $dayStr = \"二\"; break; case '3': $dayStr = \"三\"; break; case '4': $dayStr = \"四\"; break; case '5': $dayStr = \"五\"; break; case '6': $dayStr = \"六\"; break; default: $dayStr = \"未知\"; break; } // 2019年05月30日 星期四 echo \"当前时间 : \".date(\"Y年m月d日\").\" 星期\".$dayStr.\"\"; echo \"\"; // `z` 年份中的第几天 : 今天是全年的第149天 echo \"今天是全年的第\".date(\"z\").\"天\"; // `W` ISO-8601 格式年份中的第几周,每周从星期一开始 : 本周是全年的第22周 echo \"本周是全年的第\".date(\"W\").\"周\"; // `t` 指定的月份有几天 : 本月共有31天 echo \"本月共有\".date(\"t\").\"天\"; 日期转化时间戳 time : 返回当前的 Unix 时间戳 场景 获取当前日期时间或特定日期时间的时间戳,常用于日期时间之间的相互转换. 说明 返回自从 Unix 纪元(格林威治时间 1970年1月1日 00:00:00)到当前时间的秒数. 示例 // 设置当前时区为上海时区 date_default_timezone_set(\"Asia/Shanghai\"); // 获取当前时区 echo \"当前时区 : \".date_default_timezone_get().\"\"; // 一周前的日期时间: 7 days; 24 hours; 60 mins; 60 secs $preWeek = time() - (7 * 24 * 60 * 60); echo \"现在是\".date(\"Y-m-d H:i:s\").\",上周是\".date(\"Y-m-d H:i:s\",$preWeek).\"\"; // 一周后的日期时间: 7 days; 24 hours; 60 mins; 60 secs $nextWeek = time() + (7 * 24 * 60 * 60); echo \"现在是\".date(\"Y-m-d H:i:s\").\",下周是\".date(\"Y-m-d H:i:s\",$nextWeek).\"\"; microtime : 返回当前 Unix 时间戳和微秒数 场景 获取当前日期时间或特定日期时间的时间戳,常用于程序运行过程打点分析,也可以用于日期时间之间的互相转换. 说明 当前 Unix 时间戳以及微秒数,本函数仅在支持 `gettimeofday()`` 系统调用的操作系统下可用. 示例 // 设置当前时区为上海时区 date_default_timezone_set(\"Asia/Shanghai\"); // 获取当前时区 echo \"当前时区 : \".date_default_timezone_get().\"\"; // 当前日期时间戳 echo \"当前日期时间戳: \".time().\" \".microtime().\" \".microtime(TRUE).\"\"; mktime : 取得一个日期的 Unix 时间戳 场景 获取给定日期的时间戳,按照\"时分秒 月日年\"格式依次解析,返回时间戳. 说明 根据给出的参数返回 Unix 时间戳. 备注 格式 说明 参数示例 H hour 小时数 00 到 23 i minute 分钟数 00 到 59 s second 秒数 00 到 59 n month 月份数 01 到 12 j day 天数 01 到 31 Y year 年份数,可以是两位或四位数字 0-69 对应于 2000-2069 ,70-100 对应于 1970-2000 格式: 时分秒 月日年,支持从右往左依次省略,被省略的值取当前时间的对应值. 示例 // 设置当前时区为上海时区 date_default_timezone_set(\"Asia/Shanghai\"); // 获取当前时区 echo \"当前时区 : \".date_default_timezone_get().\"\"; // 指定日期时间戳: 时分秒 月日年 : 1559275200 2019-05-31 12:00:00 echo \"2019年05月31日 12:00:00 的时间戳: \".mktime(12,0,0,5,31,2019).\" \".date(\"Y-m-d H:i:s\", mktime(12,0,0,5,31,2019)).\"\"; // 距离国庆节还有多少天,单位秒 : 今天是2019-05-31,距离国庆节还剩122天 $nationalDay = mktime(0,0,0,10,1,2019); $currentDay = time(); $remainingDay = floor(abs($nationalDay - $currentDay)/(24*3600)); echo \"今天是\".date(\"Y-m-d\").\",距离国庆节还剩\".$remainingDay.\"天\"; strtotime : 将任何字符串的日期时间描述解析为 Unix 时间戳 场景 将英文日期解析成时间戳,比直接解析日期方便,采用自然语义而不是编程语言进行转换日期. 说明 本函数预期接受一个包含美国英语日期格式的字符串并尝试将其解析为 Unix 时间戳（自 January 1 1970 00:00:00 GMT 起的秒数,其值相对于 now 参数给出的时间,如果没有提供此参数则用系统当前时间. 常用格式 // 2019-06-02 echo date(\"Y-m-d\", strtotime(\"2019-05-31 +2 days\")); // 2019-07-01 echo date(\"Y-m-d\", strtotime(\"2019-05-31 +1 month\")); // 2019-06-09 echo date(\"Y-m-d\", strtotime(\"2019-05-31 +1 week 2 days 4 hours 2 seconds\")); 示例 // 设置当前时区为上海时区 date_default_timezone_set(\"Asia/Shanghai\"); // 获取当前时区 echo \"当前时区 : \".date_default_timezone_get().\"\"; // 当前日期时间戳 echo \"当前日期时间戳: \".time().\" \".strtotime(\"now\").\" \".date(\"Y-m-d H:i:s\", strtotime(\"now\")).\"\"; // 一周后的日期时间: 7 days; 24 hours; 60 mins; 60 secs $nextWeek = time() + (7 * 24 * 60 * 60); echo \"现在是\".date(\"Y-m-d H:i:s\").\",下周是\".date(\"Y-m-d H:i:s\",$nextWeek).\" \".date(\"Y-m-d H:i:s\",strtotime(\"+1 week\")).\"\"; echo \"现在是\".date(\"Y-m-d H:i:s\").\",1周2天4小时2秒是\".date(\"Y-m-d H:i:s\",strtotime(\"+1 week 2 days 4 hours 2 seconds\")).\"\"; echo \"现在是\".date(\"Y-m-d H:i:s\").\",下周三是\".date(\"Y-m-d H:i:s\",strtotime(\"next Thursday\")).\"\"; 日期时间函总结 日期时间函数库是 php 内置的函数库,默认情况下已启用,值得注意的是,日期时间和时区有关,建议首先设置下时区. 纵观日期时间的操作方法,总的来说,可以大致分为两类,一类是给计算机用的,另一类是给人看的. 给人看的 date_default_timezone_set(\"Asia/Shanghai\") : 设置当前脚本使用的时区 date(\"Y-m-d H:i:s\") : 格式化日期时间 date(\"Y-m-d\", strtotime(\"2019-05-31 +2 days\")) : 格式化英文描述的日期时间 给计算机用的 time() : 当前时间的秒数 microtime() : 当前时间的秒数和微秒数 strtotime() : 将字符串形式的日期时间转换成时间戳 最后,文档那么齐全,不懂就去多看看,忘记有啥方法全靠 ide 智能提示就好,多用用就会慢慢熟练. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/php/datetime-overview.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/":{"url":"go/","title":"go 学习笔记","keywords":"","body":"go 学习笔记 Go 是一种开源编程语言,可以轻松构建简单,可靠,高效的软件. Google 出品,必属精品,出身名门的 Go 语言天生支持并发,近年甚为流行. 诞生背景 为了解决 Google 在软件开发中遇到的困难,三位创始人开发出了 Go 语言,主要是以下问题: 多核硬件架构 超大规模的分布式计算集群 Web 模式导致的前所未有的开发规模和更新速度 这些也是广大的互联网公司遇到的问题,越来越多的国内公司也开始广泛使用 Go 语言开发,比如熟悉的Docker 和 K8s 也是 Go 语言开发的,也是 Go 语言被称为云端开发语言的原因之一. 语言特点 Go 语言是云计算时代的 C 语言也称为21 世纪的 C 语言,由此可见,Go 的地位非同一般. Go 语言的诞生是为了提高生产效率,专门对多处理器系统应用程序的编程进行了优化,使用Go编译的程序可以媲美C或C++代码的速度,而且更加安全,支持并行进程. 运行效率高,开发高效,部署简单. 运行效率高是因为编译性语言与解释性语言相比,开发高效是语法简单,部署简单是直接部署编译后的程序. 语言层面支持并发,易于利用多核实现并发. 不同于 php,只需要 go 配合 channel 即可完成进程或线程所做的工作. 内置 runtime 并支持垃圾回收 类似 Java 虚拟机支持垃圾回收,不必手动进行内存管理. 简单易学,丰富的标准库,强大的网络库. 学习成本低,语法简单但表达能力强,支持函数式编程,面向对象编程等多种编程范式. 内置强大的工具(gofmt),跨平台编译,内嵌C支持. 不同的人有不同的代码风格,可转化统一风格 知名应用 Docker : 是为开发人员构建和运行应用程序而构建的平台 https://www.docker.com/ Kubernetes : 自动化容器部署,扩展,管理的应用程序 https://kubernetes.io/ Etcd : 分布式键值对存储系统 https://etcd.io/ 学习文档 https://golang.org/ : The Go Programming Language https://golang.google.cn/ : The Go Programming Language https://tour.go-zh.org/welcome/1 : Go 语言之旅 https://studygolang.com/ : Go语言中文网- Golang中文社区 https://www.runoob.com/go/go-tutorial.html : Go 语言教程| 菜鸟教程 https://snowdreams1006.github.io/go/ : Go 学习笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/base/about.html":{"url":"go/base/about.html","title":"初识 go","keywords":"","body":"go 学习笔记 Go 是一种开源编程语言,可以轻松构建简单,可靠,高效的软件. 摘录自 github: https://github.com/golang/go,其中官网(国外): https://golang.org 和官网(国内): https://golang.google.cn/ Go 是 Google 公司推出的静态强类型,编译型,并发型,并具有垃圾回收功能的开源编程语言,最初由 Robert Griesemer , Rob Pike ,Ken Thompson 三人主持开发,后来陆续加入其他开发者,最终于 2009 年 11 月正式开源. 创始人都是大神 Go 的三位主要创始人分别是: 罗伯特·格瑞史莫(Robert Griesemer),和肯·汤普逊(Ken Thompson) 罗伯特·格瑞史莫(Robert Griesemer) JS V8 引擎,Chubby ,Java HotSpot 虚拟机,Sawzall 语言和 Strongtalk 系统 github: https://github.com/griesemer 罗勃·派克(Rob Pike) Plan 9 操作系统和UTF-8 编码 github: https://github.com/robpike 肯·汤普逊(Ken Thompson) UNIX 操作系统 ,Plan 9 操作系统,B 语言,UTF-8 编码 github: https://github.com/ken 如此厉害的三位大牛合作创作的 Go 语言还能差到哪里去呢? 吉祥物也很可爱 原来的 logo 是一只可爱的囊地鼠,英文名叫 gopher. 新的 logo 是现代化图标,代表更快更强,体现速度和效率. 网上流传甚广的一组很萌很可爱的吉祥物,并附上 github 链接: https://github.com/tenntenn/gopher-stickers 体验 go 语言魅力 案例一 fmt.Println(\"Hello, 世界\") : 输出字符串并换行 package main import \"fmt\" func main() { fmt.Println(\"Hello, 世界\") } 案例二 a, b = b, a : 互换变量a 和 b 的值,而其他语言一般都需要引入临时变量. package main import \"fmt\" func main() { var a = 3 var b = 4 fmt.Println(a, b) a, b = b, a fmt.Println(a, b) } 案例三 go + chan 关键字轻松完成并行计算 package main import ( \"fmt\" \"math\" ) func main() { fmt.Println(pi(5000)) } func pi(n int) float64 { ch := make(chan float64) for k := 0; k 到底好用不好用 Go 语言是云计算时代的 C 语言也称为21 世纪的 C 语言,由此可见,Go 的地位非同一般. Go 语言的诞生是为了提高生产效率,专门对多处理器系统应用程序的编程进行了优化,使用Go编译的程序可以媲美C或C++代码的速度,而且更加安全,支持并行进程. 运行效率高,开发高效,部署简单. 运行效率高是因为编译性语言与解释性语言相比,开发高效是语法简单,部署简单是直接部署编译后的程序. 语言层面支持并发,易于利用多核实现并发. 不同于 php,只需要 go 配合 channel 即可完成进程或线程所做的工作. 内置 runtime 并支持垃圾回收 类似 Java 虚拟机支持垃圾回收,不必手动进行内存管理. 简单易学,丰富的标准库,强大的网络库. 学习成本低,语法简单但表达能力强,支持函数式编程,面向对象编程等多种编程范式. 内置强大的工具(gofmt),跨平台编译,内嵌C支持. 不同的人有不同的代码风格,可转化统一风格 志同道合有几人 Docker : 是为开发人员构建和运行应用程序而构建的平台 https://www.docker.com/ Kubernetes : 自动化容器部署,扩展,管理的应用程序 https://kubernetes.io/ Etcd : 分布式键值对存储系统 https://etcd.io/ baidu-netdisk-downloaderx : 一款图形界面的百度网盘不限速下载器,支持 Windows , Linux 和 Mac https://github.com/b3log/baidu-netdisk-downloaderx pan-light : 百度网盘不限速客户端, golang + qt5, 跨平台图形界面 https://github.com/peterq/pan-light 自学技术哪家强 https://golang.org/ : The Go Programming Language https://golang.google.cn/ : The Go Programming Language https://tour.go-zh.org/welcome/1 : Go 语言之旅 https://studygolang.com/ : Go语言中文网- Golang中文社区 https://www.runoob.com/go/go-tutorial.html : Go 语言教程| 菜鸟教程 自问自答解疑惑 go 和 golang 是什么关系? go 是 golang 的简称,golang 是 go language 的缩写,即 go 语言. go 的常用 IDE 有哪些? 独立集成工具主要有 LiteIDE 和 GoLand 两种,但是常见 IDE 基本上均提供各种 Go 插件,支持 Windows ,MacOS 和 Linux 常见操作系统. go 的常见 Web 开发框架有哪些? Beego ,Iris 和 Gin 等,国人用的比较多是 Beego,目前资料也比较齐全. 无总结不成文章 Go 是 Google 出品的开源编程语言,出身名门注定不凡,并且拥有十分活跃的社区环境. 国内使用 Go 语言比较早的公司主要有七牛云和 beego,其中七牛云主要是云存储方面的业务,这也正是 Go 支持高并发分布式的特色,而 Beego 是 Go 的 Web 开发框架,支持 MVC 编程模型,不愧是国人开发深受国人喜爱. 同时,今年著名的 bilibili 源代码泄露事件也让我们看到了 Go 的身影,侧面说明了 Go 越来越流行,不愧是 21 世纪的 C 语言啊! 好了,暂时没有别的废话了,本文到此为止,下一章将开始介绍 Go 语言的环境搭建与 IDE 的基本配置,敬请期待. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/base/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/base/setup.html":{"url":"go/base/setup.html","title":"环境搭建","keywords":"","body":"环境搭建 千里之行始于足下,开始 Go 语言学习之旅前,首先要搭建好本地开发环境,然后就可以放心大胆瞎折腾了. Go 的环境安装和其他语言安装没什么特别注意之处,下载安装包下一步下一步直到完成,可能唯一需要注意的就是 $GOPATH 环境变量的设置问题. 不过,简单起见,目前采用默认配置,等到比较熟悉 Go 语言时候再自定义设置也不迟,因此采用喜闻乐见的傻瓜式安装方式吧! Go 下载安装 由于众所周知的原因,谷歌被墙,因此 Go 的国外官网无法访问,好在已提供 Go 的中国官网可以正常访问. 国外官网: https://golang.org/ 国内官网: https://golang.google.cn/ Go 语言中文网: https://studygolang.com/ 除了官网下载,也可以从第三方网站下载,一般速度比较快,下面就以 Windows 系统为例演示下载安装过程. 双击下载文件 go1.12.7.windows-amd64.msi 按照提示一直下一步直到安装完毕. 默认情况下 Go 安装到 C:\\Go 目录,同时设置了 $GOPATH 环境变量. 如果安装时没有采用默认配置而是自定义安装位置,那么应该自行设置后续相关环境变量. 默认情况下,安装 Go 语言后新增了 GOPATH 和 PATH 用户系统变量,同时修改了系统环境变量PATH . 默认情况下,Go 安装成功后发生了如下改变: 增加了用户变量: GOPATH=%USERPROFILE%\\go 增加了用户变量: PATH=%USERPROFILE%\\go\\bin 修改了系统变量: PATH=%PATH%;C:\\Go\\bin 其中 %USERPROFILE% 代表的是当前计算机登录用户的家目录,比如我的登录名是 snowdreams1006-win7,那么 %USERPROFILE% 表示的是 C 盘下的 Users 目录下的 snowdreams1006-win7 目录,即 %USERPROFILE%=C:\\Users\\snowdreams1006-win7 Go 测试验证 安装前命令行中输入 go 提示无命令,安装后再次输入 go 则能正确显示命令信息. 安装后必须新打开命令行窗口才能生效,go version 可以打印出 Go 的版本信息. $ go version go version go1.12.7 windows/amd64 上述命令行操作验证了 Go 语言本身已安装正确,其中 go env 展示了 Go 相关的环境变量,目前重要的变量有两个: GOROOT : Go 的安装目录,默认 GOROOT=c:\\go GOPATH : Go 的工作空间,默认 GOPATH=C:\\Users\\snowdreams1006-win7\\go,其中 C:\\Users\\snowdreams1006-win7 表示用户家目录. 上述两个变量都是安装后自动设置的,除非自定义安装位置才需要手动调整一系列的环境变量,作为初次接触 Go 语言,不建议瞎折腾,为时过早,目前只要记住这些目录的位置在哪就可以了. 任意目录下打开命令行窗口都能调用 Go 相关命令,比如 go version 和 go env ,这是因为安装 Go 时已自动追加了系统环境变量 PATH=%PATH%;C:\\Go\\bin,如果上述验证失败,记得修改环境变量 PATH 试试看! Mac 安装配置 点此下载并双击安装 go1.12.7.darwin-amd64.pkg ,同样傻瓜式下一步安装操作. snowdreams1006-mac11deMac:~ snowdreams1006$ go version go version go1.12.7 darwin/amd64 安装完毕后打开终端验证 Go 的基本命令是否正常,运行 go version 和 go env 查看基本配置信息. 运行命令的过程中可能会询问是否安装命令行开发者工具,按照提示默认安装即可. Go 安装小结 Go 语言安装来说比较简单,建议采用默认配置进行安装,这样不用操心各种环境变量的配置,否则一上来就暴露在 GOROOT,GOPATH 和 PATH 等诸多陌生概念之中,影响初学者搭建环境的信心,而且这些概念在刚开始并不会用到,未免有些操之过急. 所以,采用默认安装配置后,只要记住 Go 默认位置以及接下来在哪写 Go 程序的位置足矣! 测试是否安装成功,只需要在命令行窗口中运行 go version 能够输出 Go 的版本信息表示安装成功,否则可能安装失败. 查询 Go 的安装位置以及工作空间位置只需运行 go env 就能找到相应的 GOROOT 和 GOPATH 信息. 如果是 Windows 系统: Go 的默认安装位置(GOROOT): C:\\go Go 的默认工作空间(GOPATH): C:\\Users\\yourusername\\go 如果是 Mac 系统: Go 的默认安装位置(GOROOT): /usr/local/go Go 的默认工作空间(GOPATH): /Users/yourusername/go 搭建基本的语言环境是第一步,命令行操作虽然简单,不需要额外依赖,但实际工作中总不能一直在命令行中编写代码吧,还需要一个称心如意的 IDE 来辅助我们开发,下一节见! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/base/setup.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/base/workspace.html":{"url":"go/base/workspace.html","title":"工作空间","keywords":"","body":"工作空间 搭建好 Go 的基本环境后,现在可以正式开始 Go 语言的学习之旅,初学时建议在默认的 GOPATH 工作空间规范编写代码,基本目录结构大概是这个样子. . |-- bin | `-- hello.exe |-- pkg | `-- windows_amd64 | `-- github.com | `-- snowdreams1006 | `-- learn-go | `-- strings.a `-- src `-- github.com `-- snowdreams1006 `-- learn-go |-- README.md |-- hello | `-- hello.go `-- strings |-- reverse.go `-- reverse_test.go Go 相关的代码保存在工作空间中,而工作空间目录默认情况下是 GOPATH 环境变量所指向的目录(例如: GOPATH=C:\\Users\\snowdreams006-win7\\go). 工作空间下一般应包括三个一级子目录,分别是 src,pkg 和 bin 目录,其中最重要的就是 src 源码目录,其余两个目录都是派生目录. src 目录是源代码目录,是平时写代码的地方. pkg 目录是包对象目录,里面的文件大多以 .a 为后缀名,Go 工具自动处理,暂时不用关心. bin 目录是可执行命令目录,是最终产出的文件,例如 Windows 平台一般会生成 .exe 文件. 如果你刚刚安装 Go 语言或者不是默认形式安装的 Go,打开命令行窗口运行 go env 查看 GOPATH 那一项,GOPATH 指代的目录就是工作空间. 体验别人的 Go 命令 默认情况下,刚刚安装完毕的 Go 环境并不会自动创建工作空间目录,可以手动创建也可以运行别人的 Go 命令时顺便创建. snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 / # 初始时工作空间并未创建 $ ls $GOPATH ls: cannot access 'C:\\Users\\snowdreams1006-win7\\go': No such file or directory snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 / # 下载别人的 `Go` 命令顺便创建了工作空间 $ go get github.com/snowdreams1006/learn-go/hello snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 / # 已经按照标准目录结构创建完毕,目前有src和bin目录就足够了 $ ls $GOPATH bin/ src/ 运行完 go get github.com/snowdreams1006/learn-go/hello 命令后,工作空间目前已近乎标准目录. 如果 go get 命令半天没什么反应,不要着急,说不定正在下载,只是比较慢而已,如果想要看到下载过程,可以添加额外参数: go get -u -v 可以看出,go get 命令下载了 hello 命令所依赖的文件并生成 bin/hello.exe 可执行文件,现在终于可以说一声 Hello world! snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ hello !oG,olleH 这个是啥?怎么不是传说中的 Hello World ? 不管怎么说,创建工作空间的目的已经达到了,不是吗? 聪明的你,或许已经发现输出的语句的确不是 Hello World 而是 Hello Go 反过来写! 打造自己的 Go 命令 如果手头上没有 Go 项目或者说想要从零开发 Go 项目的话,那么只能手动创建工作空间了. 我们已经知道了工作空间的规范,但是现在涉及到自定义项目,同样需要确定项目的规范. 一般说来,项目需要唯一id用于区分其他可能出现的同名项目,也就是命名空间的概念. 作为个人开源项目,同广大的 Go 项目规范一样托管到 github.com 网站,因此命名空间 github.com/user 作为基本路径. 重要区别: Go 的命名空间(即基本路径)是域名正写: github.com/snowdreams1006,如果是其他语言,命名空间可能就是域名反写形式: com.github.snowdreams1006 . snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~ # 当前并未创建过工作空间 $ ls $GOPATH ls: cannot access 'C:\\Users\\snowdreams1006-win7\\go': No such file or directory snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~ # 在工作空间下创建 `learn-go` 项目 $ mkdir -p $GOPATH/src/github.com/snowdreams1006/learn-go/hello snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~ # 在 `learn-go` 项目下创建 `hello.go` 文件 $ vim $GOPATH/src/github.com/snowdreams1006/learn-go/hello/hello.go snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~ # `hello.go` 文件内容,输出 `Hello world` $ cat $GOPATH/src/github.com/snowdreams1006/learn-go/hello/hello.go package main import \"fmt\" func main() { fmt.Printf(\"Hello, world.\\n\") } 现在 Go 语言版的 Hello World 已经编写完毕,接下来让我们编辑输出并安装 hello 文件命令吧! 在命令行窗口运行 go install github.com/snowdreams1006/learn-go/hello 命令会在工作空间的 bin 目录下生成 hello.exe 可执行文件. 现在命令行窗口不负众望,输出了期待已久的 Hello World! 简单讲解下 Go 命令 无论是下载别人的远程代码还是自己从零编写代码,在命令行中都用到了相应命令,go get 和 go install 等. go get : 下载远程代码包,如果本地已安装,则执行逻辑退化为 go install. go install : 安装本地依赖包,如果本地没有相关依赖,则报错提示无法找到相关依赖包. 当然 Go 支持的常用命令远远不止这两个,直接输入 go 自然会提示有哪些命令可供使用,如果想要查询具体某一个命令的帮助文档,则输入 go help 即可,例如 go help get 这些命令比较简单,不用翻译也能猜出八九不离十,故此不浪费时间一一阐述. 下面直接上代码亲测运行一遍相关命令. go get 下载代码包 go get github.com/golang/example/hello 下载 Go 官方示例的 hello 代码包. snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ tree . |-- bin | `-- hello.exe `-- src `-- github.com `-- snowdreams1006 `-- learn-go `-- hello `-- hello.go 6 directories, 2 files snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ go get github.com/golang/example/hello snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ tree . |-- bin | `-- hello.exe `-- src `-- github.com |-- golang | `-- example | |-- LICENSE | |-- README.md | |-- appengine-hello | | |-- README.md | | |-- app.go | | |-- app.yaml | | `-- static | | |-- favicon.ico | | |-- index.html | | |-- script.js | | `-- style.css | |-- gotypes | | |-- Makefile | | |-- README.md | | |-- defsuses | | | `-- main.go | | |-- doc | | | `-- main.go | | |-- go-types.md | | |-- hello | | | `-- hello.go | | |-- hugeparam | | | `-- main.go | | |-- implements | | | `-- main.go | | |-- lookup | | | `-- lookup.go | | |-- nilfunc | | | `-- main.go | | |-- pkginfo | | | `-- main.go | | |-- skeleton | | | `-- main.go | | |-- typeandvalue | | | `-- main.go | | `-- weave.go | |-- hello | | `-- hello.go | |-- outyet | | |-- Dockerfile | | |-- containers.yaml | | |-- main.go | | `-- main_test.go | |-- stringutil | | |-- reverse.go | | `-- reverse_test.go | `-- template | |-- image.tmpl | |-- index.tmpl | `-- main.go `-- snowdreams1006 `-- learn-go `-- hello `-- hello.go 25 directories, 35 files snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ 原本 $GOPATH/src 源码目录只有我们自己的 github.com/snowdreams1006/learn-go 项目,获取远程 golang/hello 代码包后多了一大堆源码文件. 真的是神奇的操作,其余语言调用开源工具一般都是作为依赖放到非源码目录,Go 直接放到正在编写的源码目录,看起来第三方源码像是我们自己写的一样,只不过用命名空间区分开了而已! go test 测试代码包 Go 自带轻量级的测试框架,测试文件命名是 xxx_test.go ,文件内的方法签名是 TestXXX . go test github.com/golang/example/stringutil 测试 stringutil 代码包,是因为包内存在测试文件 reverse_test.go snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ go test github.com/golang/example/stringutil ok github.com/golang/example/stringutil 0.342s go install 安装代码包 go install github.com/golang/example/hello 安装代码包,运行可执行文件 hello 输出 Hello, Go examples! snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ go install github.com/golang/example/hello snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go $ hello Hello, Go examples! go build 编译代码包 上述命令我们都是在 golang/example 项目下进行演示的,不能厚此薄彼,下面这两个命令还是演示我们自己手写的 hello 命令文件吧! 首先切换到 hello 目录下,这样省的输入一长串的路径,在当前目录下运行 go 命令可以省略文件路径. snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go # 切换到 `learn-go` 项目的 `hello` 目录 $ cd $GOPATH/src/github.com/snowdreams1006/learn-go/hello snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/earn-go/hello $ ls hello.go snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/earn-go/hello # go build 省略文件路径表示在当前目录下进行编译,输出文件也是当前目录下 $ go build snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/earn-go/hello $ ls hello.exe* hello.go snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/earn-go/hello # 此时直接运行 `hello` 命令,运行的的是 `$GOPATH/bin` 目录下的命令而不是当前目录下的 `hello` $ hello Hello, Go examples! snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/learn-go/hello $ ./hello Hello, world. 上述演示结果,展示了切换到当前目录下可以直接省略代码包路径,默认输出的可执行文件也由原先的 $GOPATH/bin 目录变成当前目录. 直接运行 hello 命令输出的结果是原先的 $GOPATH/bin/hello 命令而不是当前目录下的 hello,至于为什么如此,暂时不太理解. 当然想要运行当前目录下的 hello.exe 命令文件也很简单,指定路径即可: ./hello go run 运行代码包 go build 命令或者 go install 命令都会生成可执行二进制文件,然后运行该二进制文件才能输出命令结果. go run 就是一步到位的命令,不用生成文件直接输出命令的执行结果,有时候这种方式也很有用! snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/learn-go/hello $ ls hello.go snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/learn-go/hello $ go run hello.go Hello, world. snowdreams1006-win7@WIN-FANS2DDDB06 MINGW64 ~/go/src/github.com/snowdreams1006/learn-go/hello $ ls hello.go 值得注意的是,go run 后面紧跟着的是文件名,不能像 go build 那样省略包路径,否则会报错. Go 基本环境小结 默认安装的 Go 省心省力,自动帮我们设置好相关的环境变量,至于这些变量是干嘛用的以及怎么自定义修改,建议初学时不要深究,先搭建好基本的开发环境再说. go env 命令可以输出 Go 的相关配置信息,GOROOT 是 Go 的安装目录,GOPATH 是 Go 的工作空间目录,这是 Go 本身最基本的配置信息. 如果不太了解这部分内容,可以翻看上一篇文章,这里就不详细阐述了. Go 的工作空间下面有 src ,bin 和 pkg 三个平行目录,其中 src 下面才是我们真正编写代码的目录. Go 语言相关的项目既然都放在 src 目录下就有一定的命名规范,参考 github.com/snowdreams1006/learn-go 和 github.com/golang/example 这种形式. 测试 Go 语言的安装环境以及进行简单的命令验证,这些操作本身比较简单,用不着强大的 IDE ,但是学习 Go 语言如果没有 IDE 的辅助,那么很难想象会是什么样的局面. 因此,下一节将开始介绍 Go 开发的 IDE 环境配置,感觉离工程化开发又迈进一步呢! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/base/workspace.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/base/ide.html":{"url":"go/base/ide.html","title":"IDE编辑器","keywords":"","body":"IDE编辑器 工欲善其事必先利其器,命令行工具虽然能够在一定程度上满足基本操作的需求,但实际工作中总不能一直使用命令行工具进行编码操作吧? 学习 Go 语言同样如此,为此需要寻找一个强大的 IDE 集成环境帮助我们快速开发,据我所知,市面上比较流行的可能有三个选择: LiteIDE X : LiteIDE 是一款简单,开源,跨平台的 Go IDE. GoLand : GoLand is a cross-platform IDE built specially for Go developers. 第三方插件 : Idea, Sublime Text,VS Code ,等常见 IDE 一般均有 Go 的插件. 萝卜青菜各有所爱,选择哪个 IDE 都可以,甚至不用任何 IDE 也可以,不过还是推荐下 GoLand 吧! Goland 下载安装 官网地址: https://www.jetbrains.com/go/,如果无法访问,可能需要特殊手段绕过. Goland 并不像 Idea 那样分为专业版和社区版,目前只有收费版,提供 30 天免费试用,试用到期后可以选择购买正版也可以上淘宝购买激活码或网上寻求破解版等等. 直接点击页面中间的 Download 按钮后就会自动识别当前系统进行下载,也可以点击右上角的 Download 按钮自行选择目标平台进行下载. 安装过程比较简单,这里就不再赘述,简单的动图一闪而过看下大致过程吧! 其中安装位置,默认是 C 盘,可以自行选择合适的安装位置. 如果是 Mac 电脑,安装 Goland 更为简单,直接下载拖动到 Application 分类,连安装目录都不用选择,简单演示如下: Goland 克隆项目 初次打开 Goland 编辑器,界面出现三个选项: New Project : 新建项目,适合从零开发新项目 Open Project : 打开项目,适合本地已存在 Go 项目 Check out from Version Control : 从版本库中检出项目,适合团队合作时直接从线上项目下载到本地. 三种方式分别对应三种不同的场景,这里选择以第三种方式检出版本库为例,目录源码: https://github.com/snowdreams1006/learn-go 选择 git 版本库,并填写项目地址,然后点击右侧的 Test 按钮,如果提示失败,可能是 Git 基本环境没有配置过,请先配置下 Git,可以参考 git 入门教程 项目地址: git@github.com:snowdreams1006/learn-go.git 或者 https://github.com/snowdreams1006/learn-go.git 或者 https://github.com/snowdreams1006/learn-go 默认情况下,本地目录是 GolandProjects,一定要修改成自己的 GOPATH 目录,即 USERPROFILE/go 目录. 耐心等待,Goland 会自动下载项目相关依赖,右下角的进度条完毕后意味着项目初始化好了,可以正常工作了. Goland 打开项目 找到 hello/hello.go 文件,其中 main 方法左侧有个绿色的启动按钮,点击运行. 初始运行,提示配置进行命令配置,设置工作目录为 GOPATH 环境变量所在的目录. 此时配置页面左下角的红色报错消失了,保存后关闭该窗口,再次运行 main 方法,如我们所愿输出了 Hello Go! 的逆序. 现在打开 strings/reverse_test.go 文件,同样点击左侧的启动按钮运行测试文件,证明测试运行正常! Goland 配置总结 万事开头难,下载 Goland 并初始化项目,其实很简单,之所以特意写下这篇文章主要是为了克服陌生的恐惧,迈出第一步就会有第二步,接下来的 Go 语言学习之旅就可以顺利开始了,Go to Work ! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/base/ide.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/base/var-and-const.html":{"url":"go/base/var-and-const.html","title":"你好,Go","keywords":"","body":"变量和常量 首先希望学习 Go 语言的爱好者至少拥有其他语言的编程经验,如果是完全零基础的小白用户,本教程可能并不适合阅读或尝试阅读看看,系列笔记的目标是站在其他语言的角度学习新的语言,理解 Go 语言,进而写出真正的 Go 程序. 编程语言中一般都有变量和常量的概念,对于学习新语言也是一样,变量指的是不同编程语言的特殊之处,而常量就是编程语言的共同点. 学习 Go 语言时尽可能站在宏观角度上分析变量,而常量可能一笑而过或者编程语言不够丰富,所谓的常量其实也是变量,不管怎么样现在让我们开始 Go 语言的学习之旅吧,本教程涉及到的源码已托管于 github,如需获取源码,请直接访问 https://github.com/snowdreams1006/learn-go 编写第一个 Hello World 程序 学习编程语言的第一件事就是编写出 Hello World,现在让我们用 Go 语言开发出第一个可运行的命令行程序吧! 环境前提准备可以参考 走进Goland编辑器 新建 main 目录,并新建 hello_world.go 文件,其中文件类型选择 Simple Application ,编辑器会帮助我们创建 Go 程序骨架. 首先输入 fmt 后触发语法提示选择 fmt.Println ,然后会自动导入 fmt 包. 完整内容如下,仅供参考: package main import \"fmt\" func main() { fmt.Println(\"Hello World\") } 点击左侧绿色启动按钮,可以直接运行程序或者利用程序自带的 Terminal 终端选项卡运行程序,当然也可以用外部命令行工具运行程序. go run 命令直接运行,而 go build 命令产生可执行文件,两种方式都能如愿以偿输出 Hello World . 知识点归纳 Go 应用程序入口的有以下要求: 必须是 main 包 :package main 必须是 main 方法 : func main() 文件名任意不一定是 main.go,目录名也任意不一定是 main 目录. 以上规则可以很容易在编辑器中得到验证,任意一条不符合规则,程序都会报错提示,这也是使用编辑器而不是命令行进行学习的原因,能够帮助我们及时发现错误,方便随时验证猜想. 总结来说,main 包不一定在 main 目录下,main 方法可以在任意文件中. 这也意味着程序入口所在的目录不一定叫做 main 目录却一定要声明为 main 包,虽然不理解为什么这么设计,这一点至少和 Java 完全不一样,至少意味着 Go文件可以直接迁移目录而不需要语言层面的重构,可能有点方面,同时也有点疑惑?! main 函数值得注意的不同之处: main 函数不支持返回值,但可以通过 os.Exit 返回退出状态 main 函数,不支持返回值,若此时强行运行 main 方法,则会报错: func main must have no arguments and no return values main 函数可以借助 os.Exit(-1) 返回程序退出时状态码,外界可以根据不同状态码识别相应状态. main 函数不支持传入参数,但可以通过 os.Args 获取参数 在 Terminal 终端选项卡中运行 go run hello_world.go snowdreams1006 命令 os.Args 输出命令路径和参数值. 在测试用例中边学边练基础语法 The master has failed more times than the beginner has tried 计算机编程不是理科而是工科,动手亲自实践一遍才能更好地掌握知识技能,幸运的是,Go 语言本身内置提供了测试框架,不用加载第三方类库扩展,非常有利于学习练习. 刚刚接触 Go 语言,暂时不需要深入讲解如何编写规范的测试程序,毕竟基础语法还没开始正式练习呢! 但是,简单的规则还是要说的,总体来说,只有两条规则: 测试文件名以 _test 结尾 : XXX_test.go 命令习惯和不同, Java 中的文件名一般是大驼峰命名法,相应的测试文件是 XXXTest 测试方法名以 Test 开头 : TestXXX 命名习惯和其他编程语言不同,Java 中的测试方法命名是一般是小驼峰命名法,相应的测试方法是 testXXX 测试方法有着固定的参数 : t *testing.T 其他编程语言中一般没有参数,Java 中的测试方法一定没有参数,否则抛出异常 java.lang.Exception: Method testXXX should have no parameters 新建 Go 文件,类型选择 Empty File ,文件名命名为 hello_world_test ,编辑器新建一个空白的测试文件. 此时编写测试方法签名,利用编辑器自动提示功能输入 t.Log 随便输出些内容,这样就完成了第一个测试文件. 和 main 程序一样,测试方法也是可执行的,编辑器窗口的左侧也会出现绿色启动按钮,运行测试用例在编辑器下方的控制台窗口输出 PASS 证明测试逻辑正确! 测试文件源码示例: package main import \"testing\" func TestHelloWorld(t *testing.T){ t.Log(\"Hello Test\") } 现在已经学习了两种基本方式,一种是把程序写在 main 方法中,另一种是把程序写在测试方法中. 两种方式都可以随时测试验证我们的学习成果,如果写在 main 方法中,知识点一般要包装成单独的方法,然后再在 main 方法中运行该方法. 如果写在测试方法中,可以单独运行测试方法,而不必在 main 方法中一次性全部运行. 当然,这两种方式都可以,只不过个人倾向于测试用例方式. 实现 Fibonacci 数列 形如 1,1,2,3,5,8,13,... 形式的数列就是斐波那契数列,特点是从三个元素开始,下一个元素的值就是前两两个元素值的总和,子子孙孙无穷尽也! 记得学习初中历史时,关于昭君出塞的故事广为人知,王昭君的美貌不是此次讨论的重点,而此次关注点是放到了昭君的悲惨人生. 汉朝和匈奴和亲以换取边境和平,汉朝皇帝不愿意自己的亲闺女远嫁塞北,于是从后宫中挑选了一名普通宫女充当和亲对象,谁成想这名宫女竟长得如此美貌,\"沉鱼落雁闭月羞花\",堪称古代中国四大美女之一! 昭君担负着和亲重任,从此开始了远离他乡的悲惨生活,一路上,黄沙飞扬,燥热忧伤,情之所至,昭君拿出随性的琵琶,演奏出感人泪下的>! \"千载琵琶作胡语,分明怨恨曲中论\",可能情感过于哀伤,竟然连天上的大雁都忘记了飞翔,因此收获落雁之美! 老单于这个肥波纳了个如花似玉的妾,做梦都能了醒吧,遗憾的是,命不久矣! 如此一来,昭君却满心欢喜,异族老公死了,使命完成了,应该能回到朝思梦想的大汉朝故土了吧? 命运弄人,匈奴文化,父死子继,肥波已逝,但还有小肥波啊,放到汉朝伦理纲常来看,都不能叫做近亲结婚了简直是乱伦好吗! 小肥波+昭君=小小肥波 ,只要昭君不死,而昭君的现任老公不幸先死,那么小小肥波又会继续纳妾生娃,理论上真的是子子孙孙无穷尽也! 肥波纳妾故事可能长成这个样子: 肥波,昭君,小肥波 昭君的第一任老公: 肥波+昭君=小肥波,此时昭君刚生一个娃 肥波,小肥波,昭君,小小肥波 昭君的第二任老公: 小肥波+昭君=小小肥波,昭君的娃娶了自己的妈?难怪昭君苦楚悲惨,有苦难言,幸运的是,这次昭君没有生娃,两个女孩! 肥波,小肥波,小小肥波,昭君 昭君的第三任老公,小小肥波+昭君=小小小肥波 ,兄终弟及,还是乱伦好吗,这辈分我是算不出来了. 肥波纳妾系列,理论上和愚公移山有的一拼,生命不息,子承父业也好,兄终弟及也罢,数量越来越多,肚子越来越大. 以上故事,纯属虚构,昭君出塞是一件伟大的事情,换来了百年和平,值得尊敬. 回归正题,下面让我们用 Go 语言实现斐波那契数列吧! func TestFib(t *testing.T) { var a = 1 var b = 1 fmt.Print(a) for i := 0; i 上述简单示例,展示了变量的基本使用,简单总结如下: 变量声明关键字用 var ,类型名在前,变量类型在后,其中变量类型可以省略. // 声明变量a和变量b var a = 1 var b = 1 上述变量语法咋一看像是 Js 赋值,严格来说其实并不是那样,上面变量赋值形式只是下面这种的简化 // 声明变量a并指定类型为 int,同理声明变量b并指定类型为int var a int = 1 var b int = 1 第一种写法省略了 int 类型,由赋值 1 自动推断为 int 在一定程度上简化了书写,当然这种形式还可以继续简化. // 省略相同的 var,增加一对小括号 (),将变量放到小括号里面 var ( a = 1 b = 1 ) 可能问,还能不能继续简化下,毕竟其余语言的简化形式可不是那样的,答案是可以的! // 连续声明变量并赋值 var a, b = 1, 1 当然,其余语言也有类似的写法,这并不值得骄傲,下面这种形式才是 Go 语言特有的精简版形式. // 省略了关键字var,赋值符号=改成了:=,表示声明变量并赋值 a, b := 1, 1 就问你服不服?一个小小的变量赋值都能玩出五种花样,厉害了,我的 Go ! 变量类型可以省略,由编译器自动进行类型推断 类似 Js 的书写习惯,但本质上仍然是强类型,不会进行不同类型的自动转换,还会说像 Js 的变量吗? 同一个变量语句可以对不同变量进行同时赋值 仍然以斐波那契数列为例,Go 官网的示例中使用到的就是变量同时赋值的特性,完整代码如下: package main import \"fmt\" // fib returns a function that returns // successive Fibonacci numbers. func fib() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } func main() { f := fib() // Function calls are evaluated left-to-right. fmt.Println(f(), f(), f(), f(), f()) } 如果对该特性认识不够清晰,可能觉得这并不是什么大不了的事情嘛! 实际上,俗话说,没有对比就没有伤害,举一个简单的例子: 交换变量 func TestExchange(t *testing.T) { a, b := 1, 2 t.Log(a,b) a, b = b, a t.Log(a,b) temp := a a = b b = temp t.Log(a,b) } 其他语言中如果需要交换两个变量,一般都是引入第三个临时变量的写法,而 Go 实现变量交换则非常简单清晰,也符合人的思考而不是计算机的思考. 虽然不清楚底层会不会仍然是采用临时变量交换,但不管怎么说,使用该特性交换变量确实很方便! 同时对多个变量进行赋值是 Go 特有的语法,其他语言可以同时声明多个变量但不能同时赋值. 常量同样很有意思,也有关键字声明 const. 有些编程语言对常量和变量没有强制规定,常量可以逻辑上被视为不会修改的变量,一般用全大写字母提示用户是常量,为了防止常量被修改,有的编程语言可能会有额外的关键字进行约束. 幸运的是,Go 语言的常量提供了关键字 const 约束,并且禁止重复赋值,这一点很好,简单方便. func TestConst(t *testing.T) { const pi = 3.14 t.Log(pi) // cannot assign to pi pi = 2.828 t.Log(pi) } 除了语言层面的 const 常量关键字,Go 语言还要一个特殊的关键字 iota ,常常和常量一起搭配使用! 当设置一些连续常量值或者有一定规律的常量值时,iota 可以帮助我们快速设置. func TestConstForIota(t *testing.T) { const ( Mon = 1 + iota Tue Wed Thu Fri Sat Sun ) // 1 2 3 4 5 6 7 t.Log(Mon, Tue, Wed, Thu, Fri, Sat, Sun) } 大多数编程语言中,星期一代表的数字几乎都是 0,星期二是 1,以此类推,导致和传统认识上偏差,为了校准偏差,更加符合国人习惯,因此将星期一代表的数字 0 加一,以此类推,设置初始 iota 后就可以剩余星期应用该规律,依次 1,2,3,4,5,6,7 如果不使用 iota 的话,可能需要手动进行连续赋值,比较繁琐,引入了 iota 除了帮助快速设置,还可以进行比特位级别的操作. func TestConstForIota(t *testing.T) { const ( Readable = 1 第一位比特位为 1 时,表示文件可读,第二位比特位为 1 时,表示可写,第三位比特位为 1 时,表示可执行,相应的 10 进制数值依次为 1,2,4 也就是左移一位,左移两位,左移三位,数学上也可以记成 2^0,2^1,2^2 . 文件的可读,可写,可执行三种状态代表了文件的权限状态码,从而实现了文件的基本权限操作,常见的权限码有 755 和 644. 按位与 & 运算与编程语言无关,\"两位同时为 1 时,按位与的结果才为 1 ,否则结果为 0 \",因此给定权限码我们可以很方便判断该权限是否拥有可读,可写,可执行等权限. // 0111 即 7,表示可读,可写,可执行 accessCode := 7 t.Log(accessCode&Readable == Readable, accessCode&Writing == Writing, accessCode&Executable == Executable) // 0110 即 6,表示不可读,可写,可执行 accessCode = 6 t.Log(accessCode&Readable == Readable, accessCode&Writing == Writing, accessCode&Executable == Executable) // 0100 即 4,表示不可读,不可写,可执行 accessCode = 4 t.Log(accessCode&Readable == Readable, accessCode&Writing == Writing, accessCode&Executable == Executable) // 0000 即 0,表示不可读,不可写,不可执行 accessCode = 0 t.Log(accessCode&Readable == Readable, accessCode&Writing == Writing, accessCode&Executable == Executable) accessCode&Readable 表示目标权限码和可读权限码进行按位与运算,而可读权限码的二进制表示值为 0001 ,因此只要目标权限码的二进制表示值第一位是 1 ,按位与的结果肯定是 0001 ,而 0001 又刚好是可读权限码,所以 accessCode&Readable == Readable 为 true 就意味着目标权限码拥有可读权限. 如果目标权限码的二进制位第一个不是 1 而是 0,则 0&1=0 ,(0|1)^0=0,所以按位与运算结果肯定全是 0 即 0000,此时 0000 == 0001 比较值 false ,也就是该权限码不可读. 同理可自主分析,accessCode&Writing == Writing 结果 true 则意味着可写,否则不可写,accessCode&Executable == Executable 结果 true 意味着可执行,false 意味着不可执行. 熟悉了 iota 的数学计算和比特位计算后,我们趁热打铁,用文件大小单位继续练习! func TestConstForIota(t *testing.T) { const ( B = 1 字节 Byte 与 千字节 Kilobyte 之间的进制单位是 1024 ,也就是 2^10 ,刚好可以用 iota 左移 10 位来表示,一次只移动一次,直接乘以 10 就好了! 怎么样,iota 是不是很神奇?同时是不是和我一样也有点小困惑,iota 这货到底是啥? 百度翻译给我们的解释是,这货表示\"微量\",类似英语单词的 little 一样,a little 也表示\"一点点\". 但是 iota 除了表示一点点之外,好像还拥有自增的能力,这可不是 little 这种量词能够传达的意思. 因此,有可能 iota 并不是原始英语含义,说不定是希腊字母的语言,查询了标准的 24 个希腊字母表以及对应的英语注释. 大写 小写 英文读音 国际音标 意义 Α α alpha /ˈælfə/ 角度,系数,角加速度 Β β beta /'beitə/ 磁通系数,角度,系数 Γ γ gamma /'gæmə/ 电导系数,角度,比热容比 Δ δ delta /'deltə/ 变化量,屈光度,一元二次方 Ε ε epsilon /ep'silon/ 对数之基数,介电常数 Ζ ζ zeta /'zi:tə/ 系数,方位角,阻抗,相对粘度 Η η eta /'i:tə/ 迟滞系数,效率 Θ θ theta /'θi:tə/ 温度,角度 Ι ι ℩ iota /ai'oute/ 微小,一点 Κ κ kappa /'kæpə/ 介质常数,绝热指数 ∧ λ lambda /'læmdə/ 波长,体积,导热系数 Μ μ mu /mju:/ 磁导系数,微动摩擦系(因)数,流体动力粘度 Ν ν nu /nju:/ 磁阻系数,流体运动粘度,光子频率 Ξ ξ xi /ksi/ 随机数,(小)区间内的一个未知特定值 Ο ο omicron /oumaik'rən/ 高阶无穷小函数 ∏ π pi /pai/ 圆周率,π(n)表示不大于n的质数个数 Ρ ρ rho /rou/ 电阻系数,柱坐标和极坐标中的极径,密度 ∑ σ ς sigma /'sigmə/ 总和,表面密度,跨导,正应力 Τ τ tau /tau/ 时间常数,切应力 Υ υ upsilon /ju:p'silən/ 位移 Φ φ phi /fai/ 磁通,角,透镜焦度,热流量 Χ χ chi /kai/ 统计学中有卡方(χ2)分布 Ψ ψ psi /psai/ 角速,介质电通量 Ω ω omega /'oumigə/ 欧姆,角速度,交流电的电角度 希腊字母常常用于物理,化学,生物,科学等学科,作为常量或者变量,不同于一般的英语变量或常量的是,希腊字母表示的变量或常量一般具有特定的语义! 因此,iota 应该是希腊字母 I 的英语表示,该变量或者说常量表示微小,一点的含义. 翻译成自然语言就是,这个符号表示一点点,如果表达改变的含义,那就是在原来基础上多那么一点点,如果表达不改变的含义,应该是只有一点点,仅此而已. 当然,以上均是个人猜测,更加专业的说法还是应该看下 Go 语言如何定义 iota ,按住 Ctrl 键,鼠标悬停在 iota 上可以点击进入源码部分,如下: // iota is a predeclared identifier representing the untyped integer ordinal // number of the current const specification in a (usually parenthesized) // const declaration. It is zero-indexed. const iota = 0 // Untyped int. 简短翻译: iota 是预定义标识符,代表当前常量中无符号整型的序号,是以 0 作为索引的. 上述注释看起来晦涩难懂,如果是常量那就就安安静静当做常量,不行吗?怎么从常量定义中还读出了循环变量索引的味道? 为了验证猜想,仍然以最简单的星期转换为例,模拟每一步时的 iota 的值. const ( // iota = 0,Mon = 1 + 0 = 1,符合输出结果 1,此时 iota = 1,即 iota 自增1 Mon = 1 + iota // iota = 1,Tue = 1 + iota = 1 + 1 = 2,符合输出结果 2,此时 iota = 2 Tue // iota = 2,Wed = 1 + iota = 1 + 2 = 3,符合输出结果 3,此时 iota = 3 Wed Thu Fri Sat Sun ) // 1 2 3 4 5 6 7 t.Log(Mon, Tue, Wed, Thu, Fri, Sat, Sun) 上述猜想中将 iota 当做常量声明循环中的变量 i,每声明一次,i++,因此仅需要定义循环初始条件和循环自增变量即可完成循环赋值. const ( Mon = 1 + iota Tue Wed Thu Fri Sat Sun ) // 1 2 3 4 5 6 7 t.Log(Mon, Tue, Wed, Thu, Fri, Sat, Sun) var days [7]int for i := 0; i 这样对应是不是觉得 iota 似乎就是循环变量的 i,其中 Mon = 1 + iota 就是循环初始体,Mon~Sun 有限常量就是循环的终止条件,每一个常量就是下一次循环. 如果一个例子不足以验证该猜想的话,那就再来一个! const ( Readable = 1 上述两个例子已经初步验证 iota 可能和循环变量 i 具有一定的关联性,还可以进一步接近猜想. const ( // iota=0 const=1+0=1 iota=0+1=1 first = 1 + iota // iota=1 const=1+1=2 iota=1+1=2 second // iota=2 const=2+2=4 iota=2+1=3 third = 2 + iota // iota=3 const=2+3=5 iota=3+1=4 forth // iota=4 const=2*4=8 iota=4+1=5 fifth = 2 * iota // iota=5 const=2*5=10 iota=5+1=6 sixth // iota=6 const=6 iota=6+1=7 seventh = iota ) // 1 2 4 5 8 10 6 t.Log(first, second, third, forth, fifth, sixth, seventh) const currentIota = iota // 0 t.Log(currentIota) var rank [7]int for i := 0; i iota 是一组常量初始化中的循环变量索引,当这一组变量全部初始化完毕后,iota 重新开始计算,因此新的变量 currentIota 的值为 0 而不是 7 因此,iota 常常用作一组有规律常量的初始化背后的原因可能就是循环变量进行赋值,按照这个思路理解前面关于 iota 的例子暂时是没有任何问题的,至于这种理解是否准确,有待继续学习 Go 作进一步验证,一家之言,仅供参考! 变量和常量的基本小结 变量用 var 关键字声明,常量用 const 关键字声明. 变量声明并赋值的形式比较多,使用时最好统一一种形式,避免风格不统一. 变量类型具备自动推断能力,但本质上仍然是强类型,不同类型之间并不会自动转换. 一组规律的常量可以用 iota 常量进行简化,可以暂时理解为采用循环方式对变量进行赋值,从而转化成常量的初始化. 变量和常量都具有相似的初始化形式,与其他编程语言不同之处在于一条语句中可以对多个变量进行赋值,一定程度上简化了代码的书写规则. 任何定义但未使用的变量或常量都是不允许存在的,既然用不着,为何要声明?!禁止冗余的设计,好坏暂无法评定,既然如何设计,那就遵守吧! 与众不同的变量和常量 斐波那契数列是一组无穷的递增数列,形如 1,1,2,3,5,8,13... 这种从第三个数开始,后面的数总是前两个数之和的数列就是斐波那契数列. 如果从第三个数开始考虑,那么前两个数就是斐波那契数列的起始值,以后的数字都符合既定规律,取前两个数字当做变量 a,b 采用循环的方式不断向后推进数列得到指定长度的数列. func TestFib(t *testing.T) { var a int = 1 var b int = 1 fmt.Print(a) for i := 0; i 虽然上述解法比较清晰明了,但还不够简洁,至少没有用到 Go 语言的特性.实际上,我们还可以做得更好,或者说用 Go 语言的特性来实现更加清晰简单的解法: func TestFibSimplify(t *testing.T) { a, b := 0, 1 for i := 0; i 和第一种解法不同的是,这一次将变量 a 向前移一位,人为制造出虚拟头节点 0,变量 a 的下一个节点 b 指向斐波那契数列的第一个节点 1,随着 a 和 b 相继向后推进,下一个循环中的节点 b 直接符合规定,相比第一种解法缩短了一个节点. a, b := 0, 1 是循环开始前的初始值,b 是斐波那契数列中的第一个节点,循环进行过程中 a, b = b, a+b 语义非常清楚,节点的 a 变成节点 b,节点 b 是 a+b 的值. 是不是很神奇,这里既没有用到临时变量存储变量 a 的值,也没有发生变量覆盖的情况,直接完成了变量的交换赋值操作. 由此可见, a, b = b, a+b 并不是 a=b 和 b=a+b 的执行结果的累加,而是同时完成的,这一点有些神奇,不知道 Go 是如何实现多个变量同时赋值的操作? 如果有小伙伴知道其中奥妙,还望不吝赐教,大家一起学习进步! 如果你觉得上述操作有点不好理解,那么接下来的操作,相信你一定会很熟悉,那就是两个变量的值进行交换. func TestExchange(t *testing.T) { a, b := 1, 2 t.Log(a, b) a, b = b, a t.Log(a, b) temp := a a = b b = temp t.Log(a, b) } 同样的是,a, b = b, a 多变量同时赋值直接完成了变量的交换,其他编程语言实现类似需求一般都是采用临时变量提前存储变量 a 的值以防止变量覆盖,然而 Go 语言的实现方式竟然和普通人的思考方式一样,不得不说,这一点确实不错! 通过简单的斐波那契数列,引入了变量和常量的基本使用,以及 Go 的源码文件相应规范,希望能够带你入门 Go 语言的基础,了解和其它编程语言有什么不同以及这些不同之处对我们实际编码有什么便捷之处,如果能用熟悉的编程语言实现 Go 语言的设计思想也未曾不是一件有意思的事情. 下面,简单总结下本文涉及到的主要知识点,虽然是变量和常量,但重点并不在如何介绍定义上,而是侧重于特殊之处以及相应的实际应用. 源码文件所在的目录和源码文件的所在包没有必然联系,即 package main 所在的源码文件并不一定在 main 目录下,甚至都不一定有 main 目录. hello.go 源码文件位于 hello 目录下,而 hello_word.go 位于 main 目录下,但是他们所在的包都是 package main 源码文件命名暂时不知道有没有什么规则,但测试文件命名一定是 xxx_test,测试方法命名是 TestXXX ,其中 Go 天生支持测试框架,不用额外加载第三方类库. 声明变量的关键字是 var,声明常量的关键字是 const,无论是变量还是常量,均存在好几种声明方式,更是存在自动类型推断更可以进行简化. 一般而言,实现其它编程语言中的全局变量声明用 var,局部变量声明 := 简化形式,其中多个变量可以进行同时赋值. 一组特定规律的常量值可以巧用 iota 来实现,可以理解为首次使用 iota 的常量是这组常量规律的第一个,其余的常量按照该规律依次初始化. Go 语言没有枚举类,可以用一组常量值实现枚举,毕竟枚举也是特殊的常量. 本文源码已上传到 https://github.com/snowdreams1006/learn-go 项目,感兴趣的小伙伴可以点击查看,如果文章中有描述不当之处,恳请指出,谢谢你的评论和转发. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/base/var-and-const.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/base/grammar.html":{"url":"go/base/grammar.html","title":"基础语法","keywords":"","body":"基础语法 在上篇文章中,我们动手亲自编写了第一个 Go 语言版本的 Hello World,并且认识了 Go 语言中有意思的变量和不安分的常量. 相信通过上篇文章的斐波那契数列,你已经初步掌握了 Go 语言的变量和常量与其他主要的编程语言的异同,为了接下来更好的学习和掌握 Go 的基础语法,下面先简单回顾一下变量和常量相关知识. 有意思的变量和不安分的常量 变量默认初始化有零值 func TestVariableZeroValue(t *testing.T) { var a int var s string // 0 t.Log(a, s) // 0 \"\" t.Logf(\"%d %q\", a, s) } int 类型的变量初始化默认零值是零 0,string 类型的变量默认初始化零值是空字符串 ,其他类型也有相应的零值. 多个变量可以同时赋值 func TestVariableInitialValue(t *testing.T) { var a, b int = 1, 2 var s string = \"hello Go\" // 1 2 hello Go t.Log(a, b, s) } 其他主要的编程语言大多支持多个变量初始化,但极少数有像 Go 语言这样,不仅支持同时初始化,还可以同时赋值. 多个变量可以用小括号 () 统一定义 func TestVariableShorter(t *testing.T) { var ( a int = 1 b int = 2 s string = \"hello go\" ) // 1 2 hello Go t.Log(a, b, s) } 用小括号 () 方式,省略了相同的 var 关键字,看起来更加统一 变量类型可以被自动推断 func TestVariableTypeDeduction(t *testing.T) { var a, b, s = 1, 2, \"hello Go\" // 1 2 hello Go t.Log(a, b, s) } Go 语言可以根据变量值推测出变量类型,所以可以省略变量类型,再一次简化了变量定义,但是变量类型仍然是强类型,并不像 Js 那样的弱类型. 变量可以用 := 形式更加简化 func TestVariableTypeDeductionShorter(t *testing.T) { a, b, s := 1, 2, \"hello Go\" // 1 2 hello Go t.Log(a, b, s) s = \"hello golang\" // 1 2 hello golang t.Log(a, b, s) } 省略了关键字 var,转而使用 := 符号声明并初始化变量值且利用自动类型推断能力进一步就简化变量定义,再次赋值时不能再使用 := 符号. 变量 var 声明作用域大于变量 := 声明 var globalTestId = 2 // globalTestName := \"type_test\" is not supported var globalTestName = \"type_test\" func TestVariableScope(t *testing.T) { // 2 type_test t.Log(globalTestId, globalTestName) globalTestName = \"TestVariableScope\" // 2 TestVariableScope t.Log(globalTestId, globalTestName) } var 声明的变量可以作用于函数外或函数内,而 := 声明的变量只能作用于函数内,Go 并没有全局变量的概念,变量的作用范围只是针对包而言. 常量的使用方式和变量一致 func TestConstant(t *testing.T) { const a, b = 3, 4 const s = \"hello Go\" // 3 4 hello Go t.Log(a, b, s) } 常量声明关键字 const,常量和变量的使用方式一致,具备类型推断能力,也存在多种简化常量定义的形式. 虽然没有枚举类型,但可以用 iota 配合常量来实现枚举 func TestConstant2Enum(t *testing.T) { const ( java = iota golang cpp python javascript ) // 0 1 2 3 4 t.Log(java, golang,cpp,python,javascript) } iota 在一组常量定义中首次出现时,其值为 0,应用到下一个常量时,其值为开始自增 1,再次遇到iota 恢复 0 .效果非常像 for 循环中的循环索引 i,明明是常量,偏偏玩出了变量的味道,也是我觉得 iota 不安分的原因. 常量 iota 有妙用,还可以进行位运算 func TestConstantIotaBitCalculate(t *testing.T){ const ( Readable = 1 定义二进制位最低位为 1 时表示可读的,左移一位表示可写的,左移两位表示可执行的,按照按位与运算逻辑,目标权限位若拥有可读权限,此时和可读常量进行按位与运算之后的结果一定是可读的,由此可见,iota 非常适合此类操作. 总体来说,Go 语言中的变量很有意思,常量 iota 不那么安分,从上述归纳总结中不难看出,Go 语言和其他主流的编程语言还是有很大不同的,学习时要侧重于这些特殊之处. 如果想要回顾本节知识点,可以关注公众号[雪之梦技术驿站]找到go 学习笔记之有意思的变量和不安分的常量 这篇文章进行查看. 简洁的类型中格外关照了复数 在学习 Go 语言中的变量和常量时,虽然没有特意强调变量或常量的类型,但是大多数编程语言的类型基本都是差不多的,毕竟大家所处的现实世界是一样的嘛! 光是猜测是不够的,现在我们要梳理一遍 Go 语言的类型有哪些,和其他主流的编程语言相比有什么不同? Go 语言的变量类型大致可以分为以下几种: bool 布尔类型 bool,表示真假 true|false (u)int ,(u)int8 , (u)int16, (u)int32,(u)int64,uintptr int 类型表示整数,虽然不带位数并不表示没有位数,32 位操作系统时长度为 32 位,64 位操作系统时长度为 64 位.最后一个 uintptr 是指针类型. byte(uint8) ,rune(int32),string byte 是字节类型,也是 uint8 的别名,而 rune 是 Go 中的字符类型,也是 int32 的别名. float32 ,float64 ,complex64 ,complex128 只有 float 类型表示小数,没有 double 类型,类型越少对于开发者而言越简单,不是吗? complex64=float32+float32 是复数类型,没错!就是高中数学书本上的复数,3+4i 那种奇怪的数字! Go 的类型还是比较简单的,整数,小数,复数,字节,字符和布尔类型,相同种类的类型没有继续细分不同的名称而是直接根据类型长度进行命名的,这样是非常直观的,见名知意,根据数据大小直接选用类型,不费脑! 作为一种通用的编程语言,Go 内建类型中居然格外关照了复数这种数学概念类型,是一件有意思的事情,是不是意味着 Go 在工程化项目上做得更好?就像 Go 天生支持并发一样? 既然为数不多的类型中格外关照了复数类型,那我们简单使用下复数类型吧,毕竟其他类型和其他主流的编程语言相差不大. func TestComplex(t *testing.T) { c := 3 + 4i // 5 t.Log(cmplx.Abs(c)) } 生命苦短,直接利用变量类型推断简化变量声明,求出复数类型 c 的模(绝对值) 既然学习了复数,怎么能少得了欧拉公式,毕竟是\"世界上最美的公式\",刚好用到了复数的相关知识,那我们就简单验证一下吧! func TestEuler(t *testing.T) { // (0+1.2246467991473515e-16i) t.Log(cmplx.Pow(math.E, 1i*math.Pi) + 1) // (0+1.2246467991473515e-16i) t.Log(cmplx.Exp(1i*math.Pi) + 1) // (0.000+0.000i) t.Logf(\"%.3f\", cmplx.Exp(1i*math.Pi)+1) } 由于复数 complex 是使用 float 类型表示的,而 float 类型无论是什么编程语言都是不准确的,所以欧拉公式的计算结果非常非常接近于零,当只保留小数点后三位时,计算结果便是 (0.000+0.000i) ,复数的模也就是 0,至此验证了欧拉公式. 看过复数还是要研究类型特点 复数很重要,但其他类型也很重要,简单了解过复数的相关知识后,我们仍然要把注意力放到研究这些内建类型的特殊之处上或者说这些类型总体来说相对于其他主流的编程语言有什么异同. 只有显示类型转换,不存在隐式类型转换 func TestExplicitTypeConvert(t *testing.T) { var a, b int = 3, 4 var c int c = int(math.Sqrt(float64(a*a + b*b))) // 3 4 5 t.Log(a, b, c) } 已知勾股定理的两条直角边计算斜边,根据勾股定理得,直角边长度的平方和再开根号即斜边长度,然而 math.Sqrt 方法接收的 float64 类型,返回的也是 float64 类型,可实际值全是 int 类型,这种情况下并不会自动进行类型转换,只能进行强制类型转换才能得到我们的期望值,这就是显示类型转换. 别名类型和原类型也不能进行隐式类型转换 func TestImplicitTypeConvert2(t *testing.T) { type MyInt64 int64 var a int64 = 1 var b MyInt64 // b = a : cannot use a (type int64) as type MyInt64 in assignment b = MyInt64(a) t.Log(a, b) } MyInt64 是 int64 的别名,别名类型的 b 和原类型的 a 也不能进行也不能进行隐式类型转换,会报错 cannot use a (type int64) as type MyInt64 in assignment,只能进行显示类型转换. 支持指针类型,但不支持任何形式的计算 func TestPointer(t *testing.T) { var a int = 1 var pa *int = &a // 0xc0000921d0 1 1 t.Log(pa, *pa, a) *pa = 2 // 0xc0000901d0 2 2 t.Log(pa, *pa, a) } 同样的,指针类型也是其他编程语言反过来书写的,个人觉得这种反而不错,指向 int 类型的指针 *int,&a 是变量 a 的内存地址,所以变量 pa 存的就是变量 a 的地址,*pa 刚好也就是变量 a 的值. 上例显示声明了变量类型却没有利用到 Go 的类型推断能力,摆在那的能力却不利用简直是浪费,所以提供一种更简短的方式重写上述示例,并顺便解释后半句: \"指针类型不支持任何形式的计算\" func TestPointerShorter(t *testing.T) { a := 1 pa := &a // 0xc0000e6010 1 1 t.Log(pa, *pa, a) *pa = 2 // 0xc0000e6010 2 2 t.Log(pa, *pa, a) // pa = pa + 1 : invalid operation: pa + 1 (mismatched types *int and int) //pa = pa + 1 // *int int int t.Logf(\"%T %T %T\", pa, *pa,a) } 变量 pa 是指针类型,存储的是变量的内存地址,只可远观而不可亵玩,*pa 就是指针所指向的变量的值,可以进行修改,当然没问题就像可以重新赋值变量 a 一样,但是指针 pa 是不可以进行任何形式的运算的,pa = pa + 1 就会报错 invalid operation. 你猜运算符操作有没有彩蛋呢 变量和类型还只是孤立的声明语句,没有计算不成逻辑,并不是所有的程序都是预定义的变量,Go 的运算符是简单还是复杂呢,让我们亲自体验一下! 算术运算符少了 ++i 和 --i func TestArithmeticOperator(t *testing.T) { a := 0 // 0 t.Log(a) a = a + 1 // 1 t.Log(a) a = a * 2 // 2 t.Log(a) a = a % 2 // 0 t.Log(a) a++ // 1 t.Log(a) } 支持大部分正常的运算符,不支持前置自增,前置自减,这也是好事,再也不会弄错 i++ 和 ++i 的运算结果啦,因为根本不支持 ++i ! 比较运算符是否相等有花样 func TestComparisonOperator(t *testing.T) { a, b := 0, 1 t.Log(a, b) // false true true t.Log(a > b, a 大于,小于,不等于这种关系很正常,Golang 也没玩出新花样,和其他主流的编程语言逻辑一样,不用特别关心.但是关于比较数组 ==,Go 表示有话要说! Go 中的数组是可以进行比较的,当待比较的两个数组的维度和数组元素的个数相同时,两个数组元素顺序一致且相同时,则两个数组相等,而其他主流的编程语言一般而言比较的都是数组的引用,所以这一点需要特别注意. func TestCompareArray(t *testing.T) { a := [...]int{1, 2, 3} //b := [...]int{2, 4} c := [...]int{1, 2, 3} d := [...]int{1, 2, 4} // a == b --> invalid operation: a == b (mismatched types [3]int and [2]int) //t.Log(a == b) // true false t.Log(a == c,a == d) } 数组 a 和 c 均是一维数组且元素个数都是 3,因此两个数组可以比较且相等,若数组a 和 b 进行比较,则报错 invalid operation,是因为两个数组的元素个数不相同,无法比较! 逻辑运算符老实本分无异常 func TestLogicalOperator(t *testing.T) { a, b := true, false t.Log(a, b) // false true false true t.Log(a&&b,a||b,!a,!b) } 位运算符新增按位清零 &^ 很巧妙 Go 语言中定义按位清零运算符是 &^,计算规律如下: 当右边操作位数为 1 时,左边操作为不论是 1 还是 0 ,结果均为 0; 当右边操作位数为 0 时,结果同左边操作位数. func TestClearZeroOperator(t *testing.T) { // 0 0 1 0 t.Log(1&^1, 0&^1, 1&^0, 0&^1) } 不知道还记不记得,在介绍常量 iota 时,曾经以文件权限为例,判断给定的权限码是否拥有特定权限,同样是给定的权限码,又该如何撤销特定权限呢? func TestClearZeroOperator(t *testing.T) { const ( Readable = 1 accessCode = accessCode &^ Readable 进行按位清零操作后就失去了可读权限,accessCode&Readable == Readable 再次判断时就没有可读权限了. 流程控制语句也有自己的傲娇 if 有话要说 有了变量类型和各种运算符的加入,现在实现简单的语句已经不是问题了,如果再辅助流程控制语句,那么实现较为复杂拥有一定逻辑的语句便可更上一层楼. Go 语言的 if 条件语句和其他主流的编程语言的语义是一样的,不一样的是书写规则和一些细节上有着自己特点. 条件表达式不需要小括号 () func TestIfCondition(t *testing.T) { for i := 0; i Go 语言的各种省略形式使得整体上非常简洁,但也让拥有其他主流编程语言的开发者初次接触时很不习惯,语句结束不用分号 ;,条件表达式不用小括号 () 等等细节,如果不用 IDE 的自动提示功能,这些细节肯定要耗费不少时间. 条件表达式中可以定义变量,只要最后的表达式结果是布尔类型即可 func TestIfConditionMultiReturnValue(t *testing.T) { const filename = \"test.txt\" if content, err := ioutil.ReadFile(filename); err != nil { t.Log(err) } else { t.Logf(\"%s\\n\", content) } } Go 语言的函数支持返回多个值,这一点稍后再细说,ioutil.ReadFile 函数返回文件内容和错误信息,当存在错误信息时 err != nil,输出错误信息,否则输出文件内容. 条件表达式中定义的变量作用域仅限于当前语句块 如果尝试在 if 语句块外访问变量 content,则报错 undefined: content switch 不甘示弱 同其他主流的编程语言相比,switch 语句最大的特点就是多个 case 不需要 break,Go 会自动进行 break,这一点很人性化. switch 会自动 break,除非使用 fallthrough func TestSwitchCondition(t *testing.T) { switch os := runtime.GOOS; os { case \"darwin\": t.Log(\"Mac\") case \"linux\": t.Log(\"Linux\") case \"windows\": t.Log(\"Windows\") default: t.Log(os) } } 条件表达式不限制为常量或整数 其他主流的编程语言中 switch 的条件表达式仅支持有限类型,使用方式存在一定局限性,Go 语言则不同,这一点变化也是很有意思的,使用 switch 做分支控制时不用担心变量类型了! case 语言支持多种条件,用逗号 , 分开,逻辑或 func TestSwitchMultiCase(t *testing.T) { for i := 0; i 省略 switch 的条件表达式时,switch 的逻辑和多个 if else 逻辑相同 func TestSwitchCaseCondition(t *testing.T) { for i := 0; i for 姗姗来迟 最后登场的是 for 循环,一个人完成了其他主流编程语言三个人的工作,Go 语言中既没有 while 循环也,也没有 do while 循环,有的只是 for 循环. 循环条件不需要小括号 () func TestForLoop(t *testing.T) { sum := 0 for i := 1; i 再一次看到条件表达式不需要小括号 () 应该不会惊讶了吧? if 的条件语句表达式也是类似的,目前为止,接触到明确需要小括号的 () 也只有变量或常量定义时省略形式了. 可以省略初始条件 func convert2Binary(n int) string { result := \"\" for ; n > 0; n /= 2 { lsb := n % 2 result = strconv.Itoa(lsb) + result } return result } func TestConvert2Binary(t *testing.T) { // 1 100 101 1101 t.Log( convert2Binary(1), convert2Binary(4), convert2Binary(5), convert2Binary(13), ) } 利用整数相除法,不断取余相除,得到给定整数的二进制字符串,这里就省略了初始条件,只有结束条件和递增表达式.这种写法同样在其他主流的编程语言是没有的,体现了 Go 设计的简洁性,这种特性在以后的编程中会越来越多的用到,既然可以省略初始条件,相信你也能猜到可不可以省略其他两个条件呢? 可以省略初始条件和递增表达式 func printFile(filename string) { if file, err := os.Open(filename); err != nil { panic(err) } else { scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } } } func TestPrintFile(t *testing.T) { const filename = \"test.txt\" printFile(filename) } 打开文件并逐行读取内容,其中 scanner.Scan() 的返回值类型是 bool,这里省略了循环的初始条件和递增表达式,只有循环的终止条件,也顺便实现了 while 循环的效果. 初始条件,终止条件和递增表达式可以全部省略 func forever() { for { fmt.Println(\"hello go\") } } func TestForever(t *testing.T) { forever() } for 循环中没有任何表达式,意味着这是一个死循环,常用于 Web 请求中监控服务端口,是不是比 while(true) 要更加简单? 压轴的一等公民函数隆重登场 虽然没有特意强制函数,但是示例代码中全部都是以函数形式给出的,函数是封装的一种形式,更是 Go 语言的一等公民. 返回值在函数声明的最后,多个返回值时用小括号 () func eval(a, b int, op string) int { var result int switch op { case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported operator: \" + op) } return result } func TestEval(t *testing.T) { t.Log( eval(1, 2, \"+\"), eval(1, 2, \"-\"), eval(1, 2, \"*\"), eval(1, 2, \"/\"), //eval(1, 2, \"%\"), ) } 不论是变量的定义还是函数的定义,Go 总是和其他主流的编程语言相反,个人觉得挺符合思维顺序,毕竟都是先有输入才能输出,多个输出当然要统一隔离在一块了. 可以有零个或一个或多个返回值 func divide(a, b int) (int, int) { return a / b, a % b } func TestDivide(t *testing.T) { // 2 1 t.Log(divide(5, 2)) } 小学时就知道两个整数相除,除不尽的情况下还有余数.只不过编程中商和余数都是分别计算的,Go 语言支持返回多个结果,终于可以实现小学除法了! 返回多个结果时可以给返回值起名字 func divideReturnName(a, b int) (q, r int) { return a / b, a % b } func TestDivideReturnName(t *testing.T) { q, r := divideReturnName(5, 2) // 2 1 t.Log(q, r) } 还是整数除法的示例,只不过给返回值起了变量名称 (q, r int),但这并不影响调用者,某些 IDE 可能会基于次特性自动进行代码补全,调用者接收时的变量名不一定非要是 q,r . 其他函数可以作为当前函数的参数 func apply(op func(int, int) int, a, b int) int { p := reflect.ValueOf(op).Pointer() opName := runtime.FuncForPC(p).Name() fmt.Printf(\"Calling function %s with args (%d,%d)\\n\", opName, a, b) return op(a, b) } func pow(a, b int) int { return int(math.Pow(float64(a), float64(b))) } func TestApply(t *testing.T) { // 1 t.Log(apply(func(a int, b int) int { return a % b }, 5, 2)) // 25 t.Log(apply(pow, 5, 2)) } apply 函数的第一个参数是 op 函数,第二,第三个参数是 int 类型的 a,b.其中 op 函数也接收两个 int 参数,返回一个 int 结果,因此 apply 函数的功能就是将 a,b 参数传递给 op 函数去执行,这种方式比 switch 固定运算类型要灵活方便! 没有默认参数,可选参数等复杂概念,只有可变参数列表 func sum(numbers ...int) int { result := 0 for i := range numbers { result += numbers[i] } return result } func TestSum(t *testing.T) { // 15 t.Log(sum(1, 2, 3, 4, 5)) } range 遍历方式后续再说,这里可以简单理解为其他主流编程语言中的 foreach 循环,一般包括当前循环索引和循环项. 指针类型很方便同时也很简单 Go 的语言整体上比较简单,没有太多花里胡哨的语法,稍微有点特殊的当属变量的定义方式了,由于具备类型推断能力,定义变量的方式有点多,反而觉得选择困难症,不知道这种情况后续会不会有所改变? 在 Go 语言的为数不多的类型中就有指针类型,指针本来是 c 语言的概念,其他主流的编程语言也有类似的概念,可能不叫做指针而是引用,但 Go 语言的发展和 c++ 有一定关系,保留了指针的概念. 但是这并不意味着 Go 语言的指针像 C 语言那样复杂,相反,Go 语言的指针很方便也很简单,方便是由于提供我们操作内存地址的方式,简单是因为不能对指针做任何运算! 简单回忆一下指针的基本使用方法: func TestPointerShorter(t *testing.T) { a := 1 pa := &a // 0xc0000e6010 1 1 t.Log(pa, *pa, a) *pa = 2 // 0xc0000e6010 2 2 t.Log(pa, *pa, a) // pa = pa + 1 : invalid operation: pa + 1 (mismatched types *int and int) //pa = pa + 1 // *int int int t.Logf(\"%T %T %T\", pa, *pa,a) } & 可以获取变量的指针类型,* 指向变量,但不可以对指针进行运算,所以指针很简单! 当指针类型和其他类型和函数一起发生化学反应时,我们可能更加关心参数传递问题,其他主流的编程语言可能有值传递和引用传递两种方式,Go 语言进行参数传递时又是如何表现的呢? func swapByVal(a, b int) { a, b = b, a } func TestSwapByVal(t *testing.T) { a, b := 3, 4 swapByVal(a, b) // 3 4 t.Log(a, b) } swapByVal 函数内部实现了变量交换的逻辑,但外部函数 TestSwapByVal 调用后变量 a,b 并没有改变,可见 Go 语言这种参数传递是值传递而不是引用传递. 上面示例中参数传递的类型都是普通类型,如果参数是指针类型的话,结果会不会不一样呢? func swapByRef(a, b *int) { *a, *b = *b, *a } func TestSwapByRef(t *testing.T) { a, b := 3, 4 swapByRef(&a, &b) // 4 3 t.Log(a, b) } 指针类型进行参数传递时可以交换变量的值,拷贝的是内存地址,更改内存地址的指向实现了原始变量的交换,参数传递的仍然是值类型. 实际上,Go 语言进行参数传递的只有值类型一种,这一点不像其他主流的编程语言那样可能既存在值类型又存在引用类型. 既然是值类型进行参数传递,也就意味着参数传递时直接拷贝一份变量供函数调用,函数内部如何修改参数并不会影响到调用者的原始数据. 如果只是简单类型并且不希望参数值被修改,那最好不过,如果希望参数值被修改呢?那只能像上例那样传递指针类型. 简单类型不论是传递普通类型还是指针类型,变量的拷贝过程不会太耗费内存也不会影响状态. 如果传递的参数本身是比较复杂的类型,仍然进行变量拷贝过程估计就不能满足特定需求了,可能会设计成出传递复杂对象的某种内部指针,不然真的要进行值传递,那还怎么玩? Go 只有值传递一种方式,虽然简单,但实际中如何使用应该有特殊技巧,以后再具体分析,现在回到交换变量的例子,换一种思路. func swap(a, b int) (int, int) { return b, a } func TestSwap(t *testing.T) { a, b := 3, 4 a, b = swap(a, b) // 4 3 t.Log(a, b) } 利用 Go 函数可以返回多个值特性,返回交换后的变量值,调用者接收时相当于重新赋值,比传递指针类型要简单不少! 基础语法知识总结和下文预告 刚刚接触 Go 语言时觉得 Go 的语言很简单也很特别,和其他主流的编程语言相比,有着自己独特的想法. 语句结束不用分号 ; 而是直接回车换行,这一点有些不习惯,好在强大的 IDE 可以纠正这些细节. 变量声明时变量名在前,变量类型在后,可能更加符合大脑思维,但是习惯了先写变量类型再写变量名,这确实有一定程度的不方便,后来索性不写变量类型,自然就没有问题了. 函数声明同变量声明类似,返回值放到了最后部分,并且还可以有多个返回值,经过了变量的洗礼,再熟悉函数的这一特点也就不那么惊讶了,先输入后输出,想一想也有道理,难道其他编程语言的顺序都是错的? 接下来就是语法的细节,比如 if 的条件表达式可以进行变量赋值,switch 表达式可以不用 break,只有 for 循环一种形式等等. 这些细节总体来说比较简单方便,不用关心细节,放心大胆使用,从而专注于业务逻辑,等到语法不对时,IDE 自然会给出相应的报错提醒,放心大胆 Go ! 本文主要介绍了 Go 的基本语法以及和其他主流的编程语言的异同,你 Get 到了吗? 下文将开始介绍 Go 的内建容器类型,数组,切片,Map 来一遍! 欢迎大家一起学习交流,如有不当之处,恳请指正,如需完整源码,请在公众号[雪之梦技术驿站]留言回复,感谢你的评论与转发! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/base/grammar.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/container/about.html":{"url":"go/container/about.html","title":"内建容器","keywords":"","body":"内建容器 上篇文章中详细介绍了 Go 的基础语言,指出了 Go 和其他主流的编程语言的差异性,比较侧重于语法细节,相信只要稍加记忆就能轻松从已有的编程语言切换到 Go 语言的编程习惯中,尽管这种切换可能并不是特别顺畅,但多加练习尤其是多多试错,总是可以慢慢感受 Go 语言之美! 在学习 Go 的内建容器前,同样的,我们先简单回顾一下 Go 的基本语言,温度而知新可以为师矣! 上节知识回顾 如需了解详情,请于微信公众号[雪之梦技术驿站]内查看 go 学习笔记之值得特别关注的基础语法有哪些 文章,觉得有用的话,顺手转发一下呗! 内建类型种类 bool 布尔类型,可选 true|false,默认初始化零值 false . (u)int ,(u)int8 , (u)int16, (u)int32,(u)int64,uintptr 2^0=1,2^1=2 ,2^2=4 个字节长度的整型,包括有符号整型和无符号整型以及 uintptr 类型的指针类型,默认初始化零值 0 . byte(uint8) ,rune(int32),string byte 是最基础字节类型,是 uint8 类型的别名,而 rune 是 Go 中的字符类型,是 int32 的别名.最常用的字符串类型 string 应该不用介绍了吧? float32 ,float64 ,complex64 ,complex128 只有 float 类型的浮点型,没有 double 类型,同样是以字节长度来区分,complex64 是复数类型,实部和虚部由 float32 类型复合而成,因此写作 complex64 这种形式. 内建类型特点 类型转换只有显示转换,不存在任何形式的隐式类型转换 不同变量类型之间不会自动进行隐式类型转换,Go 语言的类型转换只有强制的,只能显示转换. 虽然提供指针类型,但指针本身不能进行任何形式的计算. 指针类型的变量不能进行计算,但是可以重新改变内存地址的指向. 变量声明后有默认初始化零值,变量零值视具体类型而定 int 类型的变量的初始化零值是 0,string 类型的初始化零值是空字符串,并不是 nil 基本运算符 算术运算符没有 ++i 和--i 只有 i++ 和 i-- 这种自增操作,再也不用担心两种方式的差异性了! 比较运算符 == 可以比较数组是否相等 当两个数组的维度和数组长度相等时,两个数组可以进行比较,顺序完全一致时,结果为 true,其他情况则是 false . 位运算符新增按位清零运算符 &^ 其他主流的编程语言虽然没有这种操作符,通过组合命令也可以实现类似功能,但既然提供了按位清零运算符,再也不用自己进行组合使用了! 流程控制语句 if 条件表达式不需要小括号并支持变量赋值操作 先定义临时变量并根据该变量进行逻辑判断,然后按照不同情况进行分类处理,Go 处理这种临时变量的情况,直接对条件表达式进行增强,这种情况以后会很常见! if 条件表达式内定义的变量作用域仅限于当前语句块 条件表达式内定义的变量是为了方便处理不同分支的逻辑,既然是临时变量,出了当前的 if 语句块就无法使用,也变得可以理解. switch 语句可以没有 break,除非使用了 fallthrough switch 语句的多个 case 结尾处可以没有 break,系统会自动进行 break 处理. switch 条件表达式不限制为常数或整数 和其他主流的编程语言相比,Go 语言的 switch 条件表达式更加强大,类型也较为宽松. switch 条件表达式可以省略,分支逻辑转向 case 语言实现. 省略 switch 条件表达式,多个 case 语言进行分支流程控制,功能效果和多重 if else 一样. 省略 switch 条件表达式后,每个 case 条件可以有多个条件,用逗号分隔. swicth 语句本质上是根据不同条件进行相应的流程控制,每个 case 的条件表达式支持多个,更是增强了流程控制的能力. for 循环的条件表达式也不需要小括号,且没有其他形式的循环. Go 语言只有 for 循环,没有 while 等其他形式的循环. for 循环的初始条件,终止条件和自增表达式都可以省略或者同时省略 条件表达式进行省略后可以实现 while 循环的效果,全部省略则是死循环. 函数和参数传递 函数声明按照函数名,入参,出参顺序定义,并支持多返回值 不论是变量定义还是函数定义,Go 总是和其他主流的编程语言反着来,如果按照输入输出的顺序思考就会发现,这种定义方式其实挺有道理的. 函数有多个返回值时可以给返回值命名,但对调用者而言没有差别 函数返回多个值时可以有变量名,见名知意方便调用者快速熟悉函数声明,但调用者并非一定要按照返回值名称接收调用结果. 函数的入参没有必填参数,可选参数等复杂概念,只支持可变参数列表 可变参数列表和其他主流的编程语言一样,必须是入参的最后一个. 函数参数传递只有值传递,没有引用传递,即全部需要重新拷贝变量 参数传递只有值传递,逻辑上更加简单,但是处理复杂情况时可以传递指针实现引用传递的效果. 内建容器有哪些 复习了 Go 语言的基础语法后,开始继续学习变量类型的承载者也就是容器的相关知识. 承载一类变量最基础的底层容器就是数组了,大多数高级的容器底层都可以依靠数组进行封装,所以先来了解一下 Go 的数组有何不同? 数组和切片 数组的声明和初始化 数组的明显特点就是一组特定长度的连续存储空间,声明数组时必须指定数组的长度,声明的同时可以进行初始化,当然不指定数组长度时也可以使用 ... 语法让编译器帮我们确定数组的长度. func TestArray(t *testing.T) { var arr1 [3]int arr2 := [5]int{1, 2, 3, 4, 5} arr3 := [...]int{2, 4, 6, 8, 10} // [0 0 0] [1 2 3 4 5] [2 4 6 8 10] t.Log(arr1, arr2, arr3) var grid [3][4]int // [[0 0 0 0] [0 0 0 0] [0 0 0 0]] t.Log(grid) } [3]int 指定数组长度为 3,元素类型为 int,当然也可以声明时直接赋值 [5]int{1, 2, 3, 4, 5} ,如果懒得指定数组长度,可以用 [...]int{2, 4, 6, 8, 10} 表示. 数组的遍历和元素访问 最常见的 for 循环进行遍历就是根据数组的索引进行访问,range arr 方式提供了简化遍历的便捷方法. func TestArrayTraverse(t *testing.T) { arr := [...]int{2, 4, 6, 8, 10} for i := 0; i range arr 可以返回索引值和索引项,如果仅仅关心索引项而不在乎索引值的话,可以使用 _ 占位符表示忽略索引值,如果只关心索引值,那么可以不写索引项.这种处理逻辑也就是函数的多返回值顺序接收,不可以出现未使用的变量. 数组是值类型可以进行比较 数组是值类型,这一点和其他主流的编程语言有所不同,因此相同纬度且相同元素个数的数组可以比较,关于这方面的内容前面也已经强调过,这里再次简单回顾一下. func printArray(arr [5]int) { arr[0] = 666 for i, v := range arr { fmt.Println(i, v) } } func TestPrintArray(t *testing.T) { var arr1 [3]int arr2 := [5]int{1, 2, 3, 4, 5} arr3 := [...]int{2, 4, 6, 8, 10} // [0 0 0] [1 2 3 4 5] [2 4 6 8 10] t.Log(arr1, arr2, arr3) // cannot use arr1 (type [3]int) as type [5]int in argument to printArray //printArray(arr1) fmt.Println(\"printArray(arr2)\") printArray(arr2) fmt.Println(\"printArray(arr3)\") printArray(arr3) // [1 2 3 4 5] [2 4 6 8 10] t.Log(arr2, arr3) } 因为参数传递是值传递,所以 printArray 函数无法更改调用者传递的外部函数值,如果想要在函数 printArray 内部更改传递过来的数组内容,可以通过指针来实现,但是有没有更简单的做法? 想要在 printArrayByPointer 函数内部修改参数数组,可以通过数组指针的方式,如果有不熟悉的地方,可以翻看上一篇文章回顾查看. func printArrayByPointer(arr *[5]int) { arr[0] = 666 for i, v := range arr { fmt.Println(i, v) } } func TestPrintArrayByPointer(t *testing.T) { var arr1 [3]int arr2 := [5]int{1, 2, 3, 4, 5} arr3 := [...]int{2, 4, 6, 8, 10} // [0 0 0] [1 2 3 4 5] [2 4 6 8 10] t.Log(arr1, arr2, arr3) fmt.Println(\"printArrayByPointer(arr2)\") printArrayByPointer(&arr2) fmt.Println(\"printArrayByPointer(arr3)\") printArrayByPointer(&arr3) // [666 2 3 4 5] [666 4 6 8 10] t.Log(arr2, arr3) } 修改数组的元素可以通过传递数组指针来实现,除此之外,Go 语言中数组还有一个近亲 slice,也就是切片,它可以实现类似的效果. 切片的声明和初始化 切片和数组非常类似,创建数组时如果没有指定数组的长度,那么最终创建的其实是切片并不是数组. func TestSliceInit(t *testing.T) { var s1 [5]int // [0 0 0 0 0] t.Log(s1) var s2 []int // [] t.Log(s2,len(s2)) } []int 没有指定长度,此时创建的是切片,默认初始化零值是 nil,并不是空数组! 同理,数组可以声明并初始化,切片也可以,并且语法也很类似,稍不注意还以为是数组呢! func TestSliceInitValue(t *testing.T) { var s1 = [5]int{1, 3, 5, 7, 9} // [1 3 5 7 9] t.Log(s1) var s2 = []int{1, 3, 5, 7, 9} // [1 3 5 7 9] t.Log(s2) } 仅仅是没有指定 [] 中的长度,最终创建的结果就变成了切片,真的让人眼花缭乱! 数组和切片如此相像,让人不得不怀疑两者之间有什么见不得人的勾当?其实可以从数组中得到切片,下面举例说明: func TestSliceFromArray(t *testing.T) { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // arr = [0 1 2 3 4 5 6 7 8 9] t.Log(\"arr = \", arr) // arr[2:6] = [2 3 4 5] t.Log(\"arr[2:6] = \", arr[2:6]) // arr[:6] = [0 1 2 3 4 5] t.Log(\"arr[:6] = \", arr[:6]) // arr[2:] = [2 3 4 5 6 7 8 9] t.Log(\"arr[2:] = \", arr[2:]) // arr[:] = [0 1 2 3 4 5 6 7 8 9] t.Log(\"arr[:] = \", arr[:]) } arr[start:end] 截取数组的一部分得到的结果就是切片,切片的概念也是很形象啊! 和其他主流的编程语言一样,[start:end] 是一个左闭右开区间,切片的含义也非常明确: 忽略起始索引 start 时,arr[:end] 表示原数组从头开始直到终止索引 end 的前一位; 忽略终止索引 end 时,arr[ start:] 表示原数组从起始索引 start 开始直到最后一位; 既忽略起始索引又忽略终止索引的情况,虽然不常见但是含义上将应该就是原数组,但是记得类型是切片不是数组哟! 目前为止,我们知道切片和数组很相似,切片相对于数组只是没有大小,那么切片和数组的操作上是否一样呢? func updateSlice(s []int) { s[0] = 666 } func TestUpdateSlice(t *testing.T) { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // arr = [0 1 2 3 4 5 6 7 8 9] t.Log(\"arr = \", arr) s1 := arr[2:6] // s1 = [2 3 4 5] t.Log(\"s1 = \", s1) s2 := arr[:6] // s2 = [0 1 2 3 4 5] t.Log(\"s2 = \", s2) updateSlice(s1) // s1 = [666 3 4 5] t.Log(\"s1 = \", s1) // arr = [0 1 666 3 4 5 6 7 8 9] t.Log(\"arr = \", arr) updateSlice(s2) // s2 = [666 1 666 3 4 5] t.Log(\"s2 = \", s2) // arr = [666 1 666 3 4 5 6 7 8 9] t.Log(\"arr = \", arr) } 切片竟然可以更改传递参数,这一点可是数组没有做到的事情啊!除非使用数组的指针类型,切片竟然可以轻易做到?除非切片内部是指针,因为参数传递只有值传递,根本没有引用传递方式! 切片和数组在参数传递的表现不同,具体表现为数组进行参数传递时无法修改数组,想要想改数组只有传递数组指针才行,而切片却实现了数组的改变! 由于参数传递只有值传递一种方式,因此推测切片内部肯定存在指针,参数传递时传递的是指针,所以函数内部的修改才能影响到到函数外部的变量. slice 的内部实现中有三个变量,指针 ptr,个数 len 和容量 cap ,其中 ptr 指向真正的数据存储地址. 正是由于切片这种内部实现,需要特性也好表现形式也罢才使得切换和数组有着千丝万缕的联系,其实这种数据结果就是对静态数组的扩展,本质上是一种动态数组而已,只不过 Go 语言叫做切片! 切片是动态数组,上述问题就很容易解释了,参数传递时传递的是内部指针,因而虽然是值传递拷贝了指针,但是指针指向的真正元素毕竟是一样的,所以切片可以修改外部参数的值. 数组可以在一定程度上进行比较,切片是动态数组,能不能进行比较呢?让接下来的测试方法来验证你的猜想吧! 不知道你有没有猜对呢?切片并不能进行比较,只能与 nil 进行判断. 切片的添加和删除 数组是静态结构,数组的大小不能扩容或缩容,这种数据结构并不能满足元素个数不确定场景,因而才出现动态数组这种切片,接下来重点看下切片怎么添加或删除元素. func printSlice(s []int) { fmt.Printf(\"s = %v, len(s) = %d, cap(s) = %d\\n\", s, len(s), cap(s)) } func TestSliceAutoLonger(t *testing.T) { var s []int // [] t.Log(s) for i := 0; i 添加元素 s = append(s, i) 需要扩容时,每次以 2 倍进行扩容,删除元素 s[1:] 时,递减缩容. s = append(s, i) 向切片中添加元素并返回新切片,由于切片是动态数组,当切片内部的数组长度不够时会自动扩容以容纳新数组,扩容前后的内部数组会进行元素拷贝过程,所以 append 会返回新的地址,扩容后的地址并不是原来地址,所以需要用变量接收添加后的切片. 当不断进行切片重新截取时 s[1:] ,切片存储的元素开始缩减,个数递减,容量也递减. 其实除了基于数组创建切片和直接创建切片的方式外,还存在第三种创建切片的方式,也是使用比较多的方式,那就是 make 函数. func TestMakeSlice(t *testing.T) { s1 := make([]int,10) // s1 = [0 0 0 0 0 0 0 0 0 0], len(s1) = 10, cap(s1) = 10 t.Logf(\"s1 = %v, len(s1) = %d, cap(s1) = %d\", s1, len(s1), cap(s1)) s2 := make([]int, 10, 32) // s2 = [0 0 0 0 0 0 0 0 0 0], len(s2) = 10, cap(s2) = 32 t.Logf(\"s2 = %v, len(s2) = %d, cap(s2) = %d\", s2, len(s2), cap(s2)) } 通过 make 方式可以设置初始化长度和容量,这是字面量创建切片所不具备的能力,并且这种方式创建的切片还支持批量拷贝功能! func TestCopySlice(t *testing.T) { var s1 = []int{1, 3, 5, 7, 9} var s2 = make([]int, 10, 32) copy(s2, s1) // s2 = [1 3 5 7 9 0 0 0 0 0], len(s2) = 10, cap(s2) = 32 t.Logf(\"s2 = %v, len(s2) = %d, cap(s2) = %d\", s2, len(s2), cap(s2)) var s3 []int copy(s3, s1) // s3 = [], len(s3) = 0, cap(s3) = 0 t.Logf(\"s3 = %v, len(s3) = %d, cap(s3) = %d\", s3, len(s3), cap(s3)) } func copy(dst, src []Type) int 是切片之间拷贝的函数,神奇的是,只有目标切片是 make 方式创建的切片才能进行拷贝,不明所以,有了解的小伙伴还请指点一二! 切片的底层结构是动态数组,如果切片是基于数组截取而成,那么此时的切片从效果上来看,切片就是原数组的一个视图,对切片的任何操作都会反映到原数组上,这也是很好理解的. 那如果对切片再次切片呢,或者说切片会不会越界,其实都比较简单了,还是稍微演示一下,重点就是动态数组的底层结构. func TestSliceOutOfBound(t *testing.T) { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s1 := arr[2:6] // s1 = [2 3 4 5], len(s1) = 4, cap(s1) = 6 t.Logf(\"s1 = %v, len(s1) = %d, cap(s1) = %d\", s1, len(s1), cap(s1)) s2 := s1[3:5] // s2 = [5 6], len(s2) = 2, cap(s2) = 3 t.Logf(\"s2 = %v, len(s2) = %d, cap(s2) = %d\", s2, len(s2), cap(s2)) } [] 只能访问 len(arr) 范围内的元素,[:] 只能访问 cap(arr) 范围内的元素,一般而言 cap >= len 所以某些情况看起来越界,其实并不没有越界,只是二者的标准不同! 我们知道切片 slice 的内部数据结构是基于动态数组,存在三个重要的变量,分别是指针 ptr,个数 len 和容量 cap ,理解了这三个变量如何实现动态数组就不会掉进切片的坑了! 个数 len 是通过下标访问时的有效范围,超过 len 后会报越界错误,而容量 cap 是往后能看到的最大范围,动态数组的本质也是控制这两个变量实现有效数组的访问. 因为 s1 = [2 3 4 5], len(s1) = 4, cap(s1) = 6 ,所以 [] 访问切片 s1 元素的范围是[0,4) ,因此最大可访问到s1[3],而 s1[4] 已经越界了! 因为 s1 = [2 3 4 5], len(s1) = 4, cap(s1) = 6 ,所以 [:] 根据切片 s1 创建新切片的范围是 [0,6] ,因此最大可访问范围是 s1[0:6] ,而 s1[3:7] 已经越界! 集合 map 集合是一种键值对组成的数据结构,其他的主流编程语言也有类似概念,相比之下,Go 语言的 map 能装载的数据类型更加多样化. 字面量创建 map 换行需保留逗号 , func TestMap(t *testing.T) { m1 := map[string]string{ \"author\": \"snowdreams1006\", \"website\": \"snowdreams1006\", \"language\": \"golang\", } // map[name:snowdreams1006 site:https://snowdreams1006.github.io] t.Log(m1) } 一对键值对的结尾处加上逗号 , 可以理解,但是最后一个也要有逗号这就让我无法理解了,Why ? make 创建的 map 和字面量创建的 map 默认初始化零值不同 func TestMapByMake(t *testing.T) { // empty map m1 := make(map[string]int) // map[] false t.Log(m1, m1 == nil) // nil var m2 map[string]int // map[] true t.Log(m2, m2 == nil) } make 函数创建的 map 是空 map,而通过字面量形式创建的 map 是 nil,同样的规律也适合于切片 slice. range 遍历 map 是无序的 func TestMapTraverse(t *testing.T) { m := map[string]string{ \"name\": \"snowdreams1006\", \"site\": \"https://snowdreams1006.github.io\", } // map[name:snowdreams1006 site:https://snowdreams1006.github.io] t.Log(m) for k, v := range m { t.Log(k, v) } t.Log() for k := range m { t.Log(k) } t.Log() for _, v := range m { t.Log(v) } } 这里再一次遇到 range 形式的遍历,忽略键或值时用 _ 占位,也是和数组,切片的把遍历方式一样,唯一的差别就是 map 没有索引,遍历结果也是无序的! 获取元素时需判断元素是否存在 func TestMapGetItem(t *testing.T) { m := map[string]string{ \"name\": \"snowdreams1006\", \"site\": \"https://snowdreams1006.github.io\", } // snowdreams1006 t.Log(m[\"name\"]) // zero value is empty string t.Log(m[\"author\"]) // https://snowdreams1006.github.io if site, ok := m[\"site\"]; ok { t.Log(site) } else { t.Log(\"key does not exist \") } } Go 语言的 map 获取不存在的键时,返回的是值对应类型的零值,map[string]string 返回的默认零值就是空字符串,由于不会报错进行强提醒,这也就要求我们调用时多做一步检查.当键值对存在时,第二个返回值返回 true,不存在时返回 false. 删除键值对时用 delete 函数 func TestMapDeleteItem(t *testing.T) { m := map[string]string{ \"name\": \"snowdreams1006\", \"site\": \"https://snowdreams1006.github.io\", } // map[name:snowdreams1006 site:https://snowdreams1006.github.io] t.Log(m) delete(m, \"name\") // map[site:https://snowdreams1006.github.io] t.Log(m) delete(m, \"id\") // map[site:https://snowdreams1006.github.io] t.Log(m) } delete(map,key) 用于删除 map 的键值对,如果想要验证是否删除成功,别忘了使用 value,ok := m[k] 确定是否存在指定键值对 除 slice,map,func 外,其余类型均可键 因为 map 是基于哈希表实现,所以遍历是无序的,另一方面因为 slice,map,func 不可比较,因为也不能作为键.当然若自定义类型 struc 不包含上述类型,也可以作为键,并不要求实现 hashcode 和 equal 之类的. value 可以承载函数 func 类型 func TestMapWithFunValue(t *testing.T) { m := map[int]func(op int) int{} m[1] = func(op int) int { return op } m[2] = func(op int) int { return op * op } m[3] = func(op int) int { return op * op * op } // 1 4 27 t.Log(m[1](1), m[2](2), m[3](3)) } 再一次说明函数是一等公民,这部分会在以后的函数式编程中进行详细介绍. 没有 set Go 的默认类型竟然没有 set 这种数据结构,这在主流的编程语言中算是特别的存在了! 正如 Go 的循环仅支持 for 循环一样,没有 while 循环一样可以玩出 while 循环的效果,靠的就是增强的 for 能力. 所以,即使没有 set 类型,基于现有的数据结构一样能实现 set 效果,当然直接用 map 就可以封装成 set. func TestMapForSet(t *testing.T) { mySet := map[int]bool{} mySet[1] = true n := 3 if mySet[n] { t.Log(\"update\", mySet[n]) } else { t.Log(\"add\", mySet[n]) } delete(mySet, 1) } 使用 map[type]bool 封装实现 set 禁止重复性元素的特性,等到讲解到面向对象部分再好好封装,这里仅仅列出核心结构. 知识点总结梳理 Go 语言是十分简洁的,不论是基础语法还是这一节的内建容器都很好的体现了这一点. 数组作为各个编程语言的基础数据结构,Go 语言和其他主流的编程语言相比没有什么不同,都是一片连续的存储空间,不同之处是数组是值类型,所以也是可以进行比较的. 这并不是新鲜知识,毕竟上一节内容已经详细阐述过该内容,这一节的重点是数组的衍生版切片 slice . 因为数组本身是特定长度的连续空间,因为是不可变的,其他主流的编程语言中有相应的解决方案,其中就有不少数据结构的底层是基于数组实现的,Go 语言的 slice 也是如此,因此个人心底里更愿意称其为动态数组! 切片 slice 的设计思路非常简单,内部包括三个重要变量,包括数组指针 ptr,可访问元素长度 len 以及已分配容量 cap . 当新元素不断添加进切片时,总会达到已最大分配容量,此时切片就会自动扩容,反之则会缩容,从而实现了动态控制的能力! 指定元素个数的是数组,未指定个数的是切片 func TestArrayAndSlice(t *testing.T) { // array var arr1 [3]int // slice var arr2 []int // [0 0 0] [] t.Log(arr1,arr2) } 基于数组创建的切片是原始数组的视图 func TestArrayAndSliceByUpdate(t *testing.T) { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // arr = [0 1 2 3 4 5 6 7 8 9] t.Log(\"arr = \", arr) s := arr[2:6] // before update s = [2 3 4 5], arr = [0 1 2 3 4 5 6 7 8 9] t.Logf(\"before update s = %v, arr = %v\", s, arr) s[0] = 666 // after update s = [666 3 4 5], arr = [0 1 666 3 4 5 6 7 8 9] t.Logf(\"after update s = %v, arr = %v\", s, arr) } 添加或删除切片元素都返回新切片 func TestArrayAndSliceIncreasing(t *testing.T) { var s []int fmt.Println(\"add new item to slice\") for i := 0; i [index] 访问切片元素仅仅和切片的 len 有关,[start:end] 创建新切片仅仅和原切片的 cap 有关 func TestArrayAndSliceBound(t *testing.T) { arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := arr[5:8] // s1[0] = 5, s1[2] = 7 t.Logf(\"s1[0] = %d, s1[%d] = %d\", s1[0], len(s1)-1, s1[len(s1)-1]) // s1 = [5 6 7], len(s1) = 3, cap(s1) = 5 t.Logf(\"s1 = %v, len(s1) = %d, cap(s1) = %d\", s1, len(s1), cap(s1)) s2 := s1[3:5] // s2[0] = 8, s2[1] = 9 t.Logf(\"s2[0] = %d, s2[%d] = %d\", s2[0], len(s2)-1, s2[len(s2)-1]) // s2 = [8 9], len(s2) = 2, cap(s2) = 2 t.Logf(\"s2 = %v, len(s2) = %d, cap(s2) = %d\", s2, len(s2), cap(s2)) } 只有 map 没有 set func TestMapAndSet(t *testing.T) { m := map[string]string{ \"name\": \"snowdreams1006\", \"site\": \"https://snowdreams1006.github.io\", \"lang\": \"go\", } // https://snowdreams1006.github.io if site, ok := m[\"site\"]; ok { t.Log(site) } else { t.Log(\"site does not exist \") } s := map[string]bool{ \"name\": true, \"site\": true, \"lang\": true, } // Pay attention to snowdreams1006 if _, ok := m[\"isFollower\"]; ok { t.Log(\"Have an eye on snowdreams1006\") } else { s[\"isFollower\"] = true t.Log(\"Pay attention to snowdreams1006\") } } delete 函数删除集合 map 键值对 func TestMapAndSetByDelete(t *testing.T) { m := map[string]string{ \"name\": \"snowdreams1006\", \"site\": \"https://snowdreams1006.github.io\", \"lang\": \"go\", } delete(m, \"lang\") // delete lang successfully if _,ok := m[\"lang\"];!ok{ t.Log(\"delete lang successfully\") } } 关于 Go 语言中内建容器是不是都已经 Get 了呢?如果有表述不对的地方,还请指正哈,欢迎一起来公众号[雪之梦技术驿站]学习交流,每天进步一点点! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/container/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/container/array.html":{"url":"go/container/array.html","title":"数组切片","keywords":"","body":"数组切片 字符串 string 是数据类型,不是引用或指针类型 string 是只读的 byte slice,len 函数可以返回它所包含的 byte 数 string 的 byte 数组可以存放任何数组 func TestString(t *testing.T) { var s string // s = ,len(s) = 0 t.Logf(\"s = %v,len(s) = %d\", s, len(s)) s = \"hello\" // s = hello,len(s) = 5 t.Logf(\"s = %v,len(s) = %d\", s, len(s)) s = \"\\xE4\\xB8\\xA5\" // s = 严,len(s) = 3 t.Logf(\"s = %v,len(s) = %d\", s, len(s)) s = \"\\xE444\\xB888\\xA555\" // s = �44�88�55,len(s) = 9 t.Logf(\"s = %v,len(s) = %d\", s, len(s)) } unicode utf8 unicode 是一种字符集(code point) utf8 是 unicode 的存储实现(转换为字节序列的规则) func TestStringCodePoint(t *testing.T) { var s string // s = ,len(s) = 0 t.Logf(\"s = %v,len(s) = %d\", s, len(s)) s = \"hello\" // s = hello,len(s) = 5 t.Logf(\"s = %v,len(s) = %d\", s, len(s)) s = \"中\" // s = 中,len(s) = 3 t.Logf(\"s = %v,len(s) = %d\", s, len(s)) //s = e4b8ad,len(s) = 3 t.Logf(\"s = %x,len(s) = %d\", s, len(s)) ch := []rune(s) // s = [4e2d],len(s) = 1 t.Logf(\"ch = %x,len(ch) = %d\", ch, len(ch)) } func TestString2Rune(t *testing.T) { s := \"中华人民共和国\" for _, c := range s { t.Logf(\"%[1]c %[1]d %[1]x\", c) } } 常用字符串函数 strings 包 func TestStrings(t *testing.T) { s := \"A,B,C\" parts := strings.Split(s,\",\") for _, part := range parts { t.Log(part) } newStr := strings.Join(parts,\"-\") t.Log(newStr) } strconv 包 func TestStrconv(t *testing.T) { s := strconv.Itoa(10) // string 10 t.Logf(\"%[1]T %[1]v\", s) // int 10 if i, err := strconv.Atoi(\"10\"); err == nil { t.Logf(\"%[1]T %[1]v\", i) } } 函数是一等公民 它可以返回多个值 所有参数都是值传递: map ,slice,channel 会有引用传递的错觉 函数可以作为变量的值 函数可以作为参数和返回值 func returnMultiValues() (int, int) { return rand.Intn(10), rand.Intn(10) } func TestReturnMultiValues(t *testing.T) { a, b := returnMultiValues() t.Log(a, b) } func timeSpend(inner func(op int) int) func(op int) int { return func(n int) int { start := time.Now() ret := inner(n) fmt.Println(\"time spend : \", time.Since(start).Seconds()) return ret } } func slowFunc(op int) int { time.Sleep(time.Second * 1) return op } func TestSlowFuncTimeSpend(t *testing.T){ slowFuncTimeSpend := timeSpend(slowFunc) t.Log(slowFuncTimeSpend(10)) } func TestDefer(t *testing.T) { defer func() { t.Log(\"Clear resource\") }() t.Log(\"Started\") panic(\"Fatal error\") } https://golang.google.cn/doc/faq#Is_Go_an_object-oriented_language 封装数据和行为 type Employee struct { Id string Name string Age int } func TestCreateEmployee(t *testing.T) { e := Employee{ \"0\", \"Bob\", 20, } t.Logf(\"%[1]T %[1]v\", e) e1 := Employee{ Name: \"Mike\", Age: 30, } t.Logf(\"%[1]T %[1]v\", e1) e2 := new(Employee) e2.Id = \"2\" e2.Name = \"Rose\" e2.Age = 18 t.Logf(\"%[1]T %[1]v\", e2) } func (e Employee) toString() string { return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\", e.Id, e.Name, e.Age) } func TestToString(t *testing.T) { e := Employee{\"0\", \"Bob\", 20} t.Log(e.toString()) } func (e *Employee) toStringPointer() string { return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\", e.Id, e.Name, e.Age) } func TestToStringPointer(t *testing.T) { e := &Employee{\"0\", \"Bob\", 20} t.Log(e.toStringPointer()) } func (e *Employee) toStringPointer() string { fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\", e.Id, e.Name, e.Age) } func TestToStringPointer(t *testing.T) { e := Employee{\"0\", \"Bob\", 20} fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) t.Log(e.toStringPointer()) } func (e Employee) toStringValue() string { fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\", e.Id, e.Name, e.Age) } func TestToStringValue(t *testing.T) { e := Employee{\"0\", \"Bob\", 20} fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) t.Log(e.toStringValue()) } type Programmer interface { WriteHelloWorld() string } type GoProgrammer struct { } func (g *GoProgrammer) WriteHelloWorld() string { return \"fmt.Println(\\\"Hello World\\\")\" } func TestGoProgrammer(t *testing.T) { var p Programmer p = new(GoProgrammer) t.Log(p.WriteHelloWorld()) } 接口为非入侵,实现不依赖于接口定义 所以接口的定义可以包含在接口的使用者包内 type Pet struct { } func (p *Pet) Speak() { fmt.Print(\"...\") } func (p *Pet) SpeakTo(host string) { p.Speak() fmt.Println(\" \", host) } type Dog struct { p *Pet } func (d *Dog) Speak() { d.p.Speak() } func (d *Dog) SpeakTo(host string) { d.p.SpeakTo(host) } func TestDog(t *testing.T){ d := new(Dog) d.SpeakTo(\"Chao\") } type Code string type Programmer interface { WriteHelloWord() Code } type GoProgrammer struct { } func (g *GoProgrammer) WriteHelloWord() Code { return \"fmt.Println(\\\"Hello World!\\\")\" } type JavaProgrammer struct { } func (j *JavaProgrammer) WriteHelloWord() Code { return \"System.out.Println(\\\"Hello World!\\\")\" } func writeFirstProgram(p Programmer) { fmt.Printf(\"%T %v\\n\", p, p.WriteHelloWord()) } func TestPolymorphism(t *testing.T) { gp := new(GoProgrammer) jp := new(JavaProgrammer) writeFirstProgram(gp) writeFirstProgram(jp) } 空接口与断言 空接口可以表示任何类型 通过断言来将空接口转换为指定类型 v,ok := p.(int) func doSomething(p interface{}) { if i, ok := p.(int); ok { fmt.Println(\"int\", i) return } if s, ok := p.(string); ok { fmt.Println(\"string\", s) return } fmt.Println(\"unknown type\") } func TestDoSomething(t *testing.T) { doSomething(10) doSomething(\"10\") doSomething(10.0) } 接口最佳实践 倾向于使用小的接口定义,很多接口只包含一个方法 较大的接口定义可以由小的接口组合而成 只依赖于必要功能的最小接口 a38c4ca339dd38f436a45102878e92135d4b6d3b var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/container/array.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/container/map.html":{"url":"go/container/map.html","title":"字典映射","keywords":"","body":"字典映射 go 语言仅支持封装,不支持继承和多态 go 语言没有class,只有struct 结构的定义 type TreeNode struct Left,Right *TreeNode Value int 不管指针还是实例,都是 . func TestCreatTreeNode(t *testing.T) { var root treeNode root = treeNode{value:3} root.left = &treeNode{} root.right = &treeNode{5,nil,nil} root.right.left = new(treeNode) } 不论地址还是结构本身,一律使用 . 来访问成员 使用自定义工厂函数 注意返回了了局部变量的地址 结构创建在堆上还是栈上?java都是堆上(new垃圾回收),c++局部变量是栈立即销毁,返回时堆分配,手动释放. 不需要知道go,垃圾回收 func createTreeNode(val int) *treeNode { return &treeNode{value: val} } func TestConstructFn(t *testing.T) { root := createTreeNode(1) t.Log(root) } 接收者 func (node treeNode) print() { fmt.Println(node.value) } 遍历 func TestTreeNodeTraverse(t *testing.T) { var root treeNode root = treeNode{value: 3} root.left = &treeNode{} root.right = &treeNode{5, nil, nil} root.right.left = new(treeNode) root.print() } func print(node treeNode) { fmt.Println(node.value) } func TestTreeNodeTraverseByNormalWay(t *testing.T) { var root treeNode root = treeNode{value: 3} root.left = &treeNode{} root.right = &treeNode{5, nil, nil} root.right.left = new(treeNode) print(root) } func (node treeNode) setValue(value int) { node.value = value } func TestTreeNodeSetValue(t *testing.T){ var root treeNode root = treeNode{value: 3} root.left = &treeNode{} root.right = &treeNode{5, nil, nil} root.right.left = new(treeNode) root.left.setValue(4) root.left.print() } func (node *treeNode) setValue(value int) { node.value = value } func TestTreeNodeSetValue(t *testing.T){ var root treeNode root = treeNode{value: 3} root.left = &treeNode{} root.right = &treeNode{5, nil, nil} root.right.left = new(treeNode) root.left.setValue(4) root.left.print() root.setValue(100) root.print() } 显示定义和命名方法接收者 nil 指针也可以调用方法 func (node *treeNode) setValueWithNil(value int) { if node == nil{ fmt.Println(\"Setting value to nil node\") return } node.value = value } func TestTreeNodeSetValueWithNil(t *testing.T){ var root treeNode root = treeNode{value: 3} root.left = &treeNode{} root.right = &treeNode{5, nil, nil} root.right.left = new(treeNode) var pRoot *treeNode pRoot.setValueWithNil(200) pRoot = &root pRoot.setValueWithNil(300) pRoot.print() } func (node *treeNode) traverse() { if node == nil{ return } node.left.traverse() node.print() node.right.traverse() } func TestTreeNodetraverse(t *testing.T) { var root treeNode root = treeNode{value: 3} root.left = &treeNode{} root.right = &treeNode{5, nil, nil} root.right.left = new(treeNode) root.left.right = createTreeNode(2) root.right.left.setValue(4) root.traverse() } 值接收者和指针接收者 要改变内容必须使用指针接收者 结构过大也要考虑使用指针接收者 一致性: 如果有指针接收者,最好都是指针接收者 值接收者是go语言特有 值/指针接收者均可接收值/ 封装 名字一般使用CamelCase 首字母大写: public 首字母小写: private 针对package来说 每个目录一个包 main包包含可执行入口 为结构定义的方法必须放在同一个包内 可以是不同的文件 package main import \"github.com/snowdreams1006/learn-go/oop/tree\" func main() { var root tree.TreeNode root = tree.TreeNode{Value: 3} root.Left = &tree.TreeNode{} root.Right = &tree.TreeNode{5, nil, nil} root.Right.Left = new(tree.TreeNode) root.Left.Right = tree.CreateTreeNode(2) root.Right.Left.SetValue(4) root.Traverse() } 扩展已有类型 如何扩充系统类型或者别人的类型 定义别名 使用组合 type myTreeNode struct { node *tree.Node } func (myNode *myTreeNode) postOrder() { if myNode == nil || myNode.node == nil { return } //myTreeNode.node.Left.postOrder() myLeft := myTreeNode{myNode.node.Left} myLeft.postOrder() myRight := myTreeNode{myNode.node.Right} myRight.postOrder() myNode.node.Print() } func main() { var root tree.Node root = tree.Node{Value: 3} root.Left = &tree.Node{} root.Right = &tree.Node{5, nil, nil} root.Right.Left = new(tree.Node) root.Left.Right = tree.CreateTreeNode(2) root.Right.Left.SetValue(4) root.Traverse() fmt.Println() myRoot := myTreeNode{&root} myRoot.postOrder() fmt.Println() } func TestQueue_Push(t *testing.T) { q := Queue{} q.Push(1) q.Push(2) q.Push(3) t.Log(q.Pop()) t.Log(q.Pop()) t.Log(q.IsEmpty()) t.Log(q.Pop()) t.Log(q.IsEmpty()) } gopath 环境变量的设置 默认~/go(unix/linux),%userprofile\\go(windows)% 官方推荐: 所有项目和第三方库都放在同一个gopath 也可以将不同的项目放到不同的gopath go get golang.org/x/tools/cmd/goimports 使用 gopm 获取无法下载的包 go get github.com/gpmgo/gopm gopm get golang.org/x/tools/cmd/goimports go install ./... var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/container/map.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/oop/about.html":{"url":"go/oop/about.html","title":"面向对象","keywords":"","body":"面向对象 面向对象编程风格深受广大开发者喜欢,尤其是以 C++, Java 为典型代表的编程语言大行其道,十分流行! 有意思的是这两中语言几乎毫无意外都来源于 C 语言,却不同于 C 的面向过程编程,这种面向对象的编程风格给开发者带来了极大的便利性,解放了劳动,松耦合,高内聚也成为设计的标准,从而让我们能够更加愉快地复制粘贴,做代码的搬运工,很多第三方工具开箱即用,语义明确,职责清晰,这都是面向对象编程的好处! Go 语言也是来源于 C 语言,不知道你是否也会好奇 Go 语言是否支持面向对象这种编程风格呢? 准确的说,Go 既支持面向对象编程又不是面向对象语言! 是也不是,难道像是薛定谔的猫一样具有不确定性? 其实这个答案是官方的回答,并不是我个人凭空杜撰而来的,如需了解详情可参考 Is Go an object-oriented language? 为什么这么说呢? Go 支持封装,却不支持继承和多态,所以严格按照面向对象规范来说, Go 语言不是面向对象的编程语言. 但是,Go 提供的接口是一种非常简单上手且更加通用的方式,虽然和其他主流的编程语言表现形式上略有不同,甚至不能实现多态,但 Go 的接口不仅仅适用于结构体,也可以适用于任何数据类型,这无疑是很灵活的! 争议性比较大的当属继承,由于没有任何关键字支持继承特性,因此是找不到继承的痕迹.虽然的确存在着某些方式可以将类型嵌入到其他类型中以实现子类化,但那却不是真正的继承. 所以说,Go 既支持面向对象的编程风格又不完全是面向对象的编程语言. 如果换个角度看问题的话,正是由于没有继承特性使得Go 相对于面向对象编程语言更加轻量化,不妨想一想继承的特性,子类和父类的关系,单继承还是多继承,访问控制权限等问题吧! 如果按照面向对象的编程规范,实现封装特性的那部分应该是类和对象,但这种概念与实现语言的关键字class 是密不可分的,然而 Go 并没有 class 关键字而是 C 语言家族的 struct 关键字,所以叫做类或对象也不是十分贴切,所以下面的讲解过程还是采用结构体吧! 如何定义结构体 stuct 关键字声明结构体,属性之间回车换行. 比如下面示例中定义了动态数组结构体,接下来的示例中都会以动态数组结构体作为演示对象. type MyDynamicArray struct { ptr *[]int len int cap int } Go 语言中定义对象的多属性时使用直接换行方式而不是分号来分隔?为什么和其他主流的编程语言不呢? 对于习惯分号结尾的开发者可能一时并不习惯 Go 的这种语法,于是决定探索一下 Go 的编程规范! 如果手动添加分号的话,编辑器则会提示分号重复,所以猜想是可能是Go编译器已经自动添加了分号,并将分号作为语句声明的分隔符,手动添加分号后,Go 不管不顾还是添加了分号,于是就有了上述的报错. 这样做有什么好处呢? 自己添加分号和编译器无条件添加分号结果不都是一样的吗,更何况其他主流的编程语言都是手动添加分号的啊! 存在多个属性时直接换行而不是添加分号作为分隔符,对于从未接触过编程语言的小白来说,可能会省事儿,但是对于已有编程经验的开发者来说,却需要特别记住不能添加分号,这一点确实有些闹腾! 如果多个属性全部写在一行时,没有换行符我看你还怎么区分,此时用逗号分隔还是用分号分隔呢? 首先空格肯定是不能分隔多个属性的,因此尝试分号或者逗号是否可以. 根据提示说需要分号或者新的换行符,而换行符是标准形式,所以接下来试一下分号能不能分隔? 编辑器此时没有报错或警告信息,因此在一行上多个属性之间应该用分号分隔,也就是说 Go 编译器识别多个属性仍然是同其他主流的编程语言一样,使用分号分隔,而开发者却不能用! 类似于上述的规则记忆很简单,验证也比较容易,难点在于理解为什么? Go 为什么会这么设计?或者说如何理解这种设计思路所代表的语义? Go 作为一门新的编程语言,不仅体现在具体的语法差异上,更重要的是编程思想的特殊性. 正如面向对象中的接口概念一样,设计者只需要定义抽象的行为并不用关心行为的具体实现. 如果我们也采用这种思路来理解不同的编程语言,那么就能透过现象看本质了,否则真的很容易陷入语法细节上,进而可能忽略了背后的核心思想. 其实关于结构体的多属性分隔符问题上,实际上不论采用什么作为分隔符都行,哪怕就是一个逗号,句号都行,只要能让编译器识别到这是不同的属性就行. 由于大多数主流的编程语言一般采用分号作为分隔符,开发者需要手动编写分隔号以供编译器识别,而 Go 语言却不这么认为,算了吧,直接换行,我一样可以识别出来(尽管底层 Go 编译器进行编译时仍然是采用分号表示换行的)! 添加或者不添加分号,对于开发者而言,仅仅是一种分隔多个属性的标志而已,如果能不添加就能实现,那为什么还要添加呢? 是什么,为什么和怎么样是三个基本问题,如果是简单学习了解的话,学会是什么和怎么样就已经足够了,但是这样一来学着学着难免会陷入各自为政的场面,也就是说各个编程语言之间没有任何关系,每一种语言都是独立存在的?! 世界语言千千万,编程语言也不少,学了新语言却没有利用旧语言,那学习新语言时和纯小白有何差异? 学到是学会了,可惜却对旧语言没什么帮助并没有加深旧语言的理解,只是单纯的学习一种全新的语言罢了. 语言是演变创造出来的,不是空中楼阁,是建立在已有体系下逐渐发展演变而来,任何新语言都能或多或少找到旧语言的影子. 所以何不尝试一下,弄清楚新语言设计的初衷和以及设计时所面临的问题,然后再看该语言是如何解决问题的,解决的过程称之为实现细节,我想这种方式应该是一种比较好的学习方式吧! 虽然无法身处语言设计时环境,也不一定明白语言设计时所面临的挑战,但先问尝试着问一下为什么,不这么设计行不行诸如此类的问题,应该是一种不错的开端. 所以接下来的文章都会采用语义性分析的角度,尝试理解 Go语言背后的设计初衷,同时以大量的辅助性的测试验证猜想,不再是简单的知识罗列整理过程,当然必要的知识归纳还是很重要的,这一点自然也不会放弃. 现在动态数组已经定义完毕,也就是作为设计者的工作暂时告一段落,那作为使用者,如何使用我们的动态数组呢? 按照面向对象的说法,由类创造出对象的过程叫做实例化,然而我们已经知道 Go 并不是完全的面向对象语言,因此为了尽可能避免用面向对象的专业术语去称呼 Go 的实现细节,我们暂时可以将其理解为结构体类型和结构体变量的关系,以后随着学习的深入,可能会对这部分有更加深刻的认识. func TestMyDynamicArray(t *testing.T){ var arr MyDynamicArray // { 0 0} t.Log(arr) } 上述写法并没有特殊强调过,完全是用前几篇文章中已经介绍过的语法规则实现的,var arr MyDynamicArray 表示声明类型为 MyDynamicArray 的变量 arr ,此时直接打印该变量的值,得到的是 { 0 0}. 后两个值都是 0,自然很好理解,因为在讲解 Go 语言中的变量时我们就已经介绍过,Go 的变量类型默认初始化都有相应的零值,int 类型的 len cap 属性自然就是 0,而 ptr *[]int 是指向数组的指针,所以是 nil. 等等,有点不对劲,这里有个设计错误,明明叫做动态数组结果内部却是切片,这算怎么回事? 先修正这个错误再说,由此可见,一时粗心影响多么恶劣以至于语义都变了,容我先改正过来! 我们知道要使用数组必须指定数组的初始化长度,第一感觉是使用 cap 表示的容量来初始化 *[cap]int 数组,然而并不可以,编辑器提示说必须使用整型数字. 虽然 cap 是 int 类型的变量,但内部数组 [cap]int 并不能识别这种方式,可能是因为这两个变量时一块声明的,cap 和 [cap]int 都是变量,无法分配. 那如果指定初始化长度应该指定多少呢,如果是 0 的话,语义上正确但和实际使用情况不符合,因为这样一来内部数组根据就没办法插入了! 所以数组的初始化长度不能为零,这样解决了无法操作数组的问题,但语义上又不正确了,因此这种情况下需要维护两个变量 len 和 cap 的值来确保语义和逻辑正确,其中 len 表示真正的数组个数,cap 表示内部数组实际分配的长度,由于这两个变量至关重要,不应该被调用者随意修改,最多只能查看变量的值,所以必须提供一种机制保护变量的值. 接下来,我们尝试用函数封装的思路来完成这种需求,代码实现如下: type MyDynamicArray struct { ptr *[10]int len int cap int } func TestMyDynamicArray(t *testing.T){ var myDynamicArray MyDynamicArray t.Log(myDynamicArray) myDynamicArray.len = 0 myDynamicArray.cap = 10 var arr [10]int myDynamicArray.ptr = &arr t.Log(myDynamicArray) t.Log(*myDynamicArray.ptr) } var myDynamicArray MyDynamicArray 声明结构体变量后并设置了结构体的基本属性,然后操作了内部数组,实现了数组的访问修改. 然而,我们犯了一个典型的错误,调用者不应该关注实现细节,这不是一个封装该干的事! 具体实现细节应该由设计者完成,将有关数据封装成一个整体对外提供相应的接口,这样调用者才能安全方便地调用. 第一步,先将与内部数组相关的两个变量进行封装,对外仅提供访问接口不提供设置接口,防止调用者随意修改. 很显然这部分应该是函数来实现,于是乎有了下面的改造过程. 很遗憾,编辑器直接报错: 必须是类型名称或是指向类型名称的指针. 函数不可以放在结构体内,这一点倒是像极了 C 家族,但是 Java 这种衍生家族会觉得不可思议,不管怎么说,这意味着结构体只能定义结构而不能定义行为! 那我们就把函数移动到结构体外部吧,可是我们定义的函数名叫做 len,而系统也有 len 函数,此时能否正常运行呢?让我们拭目以待,眼见为实. 除了函数本身报错外,函数内部的 len 也报错了,是因为此时的函数和结构体尚未建立起任何联系,怎么可能访问到 len 属性呢,不报错才怪呢! 解决这个问题很简单,直接将结构体的指针传递给 len 函数不就好了,这样一来函数内部就可以访问到结构体的属性了. 从设计的角度上来讲,确实解决了函数定义的问题,但是使用者调用函数时的使用方法看起来和面向对象的写法有些不一样. func TestMyDynamicArray(t *testing.T) { var myDynamicArray MyDynamicArray t.Log(myDynamicArray) myDynamicArray.len = 0 myDynamicArray.cap = 10 var arr [10]int myDynamicArray.ptr = &arr t.Log(myDynamicArray) t.Log(*myDynamicArray.ptr) (*myDynamicArray.ptr)[0] = 1 t.Log(*myDynamicArray.ptr) t.Log(len(&myDynamicArray)) } 面向对象的方法中一般都是通过点操作符 . 访问属性或方法的,而我们实现的属性访问是 . 但方法却是典型的函数调用形式?这看起来明显不像是方法嘛! 为了让普通函数看起来像是面向对象中的方法,Go 做了下面的改变,通过将当前结构体的变量声明移动到函数名前面,从而实现类似于面向对象语言中的 this 或 self 的效果. func len(myArr *MyDynamicArray) int { return myArr.len } 此时方法名和参数返回值又报错了,根据提示说函数名和字段名不能相同? 真的又是一件神奇的事情,难不成 Go 无法区分函数和字段?这就不得而知了. 那我们只好修改函数名,改成面向对象中喜闻乐见的方法命名规则,如下: func (myArr *MyDynamicArray) GetLen() int { return myArr.len } 简单说一下 Go 的访问性规则,大写字母开头的表示公开的 public 权限,小写字母开头表示私有的 private 权限,Go 只有这两类权限,都是针对包 package 而言,以后会再细说,现在先这么理解就行了. 按照实验得到的方法规则,继续完善其他方法,补充 GetCap 和 IsEmpty 等方法. 现在我们已经解决了私有变量的访问性问题,对于初始化的逻辑还没有处理,一般来说,初始化逻辑可以放到构造函数中执行,那 Go 是否支持构造函数呢,以及怎么才能触发构造函数? 尝试按照其他主流的编程语言中构造函数的写法来编写 Go 的构造函数 , 没想到 Go 编译器直接报错了,提示重新定义了 MyDynamicArray 类型,以至于影响了其余部分! 如果修改方法名称的话,理论上可以解决报错问题,但是这并不是构造函数的样子了,难不成 Go 不支持构造函数吗? 此时,面向对象形式的构造函数转变成自定义函数实现的构造函数,更加准确的说法,这是一种类似于工厂模式实现的构造函数方式. func NewMyDynamicArray() *MyDynamicArray { var myDynamicArray MyDynamicArray return &myDynamicArray } 难道 Go 语言真的不支持构造函数? 至于是否支持构造函数或者说应该如何支持构造函数,真相不得而知,随着学习的深入,相信以后一定会有明确的答案,这里简单表达一下个人看法. 首先我们知道 Go 的结构体中只能定义数据,而结构体的方法肯定是在结构体外定义的,为了符合面向对象的使用习惯,也就是通过实例对象的点操作符来访问方法,Go 的方法只能是函数的变体,即普通函数中关于指向结构体变量的声明部分转移到函数名前面来实现方法,这种由函数转变成为方法的模式也符合 Go 一贯的命名规则: 向来是按照人的思维习惯命名,先有输入再有输出等逻辑. 结构体的方法从语法和语义的两个维度上支持了面向对象规范,那么构造函数想要实现面向对象应该如何做呢? 构造函数正如其名应该是函数,而不是方法,方法由指向自身的参数,这一点构造函数不应该有,否则都有实例对象了还构造毛线啊? 既然构造函数是普通函数,那么按照面向对象的命名习惯,方法名应该是结构体名,然而真的操作了,编辑器直接就报错了,所以这不符合面向对象的命名习惯! 如此一来,构造函数的名称可能并不是结构体类型的名称,有可能是其他特殊的名称,最好这个名称能够见名知义且具备实例化对象时自动调用的能力. 当然这个名称依赖于 Go 的设计者如何命名,这里靠猜测是很难猜对的,否则我就是设计者了啊! 除此之外,还有另外一种可能,那就是 Go 并没有构造函数,想要实现构造函数的逻辑只能另辟蹊径. 这么说有没有什么靠谱的依据呢? 我想大概是有的,构造函数虽然提供了自动初始化能力,但是如果真的在构造函数中加入复杂的初始化逻辑,无疑会增大以后出错的排查难度并给使用者带来一定的阅读障碍,所以说一定程度上,构造函数很有可能被滥用了! 那是否就意味着不需要构造函数了呢? 也不能这么说,构造函数除了基本的变量初始化以及简单的逻辑外,在实际编程中还是有一定用途的,为了避免滥用而直接禁用,多少有点饮鸩止渴的感觉吧? 因此,个人的看法是应该可以保留构造函数这种初始化逻辑,也可以换一种思路去实现,或者干脆直接放弃构造函数转而由编译器自动实现构造函数,正如编译器可以自动添加多字段之间的分号那样. 如果开发者真的有构造函数的需求,通过工厂模式或者单例模式等手段总是可以定制结构体初始化的逻辑,所以放弃也未尝不可! 最后,以上这些纯属个人猜想,目前并不知道 Go 是否存在构造函数,有了解的人,还请明确告诉我答案,个人倾向于不存在构造函数,最多只提供类似于构造函数初始化的逻辑! 现在,我们已经封装了结构体的数据,定义了结构体的方法以及实现了结构体的工厂函数.那么接下来让我们继续完善动态数组,实现数组的基本操作. func NewMyDynamicArray() *MyDynamicArray { var myDynamicArray MyDynamicArray myDynamicArray.len = 0 myDynamicArray.cap = 10 var arr [10]int myDynamicArray.ptr = &arr return &myDynamicArray } func TestMyDynamicArray(t *testing.T) { myDynamicArray := NewMyDynamicArray() t.Log(myDynamicArray) } 首先将测试用例中的逻辑提取到工厂函数中,默认无参的工厂函数初始化的内部数组长度为 10 ,后续再考虑调用者指定以及实现动态数组等功能,暂时先实现最基本的功能. 初始化的内部数组均是零值,因此需要首先提供给外界能够添加的接口,实现如下: func (myArr *MyDynamicArray) Add(index, value int) { if myArr.len == myArr.cap { return } if index myArr.len { return } for i := myArr.len - 1; i >= index; i-- { (*myArr.ptr)[i+1] = (*myArr.ptr)[i] } (*myArr.ptr)[index] = value myArr.len++ } 由于默认的初始化工厂函数暂时是固定长度的数组,因此新增元素其实是操作固定长度的数组,不过这并不妨碍后续实现动态数组部分. 为了操作方便,再提供插入头部和插入尾部两种接口,可以基于动态数组实现比较高级的数据结构. func (myArr *MyDynamicArray) AddLast(value int) { myArr.Add(myArr.len, value) } func (myArr *MyDynamicArray) AddFirst(value int) { myArr.Add(0, value) } 为了方便测试动态数组的算法是否正确,因此提供打印方法查看数组结构. 由此可见,打印方法显示的数据结构和真实的结构体数据是一样的,接下来我们就比较有信心继续封装动态数组了! func (myArr *MyDynamicArray) Set(index, value int) { if index = myArr.len { return } (*myArr.ptr)[index] = value } func (myArr *MyDynamicArray) Get(index int) int { if index = myArr.len { return -1 } return (*myArr.ptr)[index] } 这两个接口更加简单,更新数组指定索引的元素以及根据索引查询数组的值. 接下来让我们开始测试一下动态数组的全部接口吧! 动态数组暂时告一段落,不知道你是否好奇为什么以动态数组为例讲解面向对象? 其实主要是为了验证上一篇文章中的猜想,也就是切片和数组的到底是什么关系? 我觉得切片的底层是数组,只不过语法层面提供了支持以至于看不出数组的影子,仙子阿既然学习了面向对象,那么就用面向对象的方式实现下切片的功能,虽然无法模拟语法级别的实现,但是功能特性完全是可以模仿的啊! 下面还是梳理总结一下本文的只要知识点吧,也就是封装的实现. 如何封装结构体 之所以称之为结构体是因为 Go 的关键字是 struct 而不是 class,也是面向对象编程风格中唯一支持的特性,继承和多态都不支持,到时候另开文章细说. 结构体是对数据进行封装所使用的手段,结构体内只能定义数据而不能定义方法,这些数据有时候被称为字段,有时候叫做属性或者干脆叫做变量,至于什么叫法不是特别重要,如何命名和所处的环境语义有关. type MyDynamicArray struct { ptr *[10]int len int cap int } 这种结构体内就有三个变量,变量之间直接换行进行分隔而不是分号并换行的形式,刚开始觉得有些怪,不过编辑器一般都很智能,假如习惯性添加了分号,会提示你进行删除,所以语法细节上不必在意. 结构体内不支持编写函数,仅支持数据结构,这样就意味着数据和行为是分开的,两者之间的关联是比较弱的. func (myArr *MyDynamicArray) IsEmpty() bool { return myArr.len == 0 } 这种方式的函数和普通函数略有不同,将包含结构体变量的参数提前到函数名前面,语义上也比较明确,表示的是结构体的函数,为了和普通函数有所区别,这种函数称之为方法. 其实,单纯地就实现功能上看,方法和函数并没有什么不同,无外乎调用者的使用方式不一样罢了! func IsEmpty(myArr *MyDynamicArray) bool { return myArr.len == 0 } 之所以是这种设计方式,一方面体现了函数的重要性,毕竟是 Go 语言中的一等公民嘛! 另一方面是为了实现面向对象的语法习惯,不论属性还是方法,统统用点 . 操作符进行调用. 官方的文档中将这种结构体参数称之为接收者,因为数据和行为是弱关联的,这里的接收者充当的就是关联数据的作用,接收者顾名思义就是接受数据的人,那发送数据的人又是谁呢? 不言而喻,发送者应该是调用者传递的结构体实例对象,结构体变量将数据结构发送给接收者方法,从而数据和行为联系在一起了. func TestMyDynamicArray(t *testing.T) { myDynamicArray := NewMyDynamicArray() fmt.Println(myDynamicArray.IsEmpty()) } 好了,以上就是面向对象初体验中的全部部分,仅仅是这么一小部分却耗费我整整三天的时间了,想说换种思维不简单,写好一篇文章也不容易啊! 下篇文章中将继续介绍面向对象的封装特性,讲解更多干货,如果觉得本文对你有所帮助,欢迎转发评论,感觉你的阅读! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/oop/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/oop/encapsulation.html":{"url":"go/oop/encapsulation.html","title":"再说封装","keywords":"","body":"再说封装 关注公众号[雪之梦技术驿站]查看上篇文章 猜猜看go是不是面向对象语言？能不能面向对象编程？ 虽然在上篇文章中,我们通过尝试性学习探索了 Go 语言中关于面向对象的相关概念,更确切的说是关于封装的基本概念以及相关实现. 但那还远远不够,不能满足于一条路,而是应该尽可能地多走几条路,只有这样才能为以后可能遇到的问题积攒下来经验,所以这一节我们将继续探索封装. 何为探索性学习 通过现有知识加上思想规则指导不断猜想假设逐步验证的学习过程是探索性学习,这样既有利于我们思考又能加深我们对新知识的理解,何乐而不为? 学习 Go 语言的过程越发觉得吃力,倒不是因为语法晦涩难懂而是因为语法习惯背后蕴藏的思维习惯差异性太大! Go 语言相对于其他主流的编程语言来说是一种新语言,不仅体现在语法层面更重要的是实现思路的差异性. 尤其是对于已有其他编程经验的开发者而言,这种体会更加深刻,原本可能觉得理所应当的事情到了 Go 语言这里基本上都变了模样,很大程度上都换了一种思路去实现,这其实是一件好事,不同的思维碰撞才能促进思考进步,一成不变的话,谈何创新发展? 在这里不得不感谢强大的 IDE 开发工具,没有它我们就不能及时发现错误,正是这种快速试错的体验才给我们足够的反馈,运用已有的编程经验逐步接近 Go 语言编程的真相. 上篇文章中已经确定主线方向,基本上弄清楚了面向对象中的封装概念以及实现,为了不遗漏任何可能重要的知识点,本文将继续开放性探索,力争讲解清楚封装的知识点. 如果这种学习的过程用走迷宫来比喻的话,一条道走到黑这种策略就是算法理论中的深度优先算法.如果边走边看,四处观望周围的风景就是广度优先算法. 所以,聪明的你肯定已经猜到了,上文采用的正是深度优先算法而本文则采用广度优先算法继续探索封装对象之旅! 定义结构体 结构体的定义方式只有一种,或者不存在简化形式吗? 个人觉得不会不存在简化形式,当结构体存在多个字段,标准定义方式是合理使用的,但要是字段只有一个,仍然以标准形式定义结构体未免有种杀鸡焉用牛刀的感觉. type MyDynamicArray struct { ptr *[10]int len int cap int } 所谓的结构体只不过是实现封装的一种手段,当封装的对象只有一个字段时,这个字段也就不存在字段名或者说这个唯一的字段名应该就可以由编译器自动定义,因此字段名可以省略. 字段类型肯定是不可或缺的,这么想的话,对于封装只有一个字段的对象来说,只需要考虑的是这个唯一字段的类型. 基于上述原因,个人觉得是这种猜想是合情合理的,但是按照已有的知识能否实现呢? 简单起见,暂时先以上篇文章中关于动态数组的结构体声明为例作为测试案例. type MyDynamicArray struct { ptr *[10]int len int cap int } 如果一定要从三个字段中选择一个字段,那只能是保留内部数组,排除其余字段了,同时最终结果上可能实现不了动态数组的功能,语义上会有所欠缺,那就不论语义,只谈技术! 由于只保留内部数组,动态数组就变成下面这样.失去了动态数组的语义,命名上也做了改变,姑且称之为 MyArray 吧! type MyArray struct { arr [10]int } 很明显,现在仍然是结构体的标准语法形式,请随我一起思考一下如何简化这种形式? 因为这种简化形式的内部字段只有一个,所以字段名必须省略而字段类型可能不同,因此应该在简化形式中只保留声明内部字段类型的部分. type MyArray struct { [10]int } 由于多个字段时才需要换行分隔,一个字段自然是不需要换行的,因此大括号也是没必要存在的,这也是符合 Go 设计中尽可能精简的情况下保证语义清晰的原则. 当然如果你问我是否真的有这个原则的话,我的回答是可能有也可能没有. 因为我也不知道,只是近期学习 Go 语言的一种感觉,处处体现了这么一种哲学思想,也不用较真,只是个人看法. type MyArray struct [10]int 现在这种形式应该可以算是只有一种字段的结构体的简化形式,struct 语义上指明了 MyArray 是结构体,紧随后面的 [10]int 语义上表示结构体的类型,整体上就是说 MyArray 结构体的类型是 [10]int . 现在让我们在编辑器中测试一下,看一看 Go 的编译会不会报错,能否验证我们的猜测呢? 很遗憾,IDE 编辑器告诉我们 [10]int 不合法,必须是类型或类型指针! 可 [10]int 确实是我们需要的类型啊,既然报错也就是说Go 编译器不支持这种简化形式! 个人猜测可能是 struct 关键字不支持这种简化形式,那就去掉这个关键字好了! 没想到真的可以! 至少现在看来 Go 编译器是支持简化形式的,至于这种支持的形式和我们预期实现的语义是否一致,暂时还不好说,继续做实验探索吧! 通过声明变量后直接打印,初步证明了我们这种简化形式是可以正常工作的,输出结果也是我们定义的内部数组! 接下来看一看能不能对这个所谓的内部数组进行操作呢? 这种简化形式只有一个字段,只指明了字段的类型,没有字段名,因而访问该字段应该直接通过结构体变量访问,不知道这种猜测是否正确,依旧做实验来证明. type MyArray [10]int func TestMyArray(t *testing.T) { var myArr MyArray // [0 0 0 0 0 0 0 0 0 0] t.Log(myArr) myArr[0] = 1 myArr[9] = 9 // [1 0 0 0 0 0 0 0 0 9] t.Log(myArr) } 这一次猜想也得到了验证,Go 编译器就是通过结构体变量直接操作内部字段,看来我们离真相更进一步! 先别急着高兴,将唯一的字段换成其他类型,多测试几遍看看是否依然正常? type MyBool bool func TestMyBool(t *testing.T) { var myBool MyBool // false t.Log(myBool) myBool = true // true t.Log(myBool) } 一番测试后并没有报错,很有可能这是 Go 所支持的结构体简化形式,也和我们的预期一致. 关于结构体属性的语法规则暂时没有其他探索的新角度,接下来开始探索结构体的方法. 探索的过程中要尽可能的设身处地思考 Go 语言应该如何设计才能方便使用者,尽可能地把自己想象成 Go 语言的设计者! 结构体的简化形式下可能并不支持方法,如果真的是这样的话,这样做也有一定道理. 首先就语法层面分析,为什么单字段的结构体不支持方法? 还记得我们想要简化单字段结构体遇到的报错提示吗? type MyArray struct [10]int 如果直接将单字段类型放到 struct 关键字后面,Go 编译器就会报错,当我们省略 struct 关键字时上述报错自然就消失了. 从Go 编译器的角度上来讲,struct 是系统关键字,告诉编译器只要遇到这个关键字就解析成结构体语法,现在没有遇到 sruct 关键字也就意味着不是结构体语法. 这里关键字和结构体是一一对应关系,也就是充分必要条件,由关键字可以推测到结构体,由结构体也可以推测到关键字. 再回来看一看,我们的单字段结构体是怎么定义的呢? type MyArray [10]int 因为没有关键字 struct ,所以编译器推断 MyArray 不是结构体,既然不是结构体,也不能用结构体的接收者函数去定义方法. func (myBool *MyBool) IsTrue() bool{ return myBool } 所以这种方法就会报错,由此可见 ,Go 语言如果真的不支持单字段结构体方法也有理可循. 然后我们再从语义的角度上解释一下为什么不支持方法? 回到探索的初衷,当正在定义的结构体有多个字段时,应该按照标准写法为每个字段指定字段的名称和类型. 假如该字段有且只有一个时,再按照标准写法定义当然可以,但也应该提供更加简化的写法. 只有一个字段的结构体,字段名称是没有意义的也是不应该出现的,因为完全可以用结构体变量所代替,此时这个结构体唯一有存在价值的就是字段的类型了! 字段类型包括内建类型和用户自定义结构体类型,不论哪种类型,这种简化形式的结构体的语义上完全可以由该结构体的字段类型所决定,所以简化形式的结构体还需要方法吗? 自然是不需要的! 字段类型可以由字段类型自己定义的,也能确保职责清晰,彼此分离! 综上,个人觉得即便 Go 真的不支持单字段结构体的方法,背后的设计还是有章可循的,有理可依的! 上文中定义动态数组时,内部使用的数组是静态数组,现在为了方便继续探索方法,应该提供重载方法使其支持动态数组. func NewMyDynamicArray() *MyDynamicArray { var myDynamicArray MyDynamicArray myDynamicArray.len = 0 myDynamicArray.cap = 10 var arr [10]int myDynamicArray.ptr = &arr return &myDynamicArray } 内部数组 arr 是静态数组,应该提供可以让外部调用者初始化指定数组的接口,按照已知的面向对象中关于方法的定义来重载方法. 初次尝试方法的重载就遇到了问题,报错提示该方法已声明,所以说 Go 可能并不支持方法重载,这样就有点麻烦了. 想要实现类似的功能要么通过定义不同的方法名,要么定义一个非常大的函数,接收最全的参数,再根据调用者参数进行对应的逻辑处理. 用惯了方法的重载,突然发现这种特性在 Go 语言中无法实现,顿时有点沮丧,和其他主流的面向对象语言差异性也太大了吧! 不支持构造函数,不支持方法重载,原来以为理所应当的特性并不理所应当. 还是先冷静下来想一想,Go 为什么不支持方法重载呢?难不成和构造函数那样,怕是滥用干脆禁用的逻辑? 因为我不是设计者,无法体会也不想猜测原因,但可以肯定的是,Go 语言是一门全新的语言,有着独特的设计思路,不与众人同! 吐槽时间结束,既然上了贼船就得一条道走到黑,不支持方法重载就换个函数名或者按参数名区分. 天啊撸,刚刚解决方法重载问题又冒出数组初始化不能是变量只能是常量表达式? 简直不可思议! 既然数组初始化长度只是常量表达式,也就无法接收外部传递的容量 cap,没有了容量只能接收长度 len ,而初始化内部数组长度又没办法确定了,两个变量都无法对外暴露! 一切又回到原点,想要实现动态数组的功能只能靠具体的方法中去动态扩容和缩容,不能初始化指定长度了. 这样的话,关于方法也是一条死路,停止探索. 声明结构体 结构体定义基本已经探索完毕,除了发现一种单字段结构体的简化形式外,暂时没有新的发现. 再次回到使用者的角度上,声明结构体有没有其他方式呢? var myDynamicArray MyDynamicArray t.Log(myDynamicArray) 这是变量的声明方式,除了这种形式,还记得在学习 Go 的变量时曾经介绍过声明并初始化变量方式,是否也适用于结构体变量呢? var myDynamicArray = MyDynamicArray{ } t.Log(myDynamicArray) 编译器没有报错,证明这种字面量形式也是适用的,不过空数据结构没有太大的意义,怎么能初始化对应的结构呢? 和多字段结构体最为相似的数据结构莫过于映射 map 了! 回忆一下 map 如何进行字面量初始化的吧! var m = map[string]string{ \"id\": \"1006\", \"name\": \"雪之梦技术驿站\", } t.Log(m) 模仿这种结构看看能不能对结构体也这么初始化,果然就没有那么顺利! 我还没定义,你就不行了? IDE 编辑器提示字段名称无效,结构体明明就有 len 字段啊,除非是没有正确识别! \"len\" 与 len 是不一样的吧? 那就去掉双引号 \"\" 直接使用字段名进行定义看看. var myDynamicArray = MyDynamicArray{ len: 10, } t.Log(myDynamicArray) 此时报错消失了,成功解锁一种新的隐藏技能. var myDynamicArray = MyDynamicArray{ ptr: &[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, len: 10, cap: 10, } t.Log(myDynamicArray) 除了这种指定字段名称注入方式,能不能不指定字段名称而是按照字段顺序依次初始化? 借助编辑器可以看到确实是按照顺序注入的,这样的话,其实有点意思了,明明不支持构造函数,采用字面量实例化时却看起来像构造函数的无参,有参数和全参形式? 可以预想到的是,这种全参注入的方式一定是严格按照定义顺序相匹配的,当参数不全时可能按位插入也可能不支持,真相如何,一试便知! 事实上并不支持这种参数不全的形式,因此个人觉得要么无参要么全参要么指定初始化字段这三种语义上还是比较清楚的. 除了字面量的方式,Go 是否支持创建 slice 或 map 时所使用的 make 函数呢? 看样子,make 函数并不支持创建结构体,至于为什么不支持,原因就不清楚了,也是个人的一个疑惑点. 既然 make 可以创建 slice ,map 这种内建类型,语义上就是用来创建类型的变量,而结构体也是一种类型,唯一的差别可能就是结构体大多是自定义类型而不是内建类型. 如果我来设计的话,可能会一统天下,因为语义上一致的功能只使用相同的关键字. 回到面向对象的传统编程规范上,一般实例化对象用的是关键字 new,而 new 并不是 Go 中的关键字. Go 语言中的函数是一等公民,正如刚才说的 make 也不是关键字,同样是函数. 即便对于同一个目标,Go 也是有着自己的独到见解! new 不是以关键字形式出现而是以函数的身份登场,初步推测应该也具备实例化对象的能力吧? 难道 new 函数不能实例化对象?为什么报错说赋值错误,难不成姿势不对? 吓得我赶紧看一下 new 的文档注释. // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type 根据注释说明,果然是使用姿势不对,并不像其他的面向对象语言那样可以重复赋值,Go 不支持这种形式,还是老老实实初始化声明吧! var myDynamicArray2 = new(MyDynamicArray) t.Log(myDynamicArray2) 既然存在着两种方式来实例化对象,那么总要看一下有什么区别. func TestNewMyDynamicArray(t *testing.T) { var myDynamicArray = MyDynamicArray{ ptr: &[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, len: 10, cap: 10, } myDynamicArray = MyDynamicArray{ &[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, 10, 10, } t.Log(myDynamicArray) t.Logf(\"%[1]T %[1]v\", myDynamicArray) var myDynamicArray2 = new(MyDynamicArray) myDynamicArray2.ptr = &[10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} myDynamicArray2.len = 10 myDynamicArray2.cap = 10 t.Log(myDynamicArray2) t.Logf(\"%[1]T %[1]v\", myDynamicArray2) } 这里简单解释下 t.Logf(\"%[1]T %[1]v\", myDynamicArray) 语句是什么意思? %[1]T 其实是 %T 的变体,%[1]v 也是 %v 的变体,仔细观察的话就会发现占位符刚好都是同一个变量,这里也就是第一个参数,所以就用 [1] 替代了,再次体现了 Go 语言设计的简洁性. 下面再举一个简单的例子加深印象,看仔细了哦! test := \"snowdreams1006\" // string snowdreams1006 t.Logf(\"%T %v\", test, test) t.Logf(\"%[1]T %[1]v\", test) %T 是打印变量的类型,应该是类型 type 的缩写,v 应该是值 value 的缩写. 解释清楚了测试代码的含义,再回头看看测试结果,发现采用字面量方式得到的变量类型和 new 函数得到的变量类型明显不同! 具体表现为 _struct.MyDynamicArray {0xc0000560f0 10 10} 是结构体类型,而 *_struct.MyDynamicArray &{0xc000056190 10 10} 是结构体类型的指针类型. 这种差异也是可以预期的差异,也是符合语义的差异. 字面量实例化的对象是值对象,而 new 实例化对象开辟了内存,返回的是实例对象到引用,正如其他编程语言的 new 关键字一样,不是吗? 既然说到了值对象和引用对象,再说一遍老生常谈的问题,函数或者说方法传递时应该传递哪一种类型? 值传递还是引用传递 接下来的示例和动态数组并没有什么关系,简单起见,新开一个结构体叫做 Employee,顺便回顾一下目前学到的封装知识. type Employee struct { Id string Name string Age int } func TestCreateEmployee(t *testing.T) { e := Employee{ \"0\", \"Bob\", 20, } t.Logf(\"%[1]T %[1]v\", e) e1 := Employee{ Name: \"Mike\", Age: 30, } t.Logf(\"%[1]T %[1]v\", e1) e2 := new(Employee) e2.Id = \"2\" e2.Name = \"Rose\" e2.Age = 18 t.Logf(\"%[1]T %[1]v\", e2) } 首先测试引用传递,这也是结构体常用的传递方式,行为表现上和其他的主流编程语言表现一致,方法内的修改会影响调用者的参数. func (e *Employee) toStringPointer() string { fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\", e.Id, e.Name, e.Age) } func TestToStringPointer(t *testing.T) { e := &Employee{\"0\", \"Bob\", 20} fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) t.Log(e.toStringPointer()) } unsafe.Pointer(&e.Name) 是查看变量的内存地址,可以看出来调用前后的地址是同一个. func (e Employee) toStringValue() string { fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\", e.Id, e.Name, e.Age) } func TestToStringValue(t *testing.T) { e := Employee{\"0\", \"Bob\", 20} fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) t.Log(e.toStringValue()) } 调用者发送的内存地址和接收者接收的内存地址不一样,符合期望,值传递都是拷贝变量进行传递的嘛! 值类型还是引用类型的区分无需赘述,接下来请关注一个神奇的事情,方法的接收者是值类型,方法的调用者是不是一定要传递值类型呢? func (e Employee) toString() string { fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) return fmt.Sprintf(\"ID:%s-Name:%s-Age:%d\", e.Id, e.Name, e.Age) } 方法的调用者分别传递值类型和引用类型,两者均能正常工作,是不是很神奇,好像和方法的定义没什么关系一样! func TestToString(t *testing.T) { e := Employee{\"0\", \"Bob\", 20} fmt.Printf(\"Name address is %x\\n\", unsafe.Pointer(&e.Name)) t.Log(e.toString()) t.Log((&e).toString()) } 虽然方法的接收者要求的是值类型,调用者传递的是值类型还是引用类型均可! 仅仅更改了方法接收者的类型,调用者不用做任何更改,依然可以正常运行! 这样就很神奇了,方法的接受者不论是值类型还是指针类型,调用者既可以是值类型也可以是指针类型,为什么? 同样的,基于语义进行分析,方法的设计者和调用者之间可以说是松耦合的,设计者的更改对于调用者来说没有太大影响,这也就意味着以后设计者觉得用值类型接收参数不好,完全可以直接更改为指针类型而不用通知调用者调整逻辑! 这其实要归功于 Go 语言到设计者很好的处理了值类型和指针类型的调用方式,不论是值类型还是引用类型,一律使用点操作符 . 调用方法,并不像有的语言指针类型是 -> 或 * 前缀才能调用指针类型的方法. 有所为有所不为,可能正是看到了这两种调用方式带来的差异性,Go 全部统一成点操作符了! 虽然形式上两种调用方式是一样的,但是设计方法或者函数时到底应该是值类型还是指针类型呢? 这里有三点建议可供参考: 如果接收者需要更改调用者的值,只能使用指针类型 如果参数本身非常大,拷贝参数比较占用内存,只能用指针类型 如果参数本身具有状态,拷贝参数可能会影响对象的状态,只能用指针类型 如果是内建类型或者比较小的结构体,完全可以忽略拷贝问题,推荐用值类型. 当然,实际情况可能还和业务相关,具体用什么类型还要自行判断,万一选用不当也不用担心,更改一下参数类型就好了也不会影响调用者的代码逻辑. 封装后如何访问 封装问题基本上讲解清楚了,一般来说,封装之后的结构体不仅是我们自己使用还有可能提供给外界使用,与此同时要保证外界不能随意修改我们的封装逻辑,这一部分就涉及到访问的控制权限了. Go 语言的访问级别有两种,一种是公开的另一种就是私有的,由于没有继承特性,也不涉及子类和父类之间访问权限继承问题,顿时觉得没有继承也不是什么坏事嘛,少了很多易错的概念! 虽然现在理解起来很简单,具体实际使用上是否便利还不好判断. 关于可见性的命名规范如下: 名称一般使用大驼峰命名法即 CamelCase 首字母大写表示公开的 public ,小写表示私有的 private . 上述规则不仅适用于方法,包括结构体,变量和常量等几乎是 Go 语言的全部. 那么问题了,这里的 public 和 private 是针对谁来说? Go 语言中的基本结构是包 package,这里的包和目录有区别,并不像 Java 语言那样包和目录严格相关联的,这一点对于 Java 小伙伴来说需要特别注意. 包是相关代码的集合,这些代码可能存放于不同的目录文件中,就是通过包 package 的声明告诉 Go编译器说:我们是一个家族整体. 如果不同的文件目录可以声明在同一个包中,这样相当于允许家族外迁,只保留姓氏就好. 还是用代码说话吧,散落在各地的小伙伴能不能有共同的姓氏! package main import ( \"fmt\" \"github.com/snowdreams1006/learn-go/oop/pack\" ) func main() { var l = new(pack.Lang) l.SetName(\"Go\") l.SetWebsite(\"https://golang.google.cn/\") fmt.Println(l.ToString()) } pack.go 源码文件和 pack_test 测试文件都位于相同的目录 pack 下且包的声明也相同都是 pack. 这种情况相当于一家氏族位于一个村落中一起生活,和其他语言到表现一致. 现在试一下这个氏族的一部分人能不能搬到其他村落居住呢? 难不成跨域地域有点大,不支持定义方法吗?那移动一下使其离 pack 目录近一点试试看! 还是不行,不能新建子目录,那么和原来在一个目录下呢? 只有这样是可以被标识位结构体的方法的,如果不是方法,完全可以任意存放,这一点就不再演示了,小伙伴可自行测试一下哟! package main import ( \"fmt\" \"github.com/snowdreams1006/learn-go/oop/pack\" ) func main() { var l = new(pack.Lang) l.SetName(\"Go\") l.SetWebsite(\"https://golang.google.cn/\") fmt.Println(l.ToString()) l.PrintLangName() } \"github.com/snowdreams1006/learn-go/oop/pack\" 是当前文件中导入依赖包路径,因此调用者能否正常访问到我们封装的结构体. 在当前结构体中的属性被我们设置成了小写字母开头,所以不在同一包是无法访问该属性的. 封装后如何扩展 设计者封装好对象供其他人使用,难免会有疏忽不足之处,此时使用者就需要扩展已存在的结构体了. 如果是面向对象的设计思路,最简单的实现方式可能就是继承了,重写扩展什么的都不在话下,可是 Go 并不这么认为,不支持继承! 所以剩下的方法就是组合了,这也是学习面向对象时的前人总结的一种经验: 多用组合少用继承! 现在想一想,Go 语言不但贯彻了这一思想,更是严格执行了,因为 Go 直接取消了继承特性. type MyLang struct { l *Lang } func (ml *MyLang) Print() { if ml == nil || ml.l == nil { return } fmt.Println(ml.l.ToString()) } func TestMyLangPrint(t *testing.T) { var l = new(Lang) l.SetName(\"Go\") l.SetWebsite(\"https://golang.google.cn/\") var ml = MyLang{l} ml.Print() } 通过自定义结构体内部属性是 Lang 类型,进而扩展原来 Lang 不具备的方法或者重写原来的方法. 如果我们的自定义结构体刚好只有这么一个属性,完全可以使用简化形式,说到这里其实有必要特别说明一下,专业叫法称之为别名. type Lan Lang func (l *Lan) PrintWebsite(){ fmt.Println(l.website) } func TestLanPrintWebsite(t *testing.T) { var la = new(Lan) la.name = \"GoLang\" la.website = \"https://golang.google.cn/\" la.PrintWebsite() } 作为设计者和使用者都已经考虑到了,封装的基本知识也要告一段落了,由于 Go 不支持继承,也没必要演示相关代码,唯一剩下的只有接口了. 虽然 Go 同样是不支持多态,但是 Go 提供的接口确实与众不同,别有一番滋味在心头,下一节将开始探索接口. 关于封装的复盘 定义结构体字段 type Lang struct { name string website string } 结构体有多个字段时彼此直接换行,不用逗号也不用分号之类的,不要多此一举. 定义结构体方法 func (l *Lang) GetName() string { return l.name } 原本是普通的函数,函数名前面加入指向当前结构体的参数时,函数不再是函数而是方法,同时当前结构体参数叫做接收者,类似于其他面向对象语言中的 this 或 self 关键字实现的效果. 字面量声明结构体 func TestInitLang(t *testing.T) { l := Lang{ name: \"Go\", website: \"https://golang.google.cn/\", } t.Log(l.ToString()) } 字面量声明结构体除了这种类似于有参构造函数使用方式,还有无参和全参构造函数使用方式,这里说的构造函数只是看起来像并不真的是构造函数. new 声明结构体 func TestPack(t *testing.T) { var l = new(Lang) l.SetName(\"Go\") l.SetWebsite(\"https://golang.google.cn/\") t.Log(l.ToString()) } new 函数和其他主流的编程语言 new 关键字类似,用于声明结构体,不同于字面量声明方式,new 函数的输出对象是指针类型. 首字母大小写控制访问权限 不论是变量名还是方法名,名称首字母大写表示公开的,小写表示私有的. 代码的基本组织单元是包 访问控制权限也是针对代码包而言,一个目录下只有一个代码包,包名和目录名没有必然联系. 复合扩展已有类型 type MyLang struct { l *Lang } func (ml *MyLang) Print() { if ml == nil || ml.l == nil { return } fmt.Println(ml.l.ToString()) } func TestMyLangPrint(t *testing.T) { var l = new(Lang) l.SetName(\"Go\") l.SetWebsite(\"https://golang.google.cn/\") var ml = MyLang{l} ml.Print() } 自定义结构体内嵌其他结构体,通过复合而不是继承的方式实现对已有类型的增强控制,也是一种推荐的编程规范. 别名扩展已有类型 type Lan Lang func (l *Lan) PrintWebsite() { fmt.Println(l.website) } 别名可以看成单字段结构体的简化形式,可以用来扩展已存在的结构体类型,也支持方法等特性. 最后,非常感谢你的阅读,鄙人知识浅薄,如有描述不当的地方,还请各位看官指出,你的每一次留言我都会认真回复,你的转发就是对我最大的鼓励! 如果需要查看相关源码,可以直接访问 https://github.com/snowdreams1006/learn-go,同时也推荐关注公众号与我交流. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/oop/encapsulation.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/oop/inheritance.html":{"url":"go/oop/inheritance.html","title":"能否继承","keywords":"","body":"能否继承 熟悉面向对象的小伙伴们可能会知道封装,继承和多态是最主要的特性,为什么前辈们会如此看重这三种特性,真的那么重要吗? 什么是封装 什么是封装,封装有什么好处以及怎么实现封装? 相信大多数小伙伴们都有自己的理解,简而言之,言而简之,封装是屏蔽内部实现细节,仅仅对外暴露出有价值接口. 正如平时工作中使用的电脑一样,我们并不关心电脑的内部组成,只要会开机关机等基本操作就能正常使用电脑,即便坏了的话,也是送去专业维修店进行修理,作为使用者来说,我们从始至终并不关心电脑的工作原理以及它如何工作,唯一在乎的就是怎么能够上网. 之所以我们能如何方便地使用电脑进行网上冲浪,完全得益于电脑设计者对普通用户屏蔽了无关细节,只暴露有价值的操作方法,这种实现方式就是封装. 回到编程语言上,Go 语言作为一种通用的编程语言,和其他主流的编程语言一样支持封装,Go 语言关于封装的实现主要包括两部分: 数据结构的封装 行为方法的控制 其中数据结构的封装主要是使用结构体关键字 struct 实现,而行为方法的控制是用首字母大小写区分是否对外可见. 关于 Go 如何实现封装的细节,可以参考前一篇文章: go 学习笔记之详细说一说封装是怎么回事 继承是怎么回事 说完封装,接着说一下继承是怎么回事? 继承正是在封装的基础上逐步发展产生的概念,我们知道封装是对某一类行为事物模型的抽象,而这种抽象恰恰是由人定义实现的,因人而异也就导致了封装并没有统一的标准答案. 于是乎就可能存在着这么一种情况,对于生活中常见的猫和狗,两个人分别有两种封装方式: A: 猫是一种宠物,淘气可爱会卖萌,看家本领抓老鼠,偶尔还会喵喵喵. B: 狗是一种宠物,忠实听话能看家,嗅觉灵敏会破案,一言不合汪汪汪. C: 我想要买一个宠物,文能卖萌,武可退敌,明个一早给我送来吧! 由于客户C并没有特别说明要的是猫还是狗,A以为是猫,因为猫安静的时候很萌很可爱,生气的时候用小爪爪挠你! B以为是狗,汪星人的名气可不是自吹自擂,真的要惹怒了它,咬住不放能生生撕下一块肉,你说这种武力值强不强大? 于是第二天,客户C懵逼了,怎么一下子送来了猫狗两个宠物啊,可是又不能食言,因为A和B说的都有道理啊! 等 A和 B走了后,C望着送来的猫和狗,不禁陷入了深思:我只是想要一个宠物而已,非要给我猫和狗两个选择,我有选择困难症啊! 说完这个故事,刚开始会觉得有些滑稽,C只要随便选择一种宠物不就好了吗,干嘛非要全盘接收弄得自己不开心呢? 不知道正在看的读者有没有选择困难症的经历,面对多种选择,一时不知道到底选择哪一个,最终结果可能有三种情况:全盘肯定,全盘否定和部分肯定. 上述故事中,C选择的是全盘肯定,A和B送来的猫和狗都是宠物,没理由拒绝任何一个,于是C选择全盘肯定,当然至于以后是否后悔只有 C自己心里清楚. 前车之鉴可以为师矣,如果下次我们也遇到这种情况应该如何选择呢? 相信聪明的你心中已经有了自己的答案,大声的说出来吧!我就要喵喵喵! 上述案例就好比同事间一起去吃饭,点餐时问你点些什么?你说随便! 原本是好意,以为能自己这么说能方便其他人,其实这种看似不挑剔的做法,对他人来说可能也是最难办的事情. 因为随便的范围太宽泛了,什么都可以也就意味着很大可能上并不会令你满意,你在方便别人的同时,他人也在想法设法取悦于你,不知道你的喜好,心里就犯嘀咕了,这个他喜不喜欢吃呢? 所以,请不要再说随便,勇敢亮出你的观点态度,哪怕不被认可满足. 故事中 A觉得猫是宠物,B觉得狗是宠物,因而当客户真的要宠物时,A和 B都把各自的宠物送上去了,因此问题出现在宠物的定义上,到底什么算是宠物? 其实C心中已经有了宠物的定义,那就是\"文能卖萌,武可退敌\",而猫和狗恰好都具备这种特性,因此对外宣传时就不要再说这种默认的属性,应该亮出自己的特色! A: 猫会抓老鼠 B: 狗能认清路 C: 我要一种宠物,出现意外时能帮助到我的话,那就再好不过了! 如果一开始他们就这样说的话,C真正需要的宠物到底是猫还是狗就一目了然了,也不会陷入选择困难症了! 如何实现继承 回到封装的话题上来,转换成编程语言就是A把猫封装成宠物了,B把狗封装成宠物了,而 C需要宠物时,猫和狗都是宠物,最终结果要么是程序依旧正常运行,要么是程序意外挂掉了,因为很可能某一种宠物可能并不符合特定需求. 这种重复定义问题归咎于封装的标准不同,猫和狗两者的封装过程是独立进行的,并没有在一起商量着看看能不能继续抽象出通用模型,混乱的封装导致了猫是宠物,狗也是宠物. 这种多种相关概念的封装很容易出现此类问题,所以适当进行统一分析继续抽象出更高层次的封装概念尤为重要,基于此,原来的封装就能从这种通用概念中解放出来,仅仅保留自己的特色就好,大大简化了模型的语义. 普通封装的概念和更高层次的抽象封装概念的关系就是面向对象中的继承,即猫继承于宠物,表示猫不但拥有宠物的特点还有猫自己的亮点. 对于狗也是一样,狗是宠物,狗也是狗自己本身,体现了自己的特点. Go 语言和其他主流的面向对象语言有所不同,Go 并不支持继承特性,因而也没有单继承,多继承,重写方法等复杂概念. 那 Go 是如何描述这种普通封装和抽象封装之间的关系呢? 肯定不是把猫定义成宠物,狗也定义成宠物那种方式! Go 实现继承的语义不是通过 extends 关键字而是通过结构体组合的方式,请看相关代码. 宠物就应该能文能武,这里不关心结构体的字段,因而并没有定义相关字段. type Pet struct { } func (p *Pet) Skill() { fmt.Println(\"能文能武的宠物\") } 猫是能够抓老鼠的宠物,Go 采用组合的方式表达继承的语义. type Cat struct { p *Pet } func (c *Cat) Catch() { fmt.Println(\"老鼠天敌喵喵喵\") } 狗是自带导航功能的宠物,看我导盲犬的超能力! type Dog struct { p *Pet } func (d *Dog) Navigate() { fmt.Println(\"自带导航汪汪汪\") } 接下来,C开始检验猫和狗作为宠物是否具备能文能武的基本要求,与此同时有没有自身的特色? func TestExtendInstance(t *testing.T) { p := new(Pet) d := new(Dog) d.p = p // 自带导航汪汪汪 d.Navigate() // 能文能武的宠物 d.p.Skill() fmt.Println() c := new(Cat) c.p = p // 老鼠天敌喵喵喵 c.Catch() // 能文能武的宠物 c.p.Skill() } 上述结果证明,Go 语言虽然不支持 extends 关键字表达的继承特性,但是采用组合的方式也是可以实现继承语义的,毕竟,黑猫还是白猫,抓住老鼠的才是好猫! 面向对象的封装和继承暂时告一段落,下一篇文章中将开始讲解接口,以及面向对象中最后的一个概念: 多态! 感谢你的阅读,如果本文对你有所帮助,还望你能留言告诉我,也欢迎分享转发哟! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/oop/inheritance.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/oop/interface.html":{"url":"go/oop/interface.html","title":"初识接口","keywords":"","body":"初识接口 到底是要猫还是要狗 在上篇文章中,我们编撰了一则简短的小故事用于讲解了什么是面向对象的继承特性以及 Go 语言是如何实现这种继承语义的,这一节我们将继续探讨新的场景,希望能顺便讲解面向对象的接口概念. 为了照顾到没有看过上一节文章的读取,这里再简述一下上节文章关于买宠物的故事,如需详细了解,请自行翻阅历史文章进行查看. A: 猫是一种宠物,淘气可爱会卖萌,看家本领抓老鼠,偶尔还会喵喵喵. B: 狗是一种宠物,忠实听话能看家,嗅觉灵敏会破案,一言不合汪汪汪. C: 我想要买一个宠物,文能卖萌,武可退敌,明个一早给我送来吧! 于是,第二天,A和B各自带着自己的宠物来拜见C,并附上各自的理由,说的头头是道,C总觉得有些哪里不对,可一时间又无言反驳,只能悻悻收下了猫和狗,白白多花了一份钱! 这则故事很简单,但同时也暴露出一个问题,那就是在这场交易中,卖家实际上亏了,明明只是想买一个宠物,结果却买了两个! 当然,在上篇文中最后也给出了解决方案,那就是将猫和狗进行抽象封装,共性的部分提取成宠物,个性的部分才是猫和狗. 如此一来,顾客买宠物时要么买的是猫,要么面对是狗,具体买的是什么宠物是由顾客自己根据各自宠物的个性决定的,一定程度上解决了交易不公平的问题. 让我们再简单回忆一下继承的实现过程,回忆的过程中不妨思考一下继承有没有没能解决的问题? 宠物默认自带能文能武技能 type Pet struct { } func (p *Pet) Skill() { fmt.Println(\"能文能武的宠物\") } 猫是宠物,还是能抓老鼠的宠物. type Cat struct { p *Pet } func (c *Cat) Catch() { fmt.Println(\"老鼠天敌喵喵喵\") } 狗是宠物,还是能认路导航的宠物. type Dog struct { p *Pet } func (d *Dog) Navigate() { fmt.Println(\"自带导航汪汪汪\") } 某一天,C要能文能武的宠物,最好还可以顺便抓个老鼠,于是C选择了喵喵喵! func TestExtendInstance(t *testing.T) { p := new(Pet) c := new(Cat) c.p = p // 老鼠天敌喵喵喵 c.Catch() // 能文能武的宠物 c.p.Skill() } 过了一阵子,C觉得猫除了抓老鼠别的什么都不会,别人遛狗,我遛猫? 于是,想要一种能自带导航功能的宠物,毫无疑问的是,选择了狗. func TestExtendInstance(t *testing.T) { p := new(Pet) d := new(Dog) d.p = p // 自带导航汪汪汪 d.Navigate() // 能文能武的宠物 d.p.Skill() } 上述示例,简而言之就是通过组合的方式实现了面向对象中的继承特性,解决了猫和狗除了是宠物还是自己的问题. 猫狗随便是宠物就行 面对猫和狗两种宠物,顾客犯了选择困难症,于是第一次全盘照收买下了两种宠物,吃了一次哑巴亏. 后来在市场监督的介入下,利用面向对象的继承特性,用 Go 语言实现了猫和狗的个性化与宠物的共性化,从此像C一样的顾客再也不会面临选择困难症,每一次都要根据独特的需求,最终选择某一种宠物,要么是猫,要么是狗. 不知过了多久,这种相安无事的场景最终被一群急性子的顾客所打破,这一天宠物市场一大早就来一大批人,一上来就吵吵嚷嚷说快给我们一批宠物,我们要作为抽奖活动的奖品,一定要快一点! 谁知道销售人员不紧不慢地说: \"别着急,我们这里的宠物有很多种,有猫,有狗,有兔子,有金鱼,有乌龟,有蜗牛...\" \"别整那些虚头巴脑的,我只要宠物,赶紧给我宠物就行,别尽扯没用的\",顾客吵吵说. 果然是一群急性子的顾客,还没等销售人员介绍完各个宠物的差异性亮点直接被打断了. 宠物市场吵吵闹闹引来了市场监督人员的注意,顾客和商家均向官方诉苦,期望能给出一个解决办法! 市场监督人员心想: 商家和顾客原本和谐相处的,今天怎么会吵闹起来? 仔细听了事情来龙去脉,双方都没有过错,看来还真的是市场赶不上实际需求的变化,真得尽快研究新的解决办法才行啊! \"冷静一下,你们的意见我们这边已经知道了,这样吧,给我们三天的时间,我们一定会想出一个万全之策,到时候再公布新的交易规则,现在我宣布暂时关闭交易,省的再惹出不必要的争端!\" 原本吵吵嚷嚷的市场顿时冷却了不少,毕竟谁也不敢违抗市场老大的命令,众人只得悻悻而去,期待三天后的重新开市. 视角切换到市场监督大会上,主席首先开始发言:\"各位,现在市场面临的问题想必大家都有所耳闻吧,我们已经郑重承诺,三天后必须给市场一个答复,时间紧,任务重,大家要集思广益,一起解决这个难题!\" \"现在的顾客到底是怎么了,连自己到底想要什么都搞不清楚,还急冲冲地跑来买宠物,自己都不知道要买啥,鬼才知道呢!\",资历老练的继承经理抱怨道. \"经理说得对,他们自己都不知道到底想要啥宠物,怎么能埋怨商家太罗里吧嗦呢?人家那么卖力介绍宠物的特点,不也是帮助顾客更好的选择嘛!\",发言的是继承经理的小弟. \"...\" \"咳咳,我理解大家的心情,继承项目组确实在解决宠物问题上立下了很大功劳,大家为他们抱不平也是情理之中的事情,过去的就让他过去吧!当务之急,还是要解决现实问题!\",主席首先安抚前几位激动情绪,又挑出重点提醒在场的各位回归到主题的讨论上,不要再揪住过去的功劳簿. \"我觉得,心急顾客的真正需求只是想要一种宠物,而不再关注宠物的种类,管他是猫是狗,只要是宠物就行.所以我们应该提供一种新的机制,对外宣传时只说这是宠物,至于这种宠物到底是猫还是狗,都可以!\" \"猫和狗明明已经是宠物了啊,难道不可以直接卖给顾客吗?为啥还要提供新机制?\" \"猫和狗虽然是宠物,但对于用户来说,这种宠物有点浪费了,用户实际使用到可能只是宠物的功能,并不会用到也不能用到具体宠物的功能,所以对用户来说,这就是一种浪费.\" \"哦哦,明白了,这就像是顾客需要的宠物是能卖萌的,是要送给女朋友作为礼物的,并不关心这个宠物能不能抓老鼠.所以对于抓老鼠的技能就是没用的,而买家却要为抓老鼠的技能额外买单,这对于买家来说并不公平!\" 经过一番激烈的讨论,大家基本上达成一致,先前存在的继承模型确实有些不足,不能适应快速变化的市场,过于强调差异性而非共性. 这样就导致无法满足急性子顾客批量购买的需求,所以需要提供类似于继承那种抽象的概念来表达某种约定,只要满足这种约定的动物就是宠,不管是猫还是狗,哪怕是玩具也行! 让继承变得更加抽象 透过现象看本质,从纷繁冗杂的事务中抽象出精简的模型是各个编程语言都必不可少的一个环节,Go 语言当然也不例外. 面向对象编程中的继承概念表达是一种上下级的抽象关系,也就是说某一个封装对象是从属于特定上级的封装对象,默认拥有该上级的行为方法,这里的上级概念就是父类就是对所有子类共性的抽象实现. 当研究的问题就是具体的子类实现时,此时使用继承的概念,语义上比较清晰,子类只需要关注自己的特性,共性部分由父类去完成,这种思路也是非常自然的,猫是猫的同时也是一种宠物. 但是当我们研究的问题不再关注具体的子类实现而是着眼于父类的共性时,此时如果再提供具体的子类实现当然也能用,但是杀鸡焉用牛刀? 明明我仅仅需要一滴水,你却给了我整个海洋! 本来,真正需要的可能只是父类的某一个方法,你却提供给我一个具体的子类实现,这个子类不但拥有目标方法还有很多的其他方法. 既然有这么多的附加价值,你说浪费不浪费,销售时可不得涨价吗,这样不相当于捆绑销售了嘛! 所以,我们需要对继承的概念进一步抽象,使这种抽象达到一种极致状态以至于只存在非常少量的行为方法,凡是继承自这种极致抽象的子类都是它的子民. 为了之后讨论方便,业界将这种抽象到极致的继承关系称之为接口,虽然看似只是称呼的改变,但实际上思维方式上已经发生了翻天覆地的变化. 继承的概念是描述子类和父类的关系,子类继承自父类,关注点在子类,共性部分完全由父类实现,子类自然拥有这些行为能力. 而接口的概念衍生于继承,只不过是这种抽象程度已经达到了一种不能再抽象的地步,所有子类都要有一个最终的父类,这个父类拥有最公共性的行为方法,所以这种极致的抽象也就无法体现出子类的共性行为的具体表现.此时这种极致的抽象没有太大的意义,是一种非常非常宽泛的概念,等于什么都没说,所以也适合绝大部分封装对象. 所以,干脆取消了极致抽象中对于行为共性的实现,转而仅仅定义共性的行为,具体这种行为到底如何表现,完全由具体子类自行决定. 这样做有两个显而易见的好处,一是解决了太宽泛概念等于没说的尴尬,同时保留了对共性行为的描述.二是将控制权转移到具体的子类实现,实现了体制内的个性化! 所以这种专业名词的转变背后是思维方式的转变,而接口更是很好地描述了这种转变的语义. 回忆一下生活总随处可见的 USB 数据线,对于计算机来说,对外暴露的是 USB 插口,行为描述是只要插入就能连接到电脑,能够同电脑进行沟通交流,这种交流可能是传递数据,也可能是连接电源等等不同的行为表现. 基于接口设计,USB 数据线提供了访问电脑的能力,一端连着电脑,另一端连着手机,双方进行数据交换. 有线鼠标的数据线也提供了访问电脑的能力,实现鼠标的左击还是又击都能反馈到电脑. 诸如此类的案例不胜枚举,生活中不缺少计算机哲学,缺少的只是我们的思考. 所以,如果让我来给这种机制进行命名的话,我可能会将其称呼为插口,意思是只要能适配指定的插口,那么就说满足插口要求,对外暴露的抽象概念是插口,真正的实现可能是数据线或者工具等. 当然,这只是我的一厢情愿,因为面向对象中这种机制叫做接口,满足接口的规范叫做实现了接口. 接口这种概念显得比较专业,提出这个概念的人估计也是厉害人物,基本上所有的面向对象语言中都采用了接口的概念,即使不是面向对象语言但支持面向对象编程风格的 Go 语言也采用了接口概念. 由此可见,接口的概念应该是通俗易懂,可移值性比较强的,获得了相当高的认可度. 除了面向对象编程风格外,与接口相关的编程风格中还有一种叫做面向接口编程,这个会在以后的文章中继续分享这封面的内容. 个人理解封装和继承的概念,讲的就是面向对象编程,关注点在于具体的对象以及对象之间的层次关系. 而接口的出现则是另外一种维度的思考,当关注点不再是具体的子类而是抽象的父类,这种情况下则根据实际情况抽象出了接口的概念,由此看出,面向对象编程中高内聚部分说的是封装和继承,低耦合则是接口和多态. 所以面向接口编程在应用而生,由此可见,不同的应用场景关注点不同,面向对象和面向接口也并不是互斥关系,是互补关系. 在未来的某种需求继续发生改变时,可能还会产生新的概念,进而提出新的一套理论,到时候是面向需求编程还是面向思维编程亦或是面向搜索编程,那就就不得而知了. 聪明的读者,你们有什么看法呢? 如何设计又怎么实现 市场监督大会散会后,继承小组接受了设计接口的任务挑战.大会之所以推举继承小组领头,是因为与会人员一致认为继承小组在处理抽象概念上十分擅长,相信设计出接口这种机制也是可以的. 继承小组深感此次任务责任重大,任重而道远,一定要设计出接口概念才能不辜负参会人员的认可和领导的厚爱. 于是,继承小组内部在一起开了个会,会上大家畅所欲言谈谈自己的看法. 小王: \"我觉得这种接口的概念是抽象的终极状态,我们可能没办法一下子到达终点,但是按照现有的理论应该可以逐步逼近终点.\" 小李: \"我也是有类似的感觉,抽象到什么程度才是终点呢?拿什么判定这个抽象程度呢?猫和狗到宠物的过程是一种抽象过程,我们先前也是基于此过程提出了继承的概念,解决了重复定义的问题.现在应该沿着这种思路继续抽象,直到小王说的那种接口概念.\" 小张: \"从猫和狗抽象到宠物,是封装对象的演进过程,顾客需要的不是具体的猫和狗,而是宠物.但是这个宠物直觉上感觉和原来继承中实现的宠物还是有点不一样啊?\" 小王: \"我也有同感,这次的宠物必须具备某种能力,只要是满足这种能力的,管他是猫还是狗或者是别的什么蜥蜴蟑螂的都是顾客眼中的宠物.所以这种宠物更加单一化,并不在乎有没有其他能力.\" ... 大家你一言我一语的讨论了好长时间,最终在项目经理的引导整理下有了有了初步的思路. 接口是一种抽象,这种抽象可能并不关注父类本身的全部能力,只在于关注的能力. 普通的抽象父类既有行为的约束还顺便实现了该行为,但抽象到接口这种程度时是否实现并不在乎,但必须要有行为的约束. 接口本身的语义是一种行为约束,满足这种约束行为的具体对象可能会有很多,同时这些具体对象可能也满足其他接口约束. 接口约束变化时,满足接口约束的具体子类到底要不要随之变化?如果需要的话,有道理,如果不需要的话,也有道理. \"等一下,我有疑问?你怎么一会说需要,一会又说不需要,这不自相矛盾了吗?\",大家几乎不约而同举手示意经理.似乎早就料到这帮小子搞不懂其中缘由,经理故弄玄虚地回应说:\"嗯嗯,我就知道你们会有疑惑,下面容我谈一下我的看法,你们听听看.” 如果站在接口的定义者角度上看问题,一旦发布了接口规范,子类肯定会屁颠屁颠满足接口约束,于是对外暴露时都是接口那一套理论,忽略了自己的特色. 统一了接口规范这种情况对于接口设计者最为方便,所有的控制权全部掌握在自己手中,一道命令即可号令群雄,莫敢不从,如若不从,轻则千夫所指,重则驱逐出境! 对于接口设计者来说,这些实现了接口的对象并没有什么不同,地球离了谁照样自转,随时随地想换就换. 但是对于接口的实现类来说,只要一收到天子诏令,立马无条件停下手上的活,熬夜加班也要满足新的接口规范,敢怒不敢言,除非是不想混了,哪怕怠慢了一步也会引发巨大的动荡! 所以说接口更改时,具体的实现类必须要随之改变以实现新的接口规范约束. 如果站在接口的使用者角度上看问题,是否实现接口应该是我的地盘我做主,是自主决定的事情,管你接口是否更改,老子爱实现就实现,不乐意实现就不实现!你奈我何?我的王国我当家,尊你敬你你才是国王,把我们惹恼了,所谓的联合王国到时候只剩你这么一个孤家寡人去吧! 所以说接口更改时,具体的实现类不需要随之更改,想不想满足新的接口规范完全在于自己,并不是强迫的,不必立即实现新的接口规范. 真的是公说公有理婆说婆有理,既然如此,那么问题来了,Go 语言选择是哪一种?其他主流的编程语言又是选择哪一种的呢? 先说其他主流的编程语言,这类编程语言大多是站在接口设计者角度出发,控制欲特别强,一言不合就报错,接口更新了实现类必须同步更新,违令者杀无赦! 这样有优点也有缺点,优点是皇帝一声令下,天下臣民莫敢不从,屡教不敢者,千夫所指,王国崩溃也不是没有可能! 正是这种优点,换另外一种角度看就是缺点了,俗话说天高皇帝远,圣旨虽下但还没传达到边境要塞,那边监察御史就上奏你一本,说你怠政目无尊上,引发帝国动荡,罪大恶极,理应凌迟处死! 你说冤不冤,不管是朝令夕改还是焕然一新的改革,凡是曾经实现过接口的类都要实时更新,否则后果不堪设想. 真的是成也萧何败萧何,控制欲太强有利有弊. 所以,Go 与众不同,选择了另一种思路来解决问题,放弃中央集权转向分封制,将权力下放给地方. 名义上还是由国王制定统一标准,由地方负责自主实施,具体如何实现标准完全是诸侯国自己的事情,万一哪天国王需要使用统一标准时,实现了该标准的诸侯王国都可以无障碍使用. 即使以后接口规范有变,旧的接口不再适合新时代要求,国王只需要制定了一套新的标准,昭告天下后,当诏令传到地方时,地方可以根据新的规范更新自己的实现类,万一消息闭塞或者不愿意立即更新,也没关系,王国不会崩溃,只不过需要使用新规范时,没有实现接口的地方自然是不能使用的. 因此,不论是集中制还是民主制,接口的规范都是自顶向下实施的,不同之处在于底下的人因各种原因没有实现新的接口规范时,集中制会直接崩溃而民主制依旧正常运行,仅此而已. 下面就演示一下两种思路的实现方式. java 等传统的面向对象语言 卖家首先定义到底什么是宠物这种接口. public interface Pet { void actingCute(); } 喵喵喵,人家能卖萌,就是宠物嘛,为啥还非得证明一下啊! public static class Cat implements Pet { @Override public void actingCute() { System.out.println(\"喵星人喵喵喵来卖萌\"); } } 这里说的证明一下猫是宠物,指的是必须使用关键字 implements 声明实现了宠物的接口,颁发了合格证才算是宠物,否则就不是. 汪星人说,这年头自带卖萌天赋的猫咪都要通过专业认证才算是宠物,我也乖乖去认证宠物吧! public static class Dog implements Pet { @Override public void actingCute() { System.out.println(\"汪星人汪汪汪来卖萌\"); } } 第二天,市场上又来了一群急性子的买家,一上来就要买宠物,管他是猫还是狗,并不在乎,只要是宠物就行. public static void main(String[] args) { Pet p; p = new Cat(); // 喵星人喵喵喵来卖萌 p.actingCute(); p = new Dog(); // 汪星人汪汪汪来卖萌 p.actingCute(); } 终于送走了这批顾客,卖家也舒了一口气,默默念叨着,市场监督那帮人真牛逼,竟然设计出接口的方案,只要是宠物,别管是猫还是狗,随便给一个都行,给这帮人点个赞! go 等非传统非面向对象语言 首先定义接口规范,宠物一定要能卖萌,不然怎么讨得女神欢心? type Pet interface { ActingCute() } 喵喵喵说我会卖萌啊,那我就是宠物啦! type Cat struct { } func (c *Cat) ActingCute() { fmt.Println(\"喵星人喵喵喵来卖萌\") } 汪汪汪说我也会卖萌,我也要给女神当宠物! type Dog struct { } func (d *Dog) ActingCute() { fmt.Println(\"汪星人汪汪汪来卖萌\") } 既然你们都会卖萌,对于直男来说这就够了,随便拿一个就行了,快点准备送礼物啦! func SendGift(p Pet) { p.ActingCute() } 于是乎,既然买家并不在乎到底是猫还是狗,那就卖给他一个猫好了,于是小伙子打包了宠物准备送给女神. func TestActingCute(t *testing.T) { var p Pet p = new(Cat) // 喵星人喵喵喵来卖萌 SendGift(p) } 第二天,女神打来电话说,你不知道对猫毛过敏的吗,送的啥破礼物!哼! 可怜的小伙子跑去宠物店找卖家算账,气冲冲地质问卖家,卖家一脸毫不在意的样子,笑嘻嘻的说,小伙子想不想将功补过啊,这一次保准你能获得女神青睐. 只见,卖家这一次找来了一条宠物狗,打打包还放到原来的包装盒递给你小伙子. func TestActingCute(t *testing.T) { var p Pet p = new(Dog) // 汪星人汪汪汪来卖萌 SendGift(p) } 我擦,还是原来的配方,有点担心,一样的包装这一次真的能讨得女神欢心,原谅自己吗? 亲爱的读者,你们说呢,同样的配方不一样的味道,女神会原谅自己吗? 同一个问题思路不同 不论是站在设计者角度上解决抽象问题还是站在使用者角度思考,两者的解决方案没有高低优劣之分,选用好恰当的应用场景就是最好的解决方案. 只不过这种选择往往不是开发者能左右的事情,因为这种底层的语言级别框架设计属于缔造者的工作,他们一旦觉得了一种模式,语言使用者很难改变,我们唯一能做的就是理解并使用罢了! 当站在接口设计者角度上时,接口的定义和具体实现类的关系就好比是集中制,皇帝一声令下,不管身处何处,天下臣民皆惟命是从,如有懒政懈怠者,千夫所指,立马崩溃. 当站在接口实现者角度上时,此时接口的设计者和具体实现者的关系是松耦合的,犹如分封制,国王一声令下,诸侯国可以听从差遣也可以抗旨不遵,对于整个王国而言并不会造成颠覆性混乱,诸侯国和国王更像是一种契约精神而不是隶属服从关系. Go 语言中的接口采用的就是后一种松耦合的关系,接口设计者和接口实现者是松耦合的,实现的关系也是隐式的,这也是另一种理论\"鸭子模型\"的体现. 好了,本文主要介绍了为什么要有接口设计的需求以及接口设计是怎么思考的,并简单介绍了 Go 是如何实现这种模型的. 下一节我们将真正开始介绍 Go 语言关于接口的设计,顺便讲解面向对象最后一个知识点---多态. 如果本文对你理解面向对象有所帮助,欢迎你的的转发分享,如果文章有描述不当之处,希望你能留言告诉我,谢谢你的阅读. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/oop/interface.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/oop/interface-type.html":{"url":"go/oop/interface-type.html","title":"再谈接口","keywords":"","body":"再谈接口 如果你还了解编程概念中的接口概念,那么我建议你最好还是先阅读上一篇文章.详情请点击 go 学习笔记之万万没想到宠物店竟然催生出面向接口编程? ,否则的话,请自动忽略上文,继续探索 Go 语言的接口有什么不同之处. 如无法自动跳转到公众号「雪之梦技术驿站」文章,可以点击我的头像,动动你的小手翻翻历史文章,相信聪明的你一定可以找到相关文章. 接口是面向对象编程风格中继封装概念后的另一个重要概念,封装包含两方面含义:数据和行为的封装. 关于封装的概念这里同样不再赘述,有兴趣的话,可以阅读go 学习笔记之详细说一说封装是怎么回事. 当现实世界中的事物或者实际需求转移到编程世界中去实现时,这时候就需要进行建模,建立合适的模型来反映现实的事物,为了模型的紧凑性以及更好的复用性.编程世界的前辈们总结出封装的概念,并在此基础上进一步衍生出一系列的编程风格,其中就包括面向对象中的继承概念. 关于继承的概念这里同样不再赘述,有兴趣的话,可以阅读go 学习笔记之是否支持以及如何实现继承. 封装和继承都是在描述同类事物模型彼此共性,正如猫和狗都是动物,运用继承的概念表示的话,猫和狗继承自动物.猫和狗不仅具备各自特殊的属性和行为,还具备一般动物的属性和行为. 然而,并不是只有同类事物才具有相同特征.家禽鸭子是鸭子,玩具太空鸭也是鸭子,看似是同类事物实际却只有某一方面的行为相同而已,一个有生命,另一个无生命. 针对这种情况下统一共性行为的方法也就是接口,是对同类事物或者不同类事物的某一方面行为的统一抽象,满足该行为规范的封装对象称之为实现了该接口. 接口描述的是规范约束和实现的一种规则,接口定义了这种约束规范,至于如何实现这种规范,接口定义者本身并不关心.如何实现是接口实现者必须关心的,定义者和实现者两者是解耦的. 从这点来看,接口就像是现实生活中的领导下达命令给下属,下属负责实现目标.如何实现目标,领导并不关心,正所谓条条大路通罗马,手底下的人自然是八仙过海各显神通. 领导关心结果,下属关心实现 作为领导负责制定各种战略目标,总揽全局关心结果,作为下属负责添砖加瓦实现具体细节关心过程,这种职责分离的模式就是编程语言中接口定义者和接口实现者的关系,一方负责定义行为约束,另一方负责实现这种行为规范. 如果站在领导者的角度上看问题,自然是希望下属规规矩矩按时完成自己布置的任务,千万不要出现任何差池,为此甚至会出台一系列的行为准则,签到打卡等形式依次树立领导威望来换取下属的恪尽职责. 为了达到这个目标,领导者首先要在下属中树立足够高的威信,做到人人信服自己,这样手底下的人才能和自己统一战线一致对外,团结在一起好做事.否则的话,不满嫉妒等负面情绪就会在团队中蔓延,逐渐侵蚀削弱团队战斗力,不攻自破. 一般而言,这种威信的树立要么靠的是能力上技高一筹实力碾压,要么是知人善任天下贤才皆为我所用,还可以狐假虎威绿叶衬红花思想上奴役统治. 不管是什么方式,领导者在这场游戏中占据绝对领导地位,只要上层接口发号施令,下层实现都要随之更改.如果你是领导,相信你也会喜欢这种形式的,毕竟谁心里没有控制欲,更何况是绝对的权力! 如果站在下层实现者的角度思考问题,显然在这场上下级关系中实现者扮演弱势角色,长期忍受不公平的待遇要么崩溃,要么揭竿而起! Go 语言对于接口的定义者和接口的实现者的关系处理问题上,选择了揭竿而起,实现了不同于其他传统编程规范的另外一种风格规范. 这种规范常被视为是鸭子类型 duck typing --- \"当看到一只鸟走起来像鸭子,游泳起来像鸭子,叫起来也像鸭子,那么这只鸟就可以被称为鸭子.\" 在这种规范中并不关心结构体对象是什么类型或者说到底是不是鸭子,唯一关心的只是行为.只要满足特定行为的结构体类型就是鸭子类型,哪怕这种鸭子可能只是一种玩具也行!所以,在这种接口定义者和实现者的关系中,实现者可以不必向接口特意声明实现,只要最终行为上确实实现了接口中定义的行为规范,那么就称为该结构体实现了接口. 如果仅仅考虑接口定义者和实现者的关系,基于这种关系很容易进行下一步推断,要么实现者一定要声明实现接口,随时向领导汇报工作进度,要么一定不声明接口,只要保证最终能够完成任务即可.除此之外,很明显还存在另外一种可能性,那就是实现者可以选择报告工作也可以选择不报告. 那么,这种似是而非的关系是否有存在的意义呢,又该如何表示呢以及有没有现成编程语言基于此思路实现呢? 按照基本语义进行理解推测: 实现者需要报告给接口的方法一定是万分紧急十分重要的规范,正所谓大是大非面前不能有任何个人情感,一旦实现者无法实现,那么便不可饶恕,零容忍! 如果实现者不报告给接口,则表示这种规范是可选规范,如果满足的话,自然是好的.如果有特殊情况一时没能实现也不算是致命的问题,这类规范是可选规范,属于锦上添花的操作. 所以要描述这种可有可无的接口定义者和实现者的关系,显而易见的是,理应由接口定义者来指明接口的优先级,不能由实现者定义.否则的话,你认为爱国是必选的,他认为是可选的,那么接口的存在还有什么意义?既然如此,接口方法在声明时就应该声明该接口方法是必选的还是可选的,这样实现者实现该接口时才能有理可循,对于必选实现的接口只要没实现就不算是真正的接口实现者,而可选的接口允许实现者可以暂时不实现. 由于个人知识经验所限,暂不可知有没有现成的编程语言支持这种妥协状态,接口方法既可以声明必选的也可以声明可选的.个人觉得这种方式还是比较友好的,还是有存在的价值的. 如果你知道有什么编程语言刚好是这种思路实现了接口规范,还望不吝赐教,可以留言评论相互学习下. 理论指导实践,实践中出真知 虽然猜测中的第三种规范是介于必须上报和必须不上报之间的妥协状态,但是由于接口声明时有可选和必选之分,这种区分需要有接口定义者进行指定,因此在接口和实现者的关系中还是接口定义者占据主导地位. 当接口定义者占据主导地位时,现成的最佳编程实践告诉我们先定义接口再写实现类,也就是先有规范再写实现,所以实际编程中给我们的指导就是先抽象出共同行为,定义出接口规范,再去写不同的实现类去实现该接口,当使用接口时就可以不区分具体的实现类直接调用接口本身了. 如果有一句话来描述这种行为的话,那就是理论指导实践,先写接口再写实现. 同样的,我们还知道另外一句话,这就是实践出真知,这种思路刚好也是比较符合现实的,先写所谓的实现类,当这种实现类写的比较多的时候,就如继承那样,自然会发现彼此之间的关联性,再抽象成接口也是水到渠成的事情,不必在编程刚开始就费时费力去抽象定义接口等高级功能特性. 通过上篇文章关于 Go 语言的接口的设计思想我们知道 Go 语言采用的就是后一种: 实践中出真知. 接口实现者对于接口的实现是隐式的,也就是说某一种结构体很有可能有意无意实现了某种接口,真的是有心插花花不开,无心插柳柳成荫. 应如何区分有没有无心插柳 Go 语言这种似是而非若有还无的朦胧暧昧既给我们带来了方便,同时也给我们留下了些许烦恼,假如需要知道结构体类型到底是不是接口的实现者时,反而有些费事了. 值得庆幸的是,现代 IDE 一般都比较智能,这种接口语法虽然比较灵活但还是有规律可寻的,所以一般 IDE 也是可以智能推测出接口和实现的关系的,并不用我们肉眼去仔细辨别. Programmer 接口的左侧有个向下的箭头,而 GoProgrammer 结构体类型左侧有个向上箭头.此时鼠标点击箭头可以相互跳转,这就是 IDE 提供的可视化效果. 如果真的需要在程序中辨别接口和实现类的关系,那么只能借助系统级别的方法来判断了,准备环境如下: 首先先定义程序员的第一课 Hello World 的接口: type Programmer interface { WriteHelloWord() string } 然后按照不同的编程语言实现该接口,为了更加通用性表示 WriteHelloWord 的输出结果,这里将输出结果 string 定义成别名形式以此表示输出的是代码 Code. type Code string 按照 Code 别名重新整理接口定义,如下: type Programmer interface { WriteHelloWord() Code } 接下来我们用 Go 语言写第一个程序,而 Go 实现接口的方式是隐式的,并不需要关键字强制声明. type GoProgrammer struct { } func (g *GoProgrammer) WriteHelloWord() Code { return \"fmt.Println(\\\"Hello World!\\\")\" } 然后,选择 Java 程序员作为对比,其他面向对象编程语言类似,这里不再赘述. type JavaProgrammer struct { } func (j *JavaProgrammer) WriteHelloWord() Code { return \"System.out.Println(\\\"Hello World!\\\")\" } 当用户需要程序员写 WriteHelloWord 程序时,此时 Go 程序员和 Java 程序员准备各显身手,比较简单,这里重点是看一下接口变量的类型和值. func writeFirstProgram(p Programmer) { fmt.Printf(\"%[1]T %[1]v %v\\n\", p, p.WriteHelloWord()) } 按照接口的语义,我们可以将 Go 程序员和 Java 程序员全部扔给 writeFirstProgram 方法中,此时接口的类型是具体实现类的类型,接口的值也是实现类的数据. 当然,不论是 Go 还是 Java 都可以写出 WriteHelloWord . func TestPolymorphism(t *testing.T) { gp := new(GoProgrammer) jp := new(JavaProgrammer) // *polymorphism.GoProgrammer &{} fmt.Println(\"Hello World!\") writeFirstProgram(gp) // *polymorphism.JavaProgrammer &{} System.out.Println(\"Hello World!\") writeFirstProgram(jp) } 上述例子很简单,我们自然也是可以一眼看出接口和实现类的关系,并且 IDE 也为我们提供非常直观的效果,在比较复杂的结构体中这种可视化效果尤为重要. 如果你非要和我较真,说你正在用的 IDE 无法可视化直接看出某个类型是否满足某接口,又该怎么办? 我的建议是,那就换成和我一样的 IDE 不就好了吗! 哈哈,这只不过是我的一厢情愿罢了,有些人是不愿意改变的,不会随随便便就换一个 IDE,那我就告诉你另外一个方法来检测类型和接口的关系. 赵本山说,没事你就走两步? 真的是博大精深,言简意赅!如果某个结构体类型满足特定接口,那么这个这个结构体的实例化后一定可以赋值给接口类型,如果不能则说明肯定没有实现!肉眼看不出的关系,那就拿放大镜看,编译错误则不符合,编译通过则满足. 为了对比效果,这里再定义一个新的接口 MyProgrammer ,除了名称外,接口暂时和 Programmer 完全一样. IDE 并没有报错,左侧的可视化效果也表明 MyProgrammer 和 Programmer 虽然名称不同,但是接口方法却一模一样,GoProgrammer 类型不仅实现了原来的 Programmer 接口还顺便实现了 MyProgrammer. 不仅 GoProgrammer 是这样,JavaProgrammer 也是如此,有意无意实现了新的接口,这也就是 Go 的接口设计不同于传统声明式接口设计的地方. 现在我们改变一下 MyProgrammer 接口中的 WriteHelloWord 方法,返回类型由别名 Code 更改成原类型 string,再试一下实际效果如何. 由于 Go 是强类型语言,即使是别名和原类型也不是相同的,正如类型之间的转换都是强制的,没有隐式类型转换那样. 因此,可以预测的是,WriteHelloWord 接口方法前后不一致,是没有类型结构体满足新的接口方法的,此时编译器应该会报错. 事实胜于雄辩,无论是 GoProgrammer 还是 JavaProgrammer 都没有实现 MyProgrammer ,因此是不能赋值给类型 MyProgrammer ,编译器确实报错了! 并不是所有长得像的都是兄弟,也不是长得不像的就不是兄弟. type Equaler interface { Equal(Equaler) bool } Equaler 接口定义了 Equal 方法,不同于传统的多态,Go 的类型检查更为严格,并不支持多态特性. type T int func (t T) Equal(u T) bool { return t == u } 如果单单看 Equal(u T) bool 方法声明,放到其他主流的编程语言中这种情况可能是正确的,但是多态特性并不适合 Go 语言. 不仅仅 IDE 没有左侧可视化的箭头效果,硬生生的将类型声明成接口类型也会报错,说明的确没有实现接口. 透过现象看本质,T.Equal 的参数类型是T ,而不是字面上所需的类型Equaler,所以并没有实现 Equaler 接口中规定的 Equal 方法. 是不是很意外? 如果你已经看到了这里,相信你现在不仅基本理解了面向对象的三大特性,还知道了 GO 设计的是多么与众不同! 这种与众不同之处,不仅仅体现在面向对象中的类型和接口中,最基础的语法细节上无一不体现出设计者的匠心独运,正是这种创新也促进我们重新思考面向对象的本质,真的需要循规蹈矩按照现有的思路去设计新语言吗? Go 语言的语法精简,设计简单优雅,抛弃了某些看起来比较高级但实际使用过程中可能会比较令人困惑的部分,对于这部分的舍弃,确实在一定程度上简化了整体的设计. 但是另一方面,如果仍然需要这种被丢弃的编程习惯时,只能由开发者手动实现,从这点看就不太方便了,所以只能尽可能靠近设计者的意图,写出真正的 Go 程序. 控制权的转移意味着开发者承担了更多的责任,比如类型转换中没有显式类型转换和隐式类型转换之分,Go 仅仅支持显式类型转换,不会自动帮你进行隐式转换,也没有为了兼顾隐式类型的转换而引入的基本类型的包装类型,也就没有自动拆箱和自动装箱等复杂概念. 所以如果要实现 Equal 接口方法,那么就应该开发者自己保证严格实现,这里只需要稍微修改下就能真正实现该方法. type T2 int func (t T2) Equal(u Equaler) bool { return t == u.(T2) } Equal(Equaler) bool 接口方法中的参数中要求 Equaler 接口,因此 Equal(u Equaler) bool 方法才是真正实现了接口方法. 只有方法名称和签名完全一致才是实现了接口,否则看似实现实则是其他编程语言的逻辑,放到Go 语言中并没有实现接口. 如何保证实现者是特定类型 但是不知道你是否发现,这种形式实现的接口方法和我们熟悉的面向接口编程还是有所不同,任何满足接口 Equaler 方法的类型都可以被传入到 T2.Equal 的参数,而我们的编译器却不会在编译时给出提示. type T3 int func (t T3) Equal(u Equaler) bool { return t == u.(T3) } 仿造 T2 实现 T3 类型,同样也实现了 Equaler 接口所要求的 Equal 方法. T2 和 T3 明显是不同的类型,编译期间 T3 是可以传给 T2 的,反之亦然, T2 也可以传给 T3 . 编译正常而运行出错意味着后期捕捉问题的难度加大了,个人比较习惯于编译期间报错而不是运行报错,Go 语言就是编译型语言为什么造成了编译期间无法捕捉错误而只能放到运行期间了? 由此可见,t == u.(T3) 可能会抛出异常,异常机制也是编程语言通用的一种自我保护机制,Go 语言应该也有一套机制,后续再研究异常机制,暂时不涉及. 不过我们在这里确实看到了 u.(T3) 判断类型的局限性,想要确保程序良好运行,应该研究一下接口变量到底是什么以及如何判断类型和接口的关系. 编译期间的判断关系可以通过 ide 的智能提示也可以将类型声明给接口看看是否编译错误,但这些都是编译期间的判断,无法解决当前运行期间的错误. func TestEqualType(t *testing.T) { var t2 Equaler = new(T2) var t3 Equaler = new(T3) t.Logf(\"%[1]T %[1]v\\n\",t2) t.Logf(\"%[1]T %[1]v\\n\",t3) t.Logf(\"%[1]T %[1]v %v\\n\",t2,t2.Equal(t3)) } %T %V 打印出接口变量的类型和值,从输出结果上看 *polymorphism.T2 0xc0000921d0,我们得知接口变量的类型其实就是实现了该接口的结构体类型,接口变量的值就是该结构体的值. t2 和 t3 接口变量的类型因此是不同的,运行时也就自然报错了. 说完现象找原因: Go 语言的接口并没有保证实现接口的类型具有多态性,仅仅是约束了统一的行为规范,t2 和 t3 都满足了 Equal 这种规范,所以对于接口的设计效果来说,已经达到目标了. 但是这种接口设计的理念和我们所熟悉的其他编程语言的多态性是不同的,Go 并没有多态正如没有继承特性一样. func TestInterfaceTypeDeduce(t *testing.T) { var t2 Equaler = new(T2) var t3 Equaler = new(T3) t.Logf(\"%[1]T %[1]v %[2]T %[2]v\\n\",t2,t2.(*T2)) t.Logf(\"%[1]T %[1]v %[2]T %[2]v\\n\",t3,t3.(*T3)) } 当 t2.(*T2) 或 t3.(*T3) 时,均正常工作,一旦 t2.(*T3) 则会抛出异常,因此需要特殊处理下这种情况. 根据实验结果得知,t2.(*T2) 的类型和值恰巧就是接口变量的类型和值,如果结构体类型不能转换成指定接口的话,则可能抛出异常. 因此,猜测这种形式的效果上类似于强制类型转换,将接口变量 t2 强制转换成结构体类型,动不动就报错或者说必须指定接口变量和结构体类型的前提,有点像其他编程语言的断言机制. 单独研究一下这种断言机制,按照 Go 语言函数设计的思想,这种可能会抛出异常的写法并不是设计者的问题,而是我们使用者的责任,属于使用不当,没有检查能否转换成功. v2,ok2 := t2.(*T2) 从实际运行的结果中可以看出,接口变量 t2 经过断言为 *T2 结构体类型后得到的变量和接口变量 t2 应该是一样的,因为他俩的类型和值完全一样. 当这种转换失败时,ok 的值是 false ,此时得到的转换结果就是 nil . 老子口中的无为而治空接口 接口既然是实现规范的方式,按照以往的编程经验给我们的最佳实践,我们知道接口最好尽可能的细化,最好一个接口中只有一个接口方法,足够细分接口即减轻了实现者的负担也方便复杂接口的组合使用. 有意思的是,Go 的接口还可以存在没有任何接口方法的空接口,这种特殊的接口叫做空接口,无为而治,没有任何规范约束,这不就是老子口中的顺其自然,无为而治吗? type EmptyInterface interface { } 道家的思想主要靠领悟,有点哲学的味道,这一点不像理科知识那样严谨,可以根据已知按照一定的逻辑推测出未知,甚至预言出超时代的新理论也不是没有可能的. 然而,道家说一生二,二生三,三生万物,这句话看似十分富有哲理性但是实际却很难操作,只讲了开头和结尾,并没有讲解如何生万物,忽略了过程,全靠个人领悟,这就很难讲解了. 没有任何接口方法的空接口和一般接口之间是什么关系? 空接口是一,是接口中最基础的存在,有一个接口的是二,有二就会有三,自然就会有千千万万的接口,从而构造出接口世界观. func TestEmptyInterfaceTypeDeduce(t *testing.T) { var _ Programmer = new(GoProgrammer) var _ EmptyInterface = new(GoProgrammer) } GoProgrammer 结构体类型不仅实现了 Programmer 接口,也实现空接口,至少编译级别没有报错. 但是,Go 语言的接口实现是严格实现,空接口没有接口,因此没有任何结构体都没有实现空接口,符合一贯的设计理念,并没有特殊处理成默认实现空接口. 所以我困惑了,一方面,结构体类型实例对象可以赋值给空接口变量,而结构体类型却又没法实现空接口,这不是有种自相矛盾的地方吗? 莫非是继承不足空接口来凑 明明没有实现空接口却可以赋值给空接口,难不成是为了弥补语言设计的不足? 因为 Go 语言不支持继承,自然没有其他编程语言中的基类概念,而实际工作中有时候确实需要一种通用的封装结构,难道是继承不足,接口来凑? 所以设计出空接口这种特殊情况来弥补没有继承特性的不足?有了空接口就有了 Go 语言中的 Object 和泛型 T ,不知道这种理解对不对? func TestEmptyInterface(t *testing.T) { var _ Programmer = new(GoProgrammer) var _ EmptyInterface = new(GoProgrammer) var p EmptyInterface = new(GoProgrammer) v, ok := p.(GoProgrammer) t.Logf(\"%[1]T %[1]v %v\\n\", v, ok) } 空接口的这种特殊性值得我们花时间去研究一下,因为任何结构体类型都可以赋值给空接口,那么此时的接口变量断言出结构体变量是否也有配套的特殊之处呢? func TestEmptyInterfaceTypeDeduce(t *testing.T) { var gpe EmptyInterface = new(GoProgrammer) v, ok := gpe.(Programmer) t.Logf(\"%[1]T %[1]v %v\\n\", v, ok) v, ok = gpe.(*GoProgrammer) t.Logf(\"%[1]T %[1]v %v\\n\", v, ok) switch v := gpe.(type) { case int: t.Log(\"int\", v) case string: t.Log(\"string\", v) case Programmer: t.Log(\"Programmer\", v) case EmptyInterface: t.Log(\"EmptyInterface\", v) default: t.Log(\"unknown\", v) } } 虽然接收的时候可以接收任何类型,但是实际使用过程中必须清楚知道具体类型才能调用实例化对象的方法,因而这种断言机制十分重要. func doSomething(p interface{}) { if i, ok := p.(int); ok { fmt.Println(\"int\", i) return } if s, ok := p.(string); ok { fmt.Println(\"string\", s) return } fmt.Println(\"unknown type\", p) } func TestDoSomething(t *testing.T) { doSomething(10) doSomething(\"10\") doSomething(10.0) } 当然上述 doSomething 可以采用 switch 语句进行简化,如下: func doSomethingBySwitch(p interface{}) { switch v := p.(type) { case int: fmt.Println(\"int\", v) case string: fmt.Println(\"string\", v) default: fmt.Println(\"unknown type\", v) } } func TestDoSomethingBySwitch(t *testing.T) { doSomethingBySwitch(10) doSomethingBySwitch(\"10\") doSomethingBySwitch(10.0) } 不一样的接口基本用法总结 类型别名 type Code string Code 类型是原始类型 string 的别名,但 Code 和 string 却不是完全相等的,因为 Go 不存在隐式类型转换,Go 不认为这两种类型是一样的. 接口定义者 type Programmer interface { WriteHelloWord() Code } Programmer 接口定义了 WriteHelloWord() 的方法. 接口实现者 type GoProgrammer struct { } func (g *GoProgrammer) WriteHelloWord() Code { return \"fmt.Println(\\\"Hello World!\\\")\" } Go 开发者实现了 WriteHelloWord 接口方法,而这个方法刚好是 Programmer 接口中的唯一一个接口方法,因此 GoProgrammer 也就是 Programmer 接口的实现者. 这种基于方法推断出实现者和定义者的形式和其他主流的编程语言有很大的不同,这里并没有显示声明结构体类型需要实现什么接口,而是说干就干,可能一不小心就实现了某种接口都有可能. type JavaProgrammer struct { } func (j *JavaProgrammer) WriteHelloWord() Code { return \"System.out.Println(\\\"Hello World!\\\")\" } 此时,当然是我们故意实现了 Programmer 接口,以便接下来方便演示接口的基于用法. 接口的使用者 func writeFirstProgram(p Programmer) { fmt.Printf(\"%[1]T %[1]v %v\\n\", p, p.WriteHelloWord()) } 定义了 writeFirstProgram 的函数,接收 Programmer 接口类型的参数,而接口中定义了 WriteHelloWord 的接口方法. 所以不管是 GoProgrammer 还是 JavaProgrammer 都可以作为参数传递给 writeFirstProgram 函数,这就是面向接口编程,并不在乎具体的实现者,只关心接口方法足矣. 面向接口编程 func TestPolymorphism(t *testing.T) { gp := new(GoProgrammer) jp := new(JavaProgrammer) // *polymorphism.GoProgrammer &{} fmt.Println(\"Hello World!\") writeFirstProgram(gp) // *polymorphism.JavaProgrammer &{} System.out.Println(\"Hello World!\") writeFirstProgram(jp) } 传递给 writeFirstProgram 函数的参数中如果是 GoProgrammer 则实现 Go 语言版本的 Hello World!,如果是 JavaProgrammer 则是 Java 版本的 System.out.Println(\"Hello World!\") 看似松散实则依旧严格的接口实现规则 type MyProgrammer interface { WriteHelloWord() string } MyProgrammer 和 Programmer 中的 WriteHelloWord 接口方法只有返回值类型不一样,虽然Code 类型是 string 类型的别名,但是 Go 依旧不认为两者相同,所以 JavaProgrammer 不能赋值给 MyProgrammer 接口类型. 接口变量肚子里是藏了啥 type GoProgrammer struct { name string } type JavaProgrammer struct { name string } 给接口实现者添加 name 属性,其余不做改变. func interfaceContent(p Programmer) { fmt.Printf(\"%[1]T %[1]v\\n\", p) } func TestInterfaceContent(t *testing.T) { var gp Programmer = &GoProgrammer{ name:\"Go\", } var jp Programmer = &JavaProgrammer{ name:\"Java\", } // *polymorphism.GoProgrammer &{Go} interfaceContent(gp) // *polymorphism.JavaProgrammer &{Java} interfaceContent(jp) } 输出接口变量的类型和值,结果显示接口变量的类型就是结构体实现者的类型,接口变量的值就是实现者的值. func (g GoProgrammer) PrintName() { fmt.Println(g.name) } func (j JavaProgrammer) PrintName() { fmt.Println(j.name) } 现在继续添加结构体类型的方法,可能 PrintName 方法有意无意实现了某种接口,不过在演示项目中肯定没有实现接口. 从实验中我们知道接口变量的类型和值都是实现者的类型和值,那么能否通过接口变量访问到实现者呢? 想要完成访问实现者的目标,首先需要知道具体实现者的类型,然后才能因地制宜访问具体实现者的方法和属性等. 断言判断接口变量的实现者 func TestInterfaceTypeImplMethod(t *testing.T) { var gp Programmer = &GoProgrammer{ name: \"Go\", } // *polymorphism.GoProgrammer &{Go} fmt.Printf(\"%[1]T %[1]v\\n\", gp) if v, ok := gp.(*GoProgrammer); ok { // Go v.PrintName() }else{ fmt.Println(\"gp is not *GoProgrammer\") } } v, ok := gp.(*GoProgrammer) 将接口变量转换成结构体类型,如果转换成功意味着断言成功,则可以调用相应结构体类型实例对象的方法和属性.如果断言失败,则不可以. 空接口定义和使用 type EmptyInterface interface { } 任何结构体类型都可以赋值给空接口,此时空接口依旧和一般接口一样的是可以采用断言机制确定目标结构体类型. 但这并不是最常用的操作,比较常用的做法还是用来充当类似于 Object 或者泛型的角色,空接口可以接收任何类型的参数. func emptyInterfaceParam(p interface{}){ fmt.Printf(\"%[1]T %[1]v\",p) switch v := p.(type) { case int: fmt.Println(\"int\", v) case string: fmt.Println(\"string\", v) case Programmer: fmt.Println(\"Programmer\", v) case EmptyInterface: fmt.Println(\"EmptyInterface\", v) default: fmt.Println(\"unknown\", v) } } func TestEmptyInterfaceParam(t *testing.T) { var gp Programmer = new(GoProgrammer) var ge EmptyInterface = new(GoProgrammer) // *polymorphism.GoProgrammer &{}Programmer &{} emptyInterfaceParam(gp) // *polymorphism.GoProgrammer &{}Programmer &{} emptyInterfaceParam(ge) } 好了,关于 Go 语言的接口部分暂时结束了,关于面向对象编程风格的探索也告一段落,接下来将开始探索 Go 的一等公民函数以及函数式编程.敬请期待,希望学习路上,与你同行! 猜猜看go是不是面向对象语言？能不能面向对象编程？ go 学习笔记之详细说一说封装是怎么回事 go 学习笔记之是否支持以及如何实现继承 go 学习笔记之万万没想到宠物店竟然催生出面向接口编程? 上述列表是关于 Go 语言面向对象的全部系列文章,详情见微信公众号「雪之梦技术驿站」,如果本文对你有所帮助,欢迎转发分享,如有描述不当之处,请一定要留言评论告诉我,感谢~ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/oop/interface-type.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/functional/about.html":{"url":"go/functional/about.html","title":"函数式编程","keywords":"","body":"函数式编程 在编程世界中向来就没有一家独大的编程风格,至少目前还是百家争鸣的春秋战国,除了众所周知的面向对象编程还有日渐流行的函数式编程,当然这也是本系列文章的重点. 越来越多的主流语言在设计的时候几乎无一例外都会参考函数式特性( lambda 表达式,原生支持 map,reduce...）,就连面向对象语言的 Java8 也慢慢开始支持函数式编程,所以再不学习函数式编程可能就晚了! 但是在正式学习函数式编程之前,不妨和早已熟悉的面向对象编程心底里做下对比,通过对比学习的方式,相信你一定会收获满满,因此特地整理出来关于 Go 语言的面向对象系列文章,邀君共赏. 猜猜看go是不是面向对象语言？能不能面向对象编程？ go 学习笔记之详细说一说封装是怎么回事 go 学习笔记之是否支持以及如何实现继承 go 学习笔记之万万没想到宠物店竟然催生出面向接口编程? go 学习笔记之无心插柳柳成荫的接口和无为而治的空接口 上述系列文章讲解了 Go 语言面向对象相关知识点,如果点击后没有自动跳转,可以关注微信公众号「雪之梦技术驿站」查看历史文章,再次感谢你的阅读与关注. 生物学家和数学家的立场不同 虽然是同一个世界,但是不同的人站在各自立场看问题,结果自然会千人千面,各有不同. 生物学家会下意识对动植物进行分类归纳,面向对象编程也是如此,用一系列的抽象模型去模拟现实世界的行为规律. 数学家向来以严谨求学著称,作为最重要的基础科学,数学规律以及归纳演绎方法论对应的就是函数式编程,不是模拟现实而是描述规律更有可能创造规律. 标准的函数式编程具有浓厚的数学色彩,幸运的是,Go 并不是函数式语言,所以也不必受限于近乎苛责般的条条框框. 简单来说,函数式编程具有以下特点: 不可变性: 不用状态变量和可变对象 函数只能有一个参数 纯函数没有副作用 摘自维基百科中关于函数式编程中有这么一段话: In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. 上述的英文的大致意思是说:函数式编程将计算机程序看成是数学函数的推演,不用状态变量也不用可变对象来表达数与数之间的关系. 如需了解详情,可点击访问维基百科关于函数式编程 Functional programming 的相关介绍. 函数式编程的立足点和出发点是函数,复杂函数是基本函数经过一定组合规律形成的,所以描述复杂函数的过程就是如何拆解重组的过程. 所以接下来我们一边复习一边学习函数的基本特点,为接下来理解函数式编程打下基础,关于函数的基础语言可参考 go 学习笔记之值得特别关注的基础语法有哪些 函数的基础语法和高级特性 下面以最基本四则运算为例,贯穿全文讲解函数的基本语法和高级特性,力求做到知其然知其所以然. func 定义普通函数 eval 函数定义了加减乘除基本运算规则,若不支持操作类型则抛出异常,终止程序. func eval(a, b int, op string) int { var result int switch op { case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported operator: \" + op) } return result } 测试未定义操作取余 % 运算时,则抛出异常,unsupported operator: % ,说明仅仅支持加减乘除基本运算. func TestEval(t *testing.T) { // 3 -1 2 0 unsupported operator: % t.Log( eval(1, 2, \"+\"), eval(1, 2, \"-\"), eval(1, 2, \"*\"), eval(1, 2, \"/\"), eval(1, 2, \"%\"), ) } 多返回值定义标准函数 Go 语言和其他主流的编程语言明显不同的是,函数支持多返回值,通常第一个返回值表示真正结果,第二个返回值表示是否错误,这也是 Go 关于异常错误设计的独特之处. 如果正常返回,则表示没有错误,那么第一个返回值是正常结果而第二个返回值则是空 nil;如果异常返回,第一个返回值设计无意义的特殊值,第二个返回值是具体的错误信息,一般非 nil. func evalWithStandardStyle(a, b int, op string) (int, error) { switch op { case \"+\": return a + b, nil case \"-\": return a - b, nil case \"*\": return a * b, nil case \"/\": return a / b, nil default: return 0, fmt.Errorf(\"unsupported operator: %s\", op) } } 改造 eval 函数以编写真正 Go 程序,此时再次测试,结果显示遇到没有定义的操作符时不再抛出异常而是返回默认零值以及给出简短的错误描述信息. func TestEvalWithStandardStyle(t *testing.T) { // Success: 2 if result, err := evalWithStandardStyle(5, 2, \"/\"); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } // Error: unsupported operator: % if result, err := evalWithStandardStyle(5, 2, \"%\"); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } } 其他函数作为参数传入 上例通过多返回值解决了遇到不支持的运算符会报错终止程序的问题,但是并没有真正解决问题,假如真的想要进行非预定义的运算时,同样是无能为力! 谁让你只是使用者而不是设计者呢! 那么舞台交给你,你就是主角,你想要怎么处理输入怎么输出就怎么处理,全部逻辑转移给使用者,这样就不存在无法满足需求的情况了. func evalWithApplyStyle(a, b int, op func(int, int) (int, error)) (int, error) { return op(a, b) } 操作符由原来的字符串 string 更改成函数 func(int, int) (int, error),舞台交给你,全靠自由发挥! evalWithApplyStyle 函数内部直接调用函数参数 op 并返回该函数的处理结果,当前演示示例中函数的控制权完全转移给函数入参 op 函数,实际情况可按照实际需求决定如何处理 evalWithApplyStyle 逻辑. func divide(a, b int) (int, error) { return a / b, nil } func mod(a, b int) (int, error) { return a % b, nil } 自己动手,丰衣足食,顺手定义除法 divide 和取余 mod 运算,接下来测试下实现效果. func TestEvalWithApplyStyle(t *testing.T) { // Success: 2 if result, err := evalWithApplyStyle(5, 2, divide); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } // Success: 1 if result, err := evalWithApplyStyle(5, 2, mod); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } } 测试结果很理想,不仅实现了减加乘除等基本运算,还可以实现之前一直没法实现的取余运算! 这说明了这种函数作为参数的做法充分调动劳动人民积极性,妈妈再也不用担心我无法实现复杂功能了呢! 匿名函数也可以作为参数 一般而言,调用函数时都是直接用函数名进行调用,单独的函数具有可复用性,但如果本就是一次性函数的话,其实是没必要定义带函数名形式的函数. 依然是上述例子,这一次对两个数的运算规则不再是数学运算了,这一次我们来比较两个数的最大值,使用匿名函数的形式进行实现. func TestEvalWithApplyStyle(t *testing.T) { // Success: 5 if result, err := evalWithApplyStyle(5, 2, func(a int, b int) (result int, e error) { if a > b { return a, nil } return b, nil }); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } } 函数的返回值可以是函数 依然是上述示例,如果由于原因不需要立即返回函数的计算结果而是等待使用者自己觉得时机合适的时候再计算返回值,这时候函数返回值依然是函数就很有作用了,也就是所谓的惰性求值. func evalWithFunctionalStyle(a, b int, op func(int, int) (int, error)) func() (int, error) { return func() (int, error) { return op(a, b) } } 上述函数看起来可能有点难以理解,实际上相对于上例仅仅更改了返回值,由原来的 (int, error) 更改成 func() (int, error) ,其余均保持不变哟! evalWithFunctionalStyle 函数依然是使用者的主场,和上例相比的唯一不同之处在于,你的主场你做主,什么时候裁判完全自己说了算,并不是运行后就立马宣布结果. func pow(a, b int) (int, error) { return int(math.Pow(float64(a), float64(b))),nil } func TestEvalWithFunctionalStyle(t *testing.T) { ef := evalWithFunctionalStyle(5, 2, pow) time.Sleep(time.Second * 1) // Success: 25 if result, err := ef(); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } } time.Sleep(time.Second * 1) 演示代码代表执行 evalWithFunctionalStyle 函数后可以不立即计算最终结果,等待时机合适后由使用者再次调用 ef() 函数进行惰性求值. // 1 1 2 3 5 8 13 21 34 55 // a b // a b func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 函数可以充当类型 上述示例中讲解了函数可以作为返回值,参数有函数,返回值也有参数,所以 evalWithFunctionalStyle 函数看起来比较费劲,而 Go 语言的类型别名就是为了简化而生的,更何况函数是 Go 中的一等公民,当然也适合了. func evalWithFunctionalStyle(a, b int, op func(int, int) (int, error)) func() (int, error) { return func() (int, error) { return op(a, b) } } 于是打算把入参函数 func(int, int) (int, error) 和返回值函数 func() (int, error) 进行统一,而入参函数和返回值函数唯一不同之处就是入参个数不同,所以顺理成章想到了 Go 函数中的不定长参数相关语法. type generateIntFunc func(base ...int) (int, error) 这样入参函数和出参函数都可以用 generateIntFunc 类型函数进行替代,接着改造 evalWithFunctionalStyle 函数. func evalWithObjectiveStyle(a, b int, op generateIntFunc) generateIntFunc { return func(base ...int) (i int, e error) { return op(a, b) } } 改造后的 evalWithObjectiveStyle 函数看起来比较简洁,花花架子中看是否中用还不好说,还是用测试用例说话吧! func TestEvalWithObjectiveStyle(t *testing.T) { ef := evalWithObjectiveStyle(5, 2, func(base ...int) (int,error) { result := 0 for i := range base { result += base[i] } return result,nil }) time.Sleep(time.Second * 1) // Success: 7 if result, err := ef(); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } } 函数别名进行类型化后并不影响功能,依然是函数式编程,不过夹杂了些面向对象的味道. 类型化函数可以实现接口 函数通过别名形式进行类型化后可以实现接口,某些程度上可以视为一种类型,因此实现接口也是顺理成章的事情. func (g generateIntFunc) String() string { r,_ := g() return fmt.Sprint(r) } 此处示例代码中为类型化函数 generateIntFunc 实现 String 接口方法,可能并没有太大实际意义,仅仅是为了讲解这个知识点而硬凑上去的,实际情况肯定会有所不同. func TestEvalWithInterfaceStyle(t *testing.T) { ef := evalWithObjectiveStyle(5, 2, func(base ...int) (int,error) { result := 0 for i := range base { result += base[i] } return result,nil }) time.Sleep(time.Second * 1) // String: 7 t.Log(\"String:\", ef.String()) // Success: 7 if result, err := ef(); err != nil { t.Log(\"Error:\", err) } else { t.Log(\"Success:\", result) } } 惰性求值获取的函数变量 ef 此时可以调用 String 方法,也就是具备对象化能力,得到的最终结果竟然和直接运行该函数的值一样? 有点神奇,目前还不理解这是什么操作,如果有 Go 语言的大佬们不吝赐教的话,小弟感激不尽! 水到渠成的闭包 函数的参数,返回值都可以是另外的函数,函数也可以作为引用那样传递给变量,也存在匿名函数等简化形式,除此之外,类型化后的函数还可以用来实现接口等等特性应该足以阐释一等公民的高贵身份地位了吧? 如此强大的函数特性,只要稍加组合使用就会拥有强大的能力,并且 Go 语言并不是严格的函数式语言,没有太多语法层面的限制. // 1 1 2 3 5 8 13 21 34 55 // a b // a b func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 斐波那契数列函数 fibonacci 的返回值是真正的生成器函数,每次调用都会生成新的斐波那契数字. 这就是 Go 语言实现闭包的一种简单示例,fibonacci 函数本身的变量 a,b 被内部匿名函数 func() int 所引用,而这种引用最终被使用者不断调用就会导致最初的 a,b 变量一直被占用着,只要继续调用这种生成器,裴波那契数列的数字就会一直递增. // 1 1 2 3 5 8 13 21 34 55 func TestFibonacci(t *testing.T) { f := fibonacci() for i := 0; i func TestFibonacci(t *testing.T) { f := fibonacci() for i := 0; i 函数式编程入门函数总结 函数是一等公民,其中函数参数,变量,函数返回值都可以是函数. 高阶函数是普通函数组合而成,参数和返回值可以是另外的函数. 函数是函数式编程的基础,支持函数式编程但并不是函数式语言. 没有纯粹函数式编程的条条框框,更加灵活自由,良好的可读性. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/functional/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/functional/fib.html":{"url":"go/functional/fib.html","title":"斐波那契数列","keywords":"","body":"斐波那契数列 本篇文章是 Go 语言学习笔记之函数式编程系列文章的第二篇,上一篇介绍了函数基础,这一篇文章重点介绍函数的重要应用之一: 闭包 空谈误国,实干兴邦,以具体代码示例为基础讲解什么是闭包以及为什么需要闭包等问题,下面我们沿用上篇文章的示例代码开始本文的学习吧! 斐波那契数列是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,即从第三个数开始,后一个数字是前两个数字之和,保持此规律无限递增... 开门见山,直接给出斐波那契数列生成器,接下来的文章慢慢深挖背后隐藏的奥秘,一个例子讲清楚什么是闭包. 「雪之梦技术驿站」: 如果还不了解 Go 语言的函数用法,可以参考上一篇文章: go 学习笔记之学习函数式编程前不要忘了函数基础 Go 版本的斐波那契数列生成器 // 1 1 2 3 5 8 13 21 34 55 // a b // a b func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 「雪之梦技术驿站」: Go 语言支持连续赋值,更加贴合思考方式,而其余主流的编程语言可能不支持这种方式,大多采用临时变量暂存的方式. Go 版本的单元测试用例 // 1 1 2 3 5 8 13 21 34 55 func TestFibonacci(t *testing.T) { f := fibonacci() for i := 0; i 「雪之梦技术驿站」: 循环调用 10 次斐波那契数列生成器,因此生成前十位数列: 1 1 2 3 5 8 13 21 34 55 背后有故事 小小的斐波那契数列生成器背后蕴藏着丰富的 Go 语言特性,该示例也是官方示例之一. 支持连续赋值,无需中间变量 「雪之梦技术驿站」: Go 语言和其他主流的编程语言不同,它们大多数最多支持多变量的连续声明而不支持连续赋值. 这也是 Go 语言特有的交换变量方式,a, b = b, a 语义简单明确并不用引入额外的临时变量. func TestExchange(t *testing.T) { a, b := 1, 2 t.Log(a,b) // 2,1 a, b = b, a t.Log(a,b) } 「雪之梦技术驿站」: Go 语言实现变量交互的示例,a, b = b, a 表示变量直接交换. 而其他主流的编程语言的惯用做法是需要引入临时变量,大多数代码类似如下方式: func TestExchange(t *testing.T) { a, b := 1, 2 t.Log(a,b) // 2,1 temp := a a = b b = temp t.Log(a,b) } 「雪之梦技术驿站」: Go 语言的多变量同时赋值特性体现的更多是一种声明式编程思想,不关注具体实现,而引入临时变量这种体现的则是命令式编程思维. 函数的返回值也可以是函数 「雪之梦技术驿站」: Go 语言中的函数是一等公民,不仅函数的返回值可以是函数,参数,变量等等都可以是函数. 函数的返回值可以是函数,这样的实际意义在于使用者可以拥有更大的灵活性,有时可以用作延迟计算,有时也可以用作函数增强. 先来演示一下延迟计算的示例: 函数的返回值可以是函数,由此实现类似于 i++ 效果的自增函数.因为 i 的初值是 0,所以每调用一次该函数, i 的值就会自增,从而实现 i++ 的效果. func autoIncrease() func() int { i := 0 return func() int { i = i + 1 return i } } 再小的代码片段也不应该忘记测试,单元测试继续走起,顺便看一下使用方法. func TestAutoIncrease(t *testing.T) { a := autoIncrease() // 1 2 3 t.Log(a(),a(),a()) } 初始调用 autoIncrease 函数并没有直接得到结果而是返回了函数引用,等到使用者觉得时机成熟后再次调用返回的函数引用即变量a ,这时候才会真正计算结果,这种方式被称为延迟计算也叫做惰性求值. 继续演示一下功能增强的示例: 因为要演示函数增强功能,没有输入哪来的输出? 所以函数的入参应该也是函数,返回值就是增强后的函数. 这样的话接下来要做的函数就比较清晰了,这里我们定义 timeSpend 函数: 实现的功能是包装特定类型的函数,增加计算函数运行时间的新功能并包装成函数,最后返回出去给使用者. func timeSpend(fn func()) func() { return func() { start := time.Now() fn() fmt.Println(\"time spend : \", time.Since(start).Seconds()) } } 为了演示包装函数 timeSpend,需要定义一个比较耗时函数当做入参,函数名称姑且称之为为 slowFunc ,睡眠 1s 来模拟耗时操作. func slowFunc() { time.Sleep(time.Second * 1) fmt.Println(\"I am slowFunc\") } 无测试不编码,继续运行单元测试用例,演示包装函数 timeSpend 是如何增强原函数 slowFunc 以实现功能增强? func TestSlowFuncTimeSpend(t *testing.T) { slowFuncTimeSpend := timeSpend(slowFunc) // I am slowFunc // time spend : 1.002530902 slowFuncTimeSpend() } 「雪之梦技术驿站」: 测试结果显示原函数 slowFunc 被当做入参传递给包装函数 timeSpend 后实现了功能增强,不仅保留了原函数功能还增加了计时功能. 函数嵌套可能是闭包函数 不论是引言部分的斐波那契数列生成器函数还是演示函数返回值的自增函数示例,其实这种形式的函数有一种专业术语称为\"闭包\". 一般而言,函数内部不仅存在变量还有嵌套函数,而嵌套函数又引用了这些外部变量的话,那么这种形式很有可能就是闭包函数. 什么是闭包 如果有一句话介绍什么是闭包,那么我更愿意称其为流浪在外的人想念爸爸妈妈! 如果非要用比较官方的定义去解释什么是闭包,那只好翻开维基百科 看下有关闭包的定义: In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function[a] together with an environment.[1] The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.[b] Unlike a plain function, a closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope. 如果能够直接理解英文的同学可以略过这部分的中文翻译,要是不愿意费脑理解英文的小伙伴跟我一起解读中文吧! 闭包是一种技术 第一句话英文如下: In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. 相应的中文翻译: 闭包也叫做词法闭包或者函数闭包,是函数优先编程语言中用于实现词法范围的名称绑定技术. 概念性定义解释后可能还是不太清楚,那么就用代码解释一下什么是闭包? 「雪之梦技术驿站」: 编程语言千万种,前端后端和中台;心有余而力不足,大众化 Js 带上 Go . Go 实现斐波那契数列生成器 这是开篇引言的示例,直接照搬过来,这里主要说明 Go 支持闭包这种技术而已,所以并不关心具体实现细节. func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 单元测试用例函数,连续 10 次调用斐波那契数列生成器,输出斐波那契数列中的前十位数字. // 1 1 2 3 5 8 13 21 34 55 func TestFibonacci(t *testing.T) { f := fibonacci() for i := 0; i Js 实现斐波那契数列生成器 仿照 Go 语言的实现方式写一个 Js 版本的斐波那契数列生成器,相关代码如下: function fibonacci() { var a, b; a = 0; b = 1; return function() { var temp = a; a = b; b = temp + b; return a; } } 同样的,仿造测试代码写出 Js 版本的测试用例: // 1 1 2 3 5 8 13 21 34 55 function TestFibonacci() { var f = fibonacci(); for(var i = 0; i 不仅仅是 Js 和 Go 这两种编程语言能够实现闭包,实际上很多编程语言都能实现闭包,就像是面向对象编程一样,也不是某种语言专有的技术,唯一的区别可能就是语法细节上略有不同吧,所以记住了: 闭包是一种技术! 闭包存储了环境 第二句英文如下: Operationally, a closure is a record storing a function[a] together with an environment. 相应的中文翻译: 在操作上,闭包是将函数[a]与环境一起存储的记录。 第一句我们知道了闭包是一种技术,而现在我们有知道了闭包存储了闭包函数所需要的环境,而环境分为函数运行时所处的内部环境和依赖的外部环境,闭包函数被使用者调用时不会像普通函数那样丢失环境而是存储了环境. 如果是普通函数方式打开上述示例的斐波那契数列生成器: func fibonacciWithoutClosure() int { a, b := 0, 1 a, b = b, a+b return a } 可想而知,这样肯定是不行的,因为函数内部环境是无法维持的,使用者每次调用 fibonacciWithoutClosure 函数都会重新初始化变量 a,b 的值,因而无法实现累加自增效果. // 1 1 1 1 1 1 1 1 1 1 func TestFibonacciWithoutClosure(t *testing.T) { for i := 0; i 很显然,函数内部定义的变量每次运行函数时都会重新初始化,为了避免这种情况,在不改变整体实现思路的前提下,只需要提升变量的作用范围就能实现斐波那契数列生成器函数: var a, b = 0, 1 func fibonacciWithoutClosure() int { a, b = b, a+b return a } 此时再次运行 10 次斐波那契数列生成器函数,如我们所愿生成前 10 位斐波那契数列. // 1 1 2 3 5 8 13 21 34 55 func TestFibonacciWithoutClosure(t *testing.T) { for i := 0; i 所以说普通函数 fibonacciWithoutClosure 的运行环境要么是仅仅依赖内部变量维持的独立环境,每次运行都会重新初始化,无法实现变量的重复利用;要么是依赖了外部变量维持的具有记忆功能的环境,解决了重新初始化问题的同时引入了新的问题,那就是必须定义作用范围更大的外部环境,增加了维护成本. 既然函数内的变量无法维持而函数外的变量又需要管理,如果能两者结合的话,岂不是皆大欢喜,扬长补短? 对的,闭包基本上就是这种实现思路! func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 斐波那契数列生成器函数 fibonacci 的返回值是匿名函数,而匿名函数的返回值就是斐波那契数字. 如果不考虑函数内部实现细节,整个函数的语义是十分明确的,使用者初始化调用 fibonacci 函数时得到返回值是真正的斐波那契生成器函数,用变量暂存起来,当需要生成斐波那契数字的时候再调用刚才暂存的变量就能真正生成斐波那契数列. // 1 1 2 3 5 8 13 21 34 55 func TestFibonacci(t *testing.T) { f := fibonacci() for i := 0; i 现在我们再好好比较一下这种形式实现的闭包和普通函数的区别? 闭包函数 fibonacci 的内部定义了变量 a,b,最终返回的匿名函数中使用了变量 a,b,使用时间接生成斐波那契数字. 普通函数 fibonacciWithoutClosure 的外部定义了变量 a,b,调用该函数直接生成斐波那契数字. 闭包函数是延迟计算也就是惰性求值而普通函数是立即计算,两者的调用方式不一样. 但是如果把视角切换到真正有价值部分,你会发现闭包函数只不过是普通函数嵌套而已! func fibonacciDeduction() func() int { a, b := 0, 1 func fibonacciGenerator() int { a, b = b, a+b return a } return fibonacciGenerator } 只不过 Go 并不支持函数嵌套,只能使用匿名函数来实现函数嵌套的效果,所以上述示例是会直接报错的哟! 但是某些语言是支持函数嵌套的,比如最常用的 Js 语言就支持函数嵌套,用 Js 重写上述代码如下: function fibonacciDeduction() { var a, b; a = 0; b = 1; function fibonacciGenerator() { var temp = a; a = b; b = temp + b; return a } return fibonacciGenerator } 斐波那契数列生成器函数是 fibonacciDeduction,该函数内部真正实现生成器功能的却是 fibonacciGenerator 函数,正是这个函数使用了变量 a,b ,相当于把外部变量打包绑定成运行环境的一部分! // 1 1 2 3 5 8 13 21 34 55 function TestFibonacciDeduction() { var f = fibonacciDeduction(); for(var i = 0; i 「雪之梦技术驿站」: 闭包并不是某一种语言特有的技术,虽然各个语言的实现细节上有所差异,但并不妨碍整体理解,正如定义的第二句那样: storing a **function**[a] together with an **environment**. 环境关联了自由变量 第三句英文如下: The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created 相应的中文翻译: 环境是一种映射,它将函数的每个自由变量(在本地使用但在封闭范围内定义的变量)与创建闭包时名称绑定到的值或引用相关联。 环境是闭包所处的环境,这里强调的是外部环境,更确切的说是相对于匿名函数而言的外部变量,像这种被闭包函数使用但是定义在闭包函数外部的变量被称为自由变量. 「雪之梦技术驿站」: 由于闭包函数内部使用了自由变量,所以闭包内部的也就关联了自由变量的值或引用,这种绑定关系是创建闭包时确定的,运行时环境也会一直存在并不会发生像普通函数那样无法维持环境. 自由变量 这里使用了一个比较陌生的概念: 自由变量(在本地使用但在封闭范围内定义的变量) 很显然,根据括号里面的注释说明我们知道: 所谓的自由变量是相对于闭包函数或者说匿名函数来说的外部变量,由于该变量的定义不受自己控制,所以对闭包函数自己来说就是自由的,并不受闭包函数的约束! 那么按照这种逻辑继续延伸猜测的话,匿名函数内部定义的变量岂不是约束变量?对于闭包函数而言的自由变量对于定义函数来说岂不是约束变量? var a, b = 0, 1 func fibonacciWithoutClosure() int { a, b = b, a+b return a } 「雪之梦技术驿站」: 这里的变量 a,b 相对于函数 fibonacciWithoutClosure 来说,是不是自由变量?或者说全局变量就是自由变量,对吗? 值或引用 func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 变量 a,b 定义在函数 fibonacci 内部,相对于匿名函数 func() int 来说是自由变量,在匿名函数中直接使用了变量 a,b 并没有重新复制一份,所以这种形式的环境关联的自由变量是引用. 再举个引用关联的示例,加深一下闭包的环境理解. func countByClosureButWrong() []func() int { var arr []func() int for i := 1; i 上述示例的 countByClosureButWrong 函数内部定义了变量数组 arr ,存储的是匿名函数而匿名函数使用的是循环变量 i . 这里的循环变量的定义部分是在匿名函数的外部就是所谓的自由变量,变量 i 没有进行拷贝所以也就是引用关联. func TestCountByClosure(t *testing.T) { // 4 4 4 for _, c := range countByClosureButWrong() { t.Log(c()) } } 运行这种闭包函数,最终的输出结果都是 4 4 4,这是因为闭包的环境关联的循环变量 i 是引用方式而不是值传递方式,所以闭包运行结束后的变量 i 已经是 4. 除了引用传递方式还有值传递方式,关联自由变量时拷贝一份到匿名函数,使用者调用闭包函数时就能如愿绑定到循环变量. func countByClosureWithOk() []func() int { var arr []func() int for i := 1; i 「雪之梦技术驿站」: 自由变量 i 作为参数传递给匿名函数,而 Go 中的参数传递只有值传递,所以匿名函数使用的变量 n 就可以正确绑定循环变量了,这也就是自由变量的值绑定方式. func TestCountByClosureWithOk(t *testing.T) { // 1 2 3 for _, c := range countByClosureWithOk() { t.Log(c()) } } 「雪之梦技术驿站」: 自由变量通过值传递的方式传递给闭包函数,实现值绑定环境,正确绑定了循环变量 1 2 3 而不是 4 4 4 访问被捕获自由变量 第四句英文如下: Unlike a plain function, a closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope. 相应的中文翻译: 与普通函数不同,闭包允许函数通过闭包的值的副本或引用访问那些被捕获的变量，即使函数在其作用域之外被调用 闭包函数和普通函数的不同之处在于,闭包提供一种持续访问被捕获变量的能力,简单的理解就是扩大了变量的作用域. func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 自由变量 a,b 的定义发生在函数 fibonacci 体内,一般而言,变量的作用域也仅限于函数内部,外界是无法访问该变量的值或引用的. 但是,闭包提供了持续暴露变量的机制,外界突然能够访问原本应该私有的变量,实现了全局变量的作用域效果! var a, b = 0, 1 func fibonacciWithoutClosure() int { a, b = b, a+b return a } 「雪之梦技术驿站」: 普通函数想要访问变量 a,b 的值或引用,定义在函数内部是无法暴露给调用者访问的,只能提升成全局变量才能实现作用域范围的扩大. 由此可见,一旦变量被闭包捕获后,外界使用者是可以访问这些被捕获的变量的值或引用的,相当于访问了私有变量! 怎么理解闭包 闭包是一种函数式编程中实现名称绑定的技术,直观表现为函数嵌套提升变量的作用范围,使得原本寿命短暂的局部变量获得长生不死的能力,只要被捕获到的自由变量一直在使用中,系统就不会回收内存空间! 知乎上关于闭包的众多回答中,其中有一个回答言简意赅,特意分享如下: 我叫独孤求败，我在一个山洞里，里面有世界上最好的剑法，还有最好的武器。我学习了里面的剑法，拿走了最好的剑。离开了这里。我来到这个江湖，快意恩仇。但是从来没有人知道我这把剑的来历，和我这一身的武功。。。那山洞就是一个闭包，而我，就是那个山洞里唯一一个可以与外界交汇的地方。这山洞的一切对外人而言就像不存在一样，只有我才拥有这里面的宝藏！ 这也是闭包定义中最后一句话表达的意思: 山洞是闭包函数,里面的剑法和武器就是闭包的内部环境,而独孤求败剑客则是被捕获的自由变量,他出生在山洞之外的世界,学成归来后独自闯荡江湖.从此江湖上有了独孤求败的传说和那把剑以及神秘莫测的剑法. 掌握闭包了么 问题: 请将下述普通函数改写成闭包函数? func count() []int { var arr []int for i := 1; i 回答: 闭包的错误示例以及正确示例 func countByClosureButWrong() []func() int { var arr []func() int for i := 1; i 那么,问题来了,原本普通函数就能实现的需求更改成闭包函数实现后,一不小心就弄错了,为什么还需要闭包? 闭包归纳总结 现在再次回顾一下斐波那契数列生成器函数,相信你已经读懂了吧,有没有看到闭包的影子呢? // 1 1 2 3 5 8 13 21 34 55 // a b // a b func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 但是,有没有想过这么一个问题: 为什么需要闭包,闭包解决了什么问题? 闭包不是某一种语言特有的机制,但常出现在函数式编程中,尤其是函数占据重要地位的编程语言. 闭包的直观表现是函数内部嵌套了函数,并且内部函数访问了外部变量,从而使得自由变量获得延长寿命的能力. 闭包中使用的自由变量一般有值传递和引用传递两种形式,示例中的斐波那契数列生成器利用的是引用而循环变量示例用的是值传递. Go 不支持函数嵌套但支持匿名函数,语法层面的差异性掩盖不了闭包整体的统一性. 「雪之梦技术驿站」: 由于篇幅所限,为什么需要闭包以及闭包的优缺点等知识的相关分析打算另开一篇单独讨论,敬请期待... 相关资料参考 廖雪峰: js 的闭包教程 知乎: 什么是闭包 三点水博客: 再谈闭包 const btw = new BTWPlugin(); btw.init({ id: 'container', blogId: '15702-1569305559839-744', name: '雪之梦技术驿站', qrcode: 'https://snowdreams1006.github.io/snowdreams1006-wechat-public.jpeg', keyword: 'vip', }); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/functional/fib.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/functional/closure.html":{"url":"go/functional/closure.html","title":"简要理解闭包","keywords":"","body":"简要理解闭包 闭包是主流编程语言中的一种通用技术,常常和函数式编程进行强强联合,本文主要是介绍 Go 语言中什么是闭包以及怎么理解闭包. 如果读者对于 Go 语言的闭包还不是特别清楚的话,可以参考上一篇文章 go 学习笔记之仅仅需要一个示例就能讲清楚什么闭包. 或者也可以直接无视,因为接下来会回顾一下前情概要,现在你准备好了吗? Go ! 斐波那契数列见闭包 不论是 Go 官网还是网上其他讲解闭包的相关教程,总能看到斐波那契数列的身影,足以说明该示例的经典! 斐波那契数列(Fibonacci sequence),又称黄金分割数列 .因数学家列昂纳多·斐波那契(Leonardoda Fibonacci)以兔子繁殖为例子而引入,故又称为“兔子数列”,指的是这样一个数列: 1、1、2、3、5、8、13、21、34、……在数学上,斐波那契数列以如下被以递推的方法定义: F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*） .在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用,为此,美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志,用于专门刊载这方面的研究成果. 根据上述百度百科的有关描述,我们知道斐波那契数列就是形如 1 1 2 3 5 8 13 21 34 55 的递增数列,从第三项开始起,当前项是前两项之和. 为了计算方便,定义两个变量 a,b 表示前两项,初始值分别设置成 0,1 ,示例: // 0 1 1 2 3 5 8 13 21 34 55 // a b // a b a, b := 0, 1 初始化后下一轮移动,a, b = b, a+b 结果是 a , b = 1 , 1,刚好能够表示斐波那契数列的开头. 「雪之梦技术驿站」试想一下: 如果 a,b 变量的初始值是 1,1 ,不更改逻辑的情况下,最终生成的斐波那契数列是什么样子? func fibonacciByNormal() { a, b := 0, 1 a, b = b, a+b fmt.Print(a, \" \") fmt.Println() } 但是上述示例只能生成斐波那契数列中的第一个数字,假如我们需要前十个数列,又该如何? func fibonacciByNormal() { a, b := 0, 1 for i := 0; i 通过指定循环次数再稍加修改上述单数列代码,现在就可以生成前十位数列: // 1 1 2 3 5 8 13 21 34 55 func TestFibonacciByNormal(t *testing.T) { fibonacciByNormal() } 这种做法是接触闭包概念前我们一直在采用的解决方案,相信稍微有一定编程经验的开发者都能实现,但是闭包却提供了另一种思路! // 1 1 2 3 5 8 13 21 34 55 func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 不论是普通函数还是闭包函数,实现斐波那契数列生成器函数的逻辑不变,只是实现不同,闭包返回的是内部函数,留给使用者继续调用而普通函数是直接生成斐波那契数列. // 1 1 2 3 5 8 13 21 34 55 func TestFibonacci(t *testing.T) { f := fibonacci() for i := 0; i 对于这种函数内部嵌套另一个函数并且内部函数引用了外部变量的这种实现方式,称之为\"闭包\"! 「雪之梦技术驿站」: 闭包是函数+引用环境组成的有机整体,两者缺一不可,详细请参考go 学习笔记之仅仅需要一个示例就能讲清楚什么闭包. 自带独立的运行环境 「雪之梦技术驿站」: 自带运行环境的闭包正如电影中出场自带背景音乐的发哥一样,音乐响起,发哥登场,闭包出现,环境自带! 闭包自带独立的运行环境,每一次运行闭包的环境都是相互独立的,正如面向对象中类和对象实例化的关系那样,闭包是类,闭包的引用是实例化对象. func autoIncrease() func() int { i := 0 return func() int { i = i + 1 return i } } 上述示例是闭包实现的计算器自增,每一次引用 autoIncrease 函数获得的闭包环境都是彼此独立的,直接上单元测试用例. func TestAutoIncrease(t *testing.T) { a := autoIncrease() // 1 2 3 t.Log(a(), a(), a()) b := autoIncrease() // 1 2 3 t.Log(b(), b(), b()) } 函数引用 a 和 b 的环境是独立的,相当于另一个一模一样计数器重新开始计数,并不会影响原来的计数器的运行结果. 「雪之梦技术驿站」: 闭包不仅仅是函数,更加重要的是环境.从运行效果上看,每一次引用闭包函数重新初始化运行环境这种机制,非常类似于面向对象中类和实例化对象的关系! 长生不老是福还是祸 普通函数内部定义的变量寿命有限,函数运行结束后也就被系统销毁了,结束了自己短暂而又光荣的一生. 但是,闭包所引用的变量却不一样,只要一直处于使用中状态,那么变量就会\"长生不老\",并不会因为出身于函数内就和普通变量拥有一样的短暂人生. 老骥伏枥,志在千里 func fightWithHorse() func() int { horseShowTime := 0 return func() int { horseShowTime++ fmt.Printf(\"(%d)祖国需要我,我就提枪上马立即战斗!\\n\",horseShowTime) return horseShowTime } } func TestFightWithHorse(t *testing.T) { f := fightWithHorse() // 1 2 3 t.Log(f(), f(), f()) } 「雪之梦技术驿站」: 如果使用者一直在使用闭包函数,那么闭包内部引用的自由变量就不会被销毁,一直处于活跃状态,从而获得永生的超能力! 祸兮福所倚福兮祸所伏 凡事有利必有弊,闭包不死则引用变量不灭,如果不理解变量长生不老的特性,编写闭包函数时可能一不小心就掉进作用域陷阱了,千万要小心! 下面以绑定循环变量为例讲解闭包作用域的陷阱,示例如下: func countByClosureButWrong() []func() int { var arr []func() int for i := 1; i countByClosureButWrong 闭包函数引用的自由变量不仅有 arr 数组还有循环变量 i ,函数的整体逻辑是: 闭包函数内部维护一个函数数组,保存的函数主要返回了循环变量. func TestCountByClosure(t *testing.T) { // 4 4 4 for _, c := range countByClosureButWrong() { t.Log(c()) } } 当我们运行 countByClosureButWrong 函数获得闭包返回的函数数组 arr,然后通过 range 关键字进行遍历数组,得到正在遍历的函数项 c. 当我们运行 c() 时,期望输出的 1,2,3 循环变量的值,但是实际结果却是 4,4,4. 原因仍然是变量长生不老的特性:遍历循环时绑定的变量值肯定是 1,2,3,但是循环变量 i 却没有像普通函数那样消亡而是一直长生不老,所以变量的引用发生变化了! 长生不老的循环变量的值刚好是当初循环的终止条件 i=4,只要运行闭包函数,不论是数组中的哪一项函数引用的都是相同的变量 i,所以全部都是 4,4,4. 既然是变量引用出现问题,那么解决起来就很简单了,不用变量引用就好了嘛! 最简单的做法就是使用短暂的临时变量 n 暂存起来正在遍历的值,闭包内引用的变量不再是 i 而是临时变量 n. func countByClosureButWrong() []func() int { var arr []func() int for i := 1; i 上述解决办法很简单就是采用临时变量绑定循环变量的值,而不是原来的长生不老的变量引用,但是这种做法不够优雅,还可以继续简化进行版本升级. 既然是采用变量赋值的做法,是不是和参数传递中的值传递很相像?那我们就可以用值传递的方式重新复制一份变量的值传递给闭包函数. func countByClosureWithOk() []func() int { var arr []func() int for i := 1; i 「雪之梦技术驿站」: 采用匿名函数自执行的方式传递参数 i ,函数内部使用变量 n 绑定了外部的循环变量,看起来更加优雅,有逼格! 采用匿名函数进行值传递进行改造后,我们再次运行测试用例验证一下改造结果: func TestCountByClosureWithOk(t *testing.T) { // 1 2 3 for _, c := range countByClosureWithOk() { t.Log(c()) } } 终于解决了正确绑定循环变量的问题,下次再出现实际结果和预期不符,不一定是 bug 有可能是理解不深,没有正确使用闭包! 七嘴八舌畅谈优缺点 模拟类和对象的关系,也可以实现封装,具备一定面向对象能力 「雪之梦技术驿站」: 每次调用闭包函数所处的环境都是相互独立的,这种特性类似于面向对象中类和实例化对象的关系. 缓存复杂逻辑,常驻内存,避免滥用全局变量徒增维护成本. 「雪之梦技术驿站」: 长生不老的特性使得闭包引用变量可以常驻内存,用于缓存一些复杂逻辑代码非常合适,避免了原来的全局变量的滥用. 实现闭包成本较高,同时也增加了理解难度. 「雪之梦技术驿站」: 普通函数转变成闭包函数不仅实现起来有一定难度,而且理解起来也不容易,不仅要求多测试几遍还要理解闭包的特性. 滥用容易占用过多内存,可能造成内存泄漏. 「雪之梦技术驿站」: 过多使用闭包势必造成引用变量一直常驻内存,如果出现循环引用或者垃圾回收不及时有可能造成内存泄漏问题. 简单总结下闭包知识 闭包是一种通用技术,Go 语言支持闭包,主要体现在 Go 支持函数内部嵌套匿名函数,但 Go 不支持普通函数嵌套. 简单的理解,闭包是函数和环境的有机结合整体,独立和运行环境和长生不老的引用变量是闭包的两大重要特征. 不论是模拟面向对象特性,实现缓存还是封装对象等等应用都是这两特性的应用. 最后,让我们再回忆一下贯穿始终的斐波那契数列来结束此次闭包之旅! func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 本文涉及示例代码: https://github.com/snowdreams1006/learn-go/blob/master/functional/closure/closure_test.go 参考资料及延伸阅读 闭包的概念、形式与应用 Jartto 博客:反思闭包 三点水博客: 再谈闭包 gitbook博客: 闭包的实现 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/functional/closure.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/error/about.html":{"url":"go/error/about.html","title":"错误管理","keywords":"","body":"错误管理 Go 语言中有个 defer 关键字,常用于实现延迟函数来保证关键代码的最终执行,常言道: \"未雨绸缪方可有备无患\". 延迟函数就是这么一种机制,无论程序是正常返回还是异常报错,只要存在延迟函数都能保证这部分关键逻辑最终执行,所以用来做些资源清理等操作再合适不过了. 出入成双有始有终 日常开发编程中,有些操作总是成双成对出现的,有开始就有结束,有打开就要关闭,还有一些连续依赖关系等等. 一般来说,我们需要控制结束语句,在合适的位置和时机控制结束语句,手动保证整个程序有始有终,不遗漏清理收尾操作. 最常见的拷贝文件操作大致流程如下: 打开源文件 srcFile, err := os.Open(\"fib.txt\") if err != nil { t.Error(err) return } 创建目标文件 dstFile, err := os.Create(\"fib.txt.bak\") if err != nil { t.Error(err) return } 拷贝源文件到目标文件 io.Copy(dstFile, srcFile) 关闭目标文件 dstFile.Close() srcFile.Close() 关闭源文件 srcFile.Close() 值得注意的是: 这种拷贝文件的操作需要特别注意操作顺序而且也不要忘记释放资源,比如先打开再关闭等等! func TestCopyFileWithoutDefer(t *testing.T) { srcFile, err := os.Open(\"fib.txt\") if err != nil { t.Error(err) return } dstFile, err := os.Create(\"fib.txt.bak\") if err != nil { t.Error(err) return } io.Copy(dstFile, srcFile) dstFile.Close() srcFile.Close() } 「雪之梦技术驿站」: 上述代码逻辑还是清晰简单的,可能不会忘记释放资源也能保证操作顺序,但是如果逻辑代码比较复杂的情况,这时候就有一定的实现难度了! 可能是为了简化类似代码的逻辑,Go 语言引入了 defer 关键字,创造了\"延迟函数\"的概念. 无 defer 的文件拷贝 func TestCopyFileWithoutDefer(t *testing.T) { if srcFile, err := os.Open(\"fib.txt\"); err != nil { t.Error(err) return } else { if dstFile,err := os.Create(\"fib.txt.bak\");err != nil{ t.Error(err) return }else{ io.Copy(dstFile,srcFile) dstFile.Close() srcFile.Close() } } } 有 defer 的文件拷贝 func TestCopyFileWithDefer(t *testing.T) { if srcFile, err := os.Open(\"fib.txt\"); err != nil { t.Error(err) return } else { defer srcFile.Close() if dstFile, err := os.Create(\"fib.txt.bak\"); err != nil { t.Error(err) return } else { defer dstFile.Close() io.Copy(dstFile, srcFile) } } } 上述示例代码简单展示了 defer 关键字的基本使用方式,显著的好处在于 Open/Close 是一对操作,不会因为写到最后而忘记 Close 操作,而且连续依赖时也能正常保证延迟时机. 简而言之,如果函数内部存在连续依赖关系,也就是说创建顺序是 A->B->C 而销毁顺序是 C->B->A.这时候使用 defer 关键字最合适不过. 懒人福音延迟函数 官方文档相关表述见 Defer statements 如果没有 defer 延迟函数前,普通函数正常运行: func TestFuncWithoutDefer(t *testing.T) { // 「雪之梦技术驿站」: 正常顺序 t.Log(\"「雪之梦技术驿站」: 正常顺序\") // 1 2 t.Log(1) t.Log(2) } 当添加 defer 关键字实现延迟后,原来的 1 被推迟到 2 后面而不是之前的 1 2 顺序. func TestFuncWithDefer(t *testing.T) { // 「雪之梦技术驿站」: 正常顺序执行完毕后才执行 defer 代码 t.Log(\" 「雪之梦技术驿站」: 正常顺序执行完毕后才执行 defer 代码\") // 2 1 defer t.Log(1) t.Log(2) } 如果存在多个 defer 关键字,执行顺序可想而知,越往后的越先执行,这样才能保证按照依赖顺序依次释放资源. func TestFuncWithMultipleDefer(t *testing.T) { // 「雪之梦技术驿站」: 猜测 defer 底层实现数据结构可能是栈,先进后出. t.Log(\" 「雪之梦技术驿站」: 猜测 defer 底层实现数据结构可能是栈,先进后出.\") // 3 2 1 defer t.Log(1) defer t.Log(2) t.Log(3) } 相信你已经明白了多个 defer 语句的执行顺序,那就测试一下吧! func TestFuncWithMultipleDeferOrder(t *testing.T) { // 「雪之梦技术驿站」: defer 底层实现数据结构类似于栈结构,依次倒叙执行多个 defer 语句 t.Log(\" 「雪之梦技术驿站」: defer 底层实现数据结构类似于栈结构,依次倒叙执行多个 defer 语句\") // 2 3 1 defer t.Log(1) t.Log(2) defer t.Log(3) } 初步认识了 defer 延迟函数的使用情况后,我们再结合文档详细解读一下相关定义. 英文原版文档 A \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns,either because the surrounding function executed a return statement,reached the end of its function body,or because the corresponding goroutine is panicking. 中文翻译文档 \"defer\"语句调用一个函数,该函数的执行被推迟到周围函数返回的那一刻,这是因为周围函数执行了一个return语句,到达了函数体的末尾,或者是因为相应的协程正在惊慌. 具体来说,延迟函数的执行时机大概分为三种情况: 周围函数执行return because the surrounding function executed a return statement return 后面的 t.Log(4) 语句自然是不会运行的,程序最终输出结果为 3 2 1 说明了 defer 语句会在周围函数执行 return 前依次逆序执行. func funcWithMultipleDeferAndReturn() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) return fmt.Println(4) } func TestFuncWithMultipleDeferAndReturn(t *testing.T) { // 「雪之梦技术驿站」: defer 延迟函数会在包围函数正常return之前逆序执行. t.Log(\" 「雪之梦技术驿站」: defer 延迟函数会在包围函数正常return之前逆序执行.\") // 3 2 1 funcWithMultipleDeferAndReturn() } 周围函数到达函数体 reached the end of its function body 周围函数的函数体运行到结尾前逆序执行多个 defer 语句,即先输出 3 后依次输出 2 1. 最终函数的输出结果是 3 2 1 ,也就说是没有 return 声明也能保证结束前执行完 defer 延迟函数. func funcWithMultipleDeferAndEnd() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) } func TestFuncWithMultipleDeferAndEnd(t *testing.T) { // 「雪之梦技术驿站」: defer 延迟函数会在包围函数到达函数体结尾之前逆序执行. t.Log(\" 「雪之梦技术驿站」: defer 延迟函数会在包围函数到达函数体结尾之前逆序执行.\") // 3 2 1 funcWithMultipleDeferAndEnd() } 当前协程正惊慌失措 because the corresponding goroutine is panicking 周围函数万一发生 panic 时也会先运行前面已经定义好的 defer 语句,而 panic 后续代码因为没有特殊处理,所以程序崩溃了也就无法运行. 函数的最终输出结果是 3 2 1 panic ,如此看来 defer 延迟函数还是非常尽忠职守的,虽然心里很慌但还是能保证老弱病残先行撤退! func funcWithMultipleDeferAndPanic() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(\"panic\") fmt.Println(4) } func TestFuncWithMultipleDeferAndPanic(t *testing.T) { // 「雪之梦技术驿站」: defer 延迟函数会在包围函数panic惊慌失措之前逆序执行. t.Log(\" 「雪之梦技术驿站」: defer 延迟函数会在包围函数panic惊慌失措之前逆序执行.\") // 3 2 1 funcWithMultipleDeferAndPanic() } 通过解读 defer 延迟函数的定义以及相关示例,相信已经讲清楚什么是 defer 延迟函数了吧? 简单地说,延迟函数就是一种未雨绸缪的规划机制,帮助开发者编程程序时及时做好收尾善后工作,提前做好预案以准备随时应对各种情况. 当周围函数正常执行到到达函数体结尾时,如果发现存在延迟函数自然会逆序执行延迟函数. 当周围函数正常执行遇到return语句准备返回给调用者时,存在延迟函数时也会执行,同样满足善后清理的需求. 当周围函数异常运行不小心 panic 惊慌失措时,程序存在延迟函数也不会忘记执行,提前做好预案发挥了作用. 所以不论是正常运行还是异常运行,提前做好预案总是没错的,基本上可以保证万无一失,所以不妨考虑考虑 defer 延迟函数? 延迟函数应用场景 基本上成双成对的操作都可以使用延迟函数,尤其是申请的资源前后存在依赖关系时更应该使用 defer 关键字来简化处理逻辑. 下面举两个常见例子来说明延迟函数的应用场景. Open/Close 文件操作一般会涉及到打开和开闭操作,尤其是文件之间拷贝操作更是有着严格的顺序,只需要按照申请资源的顺序紧跟着defer 就可以满足资源释放操作. func readFileWithDefer(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() return ioutil.ReadAll(f) } Lock/Unlock 锁的申请和释放是保证同步的一种重要机制,需要申请多个锁资源时可能存在依赖关系,不妨尝试一下延迟函数! var mu sync.Mutex var m = make(map[string]int) func lookupWithDefer(key string) int { mu.Lock() defer mu.Unlock() return m[key] } 总结以及下节预告 defer 延迟函数是保障关键逻辑正常运行的一种机制,如果存在多个延迟函数的话,一般会按照逆序的顺序运行,类似于栈结构. 延迟函数的运行时机一般有三种情况: 周围函数遇到返回时 func funcWithMultipleDeferAndReturn() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) return fmt.Println(4) } 周围函数函数体结尾处 func funcWithMultipleDeferAndEnd() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) } 当前协程惊慌失措中 func funcWithMultipleDeferAndPanic() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(\"panic\") fmt.Println(4) } 本文主要介绍了什么是 defer 延迟函数,通过解读官方文档并配套相关代码认识了延迟函数,但是延迟函数中存在一些可能令人比较迷惑的地方. 读者不妨看一下下面的代码,将心里的猜想和实际运行结果比较一下,我们下次再接着分享,感谢你的阅读. func deferFuncWithAnonymousReturnValue() int { var retVal int defer func() { retVal++ }() return 0 } func deferFuncWithNamedReturnValue() (retVal int) { defer func() { retVal++ }() return 0 } 延伸阅读参考文档 Defer_statements go语言的defer语句 Go defer实现原理剖析 go语言 defer 你不知道的秘密! Go语言中defer的一些坑 go defer (go延迟函数) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/error/about.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"go/error/defer.html":{"url":"go/error/defer.html","title":"延迟函数","keywords":"","body":"延迟函数 温故知新不忘延迟基础 A \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. 延迟函数的运行时机一般有三种情况: 周围函数遇到返回时 func funcWithMultipleDeferAndReturn() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) return fmt.Println(4) } 运行结果: 3 2 1 . 「雪之梦技术驿站」: defer fmt.Println(1) 和 defer fmt.Println(2) 两个语句由于前面存在 defer 关键字,因此均被延迟到正常语句 return 前.当多个 defer 语句均被延迟时,倒序执行延迟语句,这种特点非常类似于数据结构的栈(先入后出).所以依次输出 fmt.Println(3) ,defer fmt.Println(2) ,defer fmt.Println(1) . 周围函数函数体结尾处 func funcWithMultipleDeferAndEnd() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) } 运行结果: 3 2 1 . 「雪之梦技术驿站」: 比 funcWithMultipleDeferAndReturn 示例简单一些,虽然包围函数 funcWithMultipleDeferAndEnd 并没有显示声明 return 语句,但是当函数运行结束前依然不会忘记执行延迟语句.所以 fmt.Println(3) 执行完后,程序并没有立即结束而是紧接着执行延迟语句 defer fmt.Println(2) 和 defer fmt.Println(1). 当前协程惊慌失措中 func funcWithMultipleDeferAndPanic() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(\"panic\") fmt.Println(4) } 运行结果: 3 2 1 . 「雪之梦技术驿站」: 和 funcWithMultipleDeferAndReturn 示例有点类似,只不过由原来的 return 语句换成了 panic(\"panic\"). 我们知道延迟语句 defer fmt.Println(1) 和 defer fmt.Println(2) 肯定会被延迟执行,所以并不会先输出 1,2 而是先执行了 fmt.Println(3) ,下一步就遇到了 panic(\"panic\") ,此时顾不上惊慌失措,先让已存在的 defer 语句先执行再说! 同时,defer 是倒序执行的,因而先输出 defer fmt.Println(2) 再输出 defer fmt.Println(1) ,最后完成使命,光荣挂掉,至于 fmt.Println(4) 就无法执行了! 关于这一句话的详细解读,请参考 go 学习笔记之解读什么是defer延迟函数,示例源码见 snowdreams1006/learn-go/tree/master/error 如果你真的试图去理解 defer 的执行时机,最好看一下汇编代码的具体实现,推荐一下大佬的 defer关键字 关于 defer 关键字相关解释,摘录如下: 当函数包含 defer 语句,则汇编代码: c call runtime.deferreturn， add xx SP return goroutine 的控制结构中,有一张表记录 defer ,调用 runtime.deferproc 时会将需要 defer 的表达式记录在表中,而在调用 runtime.deferreturn 的时候，则会依次从 defer 表中出栈并执行。 但是,从语义上理解会更加简单,问一下自己为什么需要 defer 关键字,到底解决了什么问题? 一旦理解了 defer 关键字的实现意图,那么自然而然就能大概猜出有关执行顺序,所以何必深究实现细节呢? 简而言之,defer 关键字是确保程序一定会执行的代码逻辑,不管程序是正常 return 还是意外 panic ,包围函数一旦存在 defer 关键字就要保证延迟函数一定执行! 当存在多个 defer 关键字时,意味着有多个紧急任务需要处理,时间紧迫,当然是事故发生点最近的优先执行,离return 或 panic 越远的越晚执行. 所以以防万一和就近原则是理解 defer 执行时机的最佳途径: 万一哪天发生火灾,第一反应自然是就近救人啊! 支持什么又不支持哪些 The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements. 支持函数调用 func funcCallWithDefer() { fmt.Println(\"funcInvokeWithDefer function is called\") } func TestFuncCallWithDefer(t *testing.T) { // 「雪之梦技术驿站」: defer 语句可以是函数调用. fmt.Println(\" 「雪之梦技术驿站」: defer 语句可以是函数调用.\") defer funcCallWithDefer() fmt.Println(\"TestFuncInvokeWithDefer function call has ended\") } 支持方法调用 type Lang struct { name string website string } func (l *Lang) ToString() { fmt.Printf(\"Lang:[name = %s,website = %s] \\n\", l.name, l.website) } func TestMethodCallWithDefer(t *testing.T) { // 「雪之梦技术驿站」: defer 语句也可以是方法调用. fmt.Println(\" 「雪之梦技术驿站」: defer 语句也可以是方法调用.\") var l = new(Lang) l.name = \"Go\" l.website = \"https://snowdreams1006.github.io/go/\" defer l.ToString() fmt.Println(\"TestMethodCallWithDefer method call has ended\") } 不可以被括号包裹 内建函数和表达式一样受限 函数名 说明 说明 close 关闭channel 仅用于channel通讯 delete 从map中删除实例 map操作 len 返回字符串，slice和数组的长度 可用于不同的类型 cap 返回容量 可用于不同的类型 new 内存分配 用于各种类型 make 内存分配 仅用于chan/slice/map copy 复制slice slice操作 append 追加slice slice操作 panic 报告运行时问题 异常处理机制 recover 处理运行时问题 异常处理机制 print 内建打印函数 主要用于不引入fmt的时候的调试，实际使用时建议使用标准库fmt println 内建打印函数 主要用于不引入fmt的时候的调试，实际使用时建议使用标准库fmt complex 构造复数类型 复数操作 real 抽出复数的实部 复数操作 imag 抽出复数的虚部 复数操作 func TestBuiltinFuncCallWithDefer(t *testing.T) { // 「雪之梦技术驿站」: defer 语句不可以被括号包裹. fmt.Println(\" 「雪之梦技术驿站」: defer 语句不可以被括号包裹.\") arr := new([10]int) arr[4] = 5 arr[7] = 8 // defer discards result of len(arr) defer len(arr) defer println(\"Calls of built-in functions are restricted as for expression statements.\") fmt.Println(\"TestBuiltinFuncCallWithDefer function call has ended\") } 咬文嚼字深入理解延迟 Each time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the \"defer\" statement is executed. 打蛇打七寸 Each time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Each time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. 每次延迟语句执行时,函数值和调用参数会像以往一样被评估和保存,但是实际函数并不会被调用. func trace(funcName string) func(){ start := time.Now() fmt.Printf(\"function %s enter at %s \\n\",funcName,start) return func(){ fmt.Printf(\"function %s exit at %s(elapsed %s)\",funcName,time.Now(),time.Since(start)) } } func foo(){ fmt.Printf(\"foo begin at %s \\n\",time.Now()) defer trace(\"foo\")() time.Sleep(5*time.Second) fmt.Printf(\"foo end at %s \\n\",time.Now()) } func TestFoo(t *testing.T) { foo() } trace 函数实现了函数计时功能,而 foo 函数则是包围函数用于演示 defer 关键字的逻辑,TestFoo 是测试函数,输出测试结果. 测试结果如下: === RUN TestFoo foo begin at 2019-11-18 23:12:38.519097 +0800 CST m=+0.000735902 function foo enter at 2019-11-18 23:12:38.519287 +0800 CST m=+0.000926011 foo end at 2019-11-18 23:12:43.524445 +0800 CST m=+5.005934027 function foo exit at 2019-11-18 23:12:43.524549 +0800 CST m=+5.006038281(elapsed > 5.005112612s)--- PASS: TestFoo (5.01s) PASS Process finished with exit code 0 如果此时试图去解释上述运行结果,很遗憾铩羽而归! 记得官方文档中关于 defer 描述的第一句话就阐明了延迟函数的执行时机,原文如下: A \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. 但是如果按照这句话来解释此次示例的运行结果,显然是解释不通的! func foo(){ fmt.Printf(\"foo begin at %s \\n\",time.Now()) defer trace(\"foo\")() time.Sleep(5*time.Second) fmt.Printf(\"foo end at %s \\n\",time.Now()) } func TestFoo(t *testing.T) { foo() } 如果 defer trace(\"foo\")() 延迟函数真的被延迟到函数体结束之前,那么上述 foo() 函数应该等价于这种形式: func fooWithoutDefer(){ fmt.Printf(\"foo begin at %s \\n\",time.Now()) time.Sleep(5*time.Second) fmt.Printf(\"foo end at %s \\n\",time.Now()) trace(\"foo\")() } func TestFooWithoutDefer(t *testing.T) { fooWithoutDefer() } 但是对于 fooWithoutDefer 函数的执行结果直接实力打脸: === RUN TestFooWithoutDefer foo begin at 2019-11-19 11:44:20.066554 +0800 CST m=+0.001290523 foo end at 2019-11-19 11:44:25.068724 +0800 CST m=+5.003312582 function foo enter at 2019-11-19 11:44:25.068796 +0800 CST m=+5.003384341 function foo exit at 2019-11-19 11:44:25.068847 +0800 CST m=+5.003435185(elapsed 51.196µs)--- PASS: TestFooWithoutDefer (5.00s) PASS Process finished with exit code 0 由此可见,延迟函数其实并不简单,想要弄清楚 defer 关键字还要继续读下去才有可能! 这一点也是我最大的疑惑,潜意识告诉我: 只要无法真正理解 Each time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. 这句话的含义,那么永远不可能彻底弄清 defer 关键字! 通过直接调换 defer 语句的出现位置并没有解释测试结果,反而告诉我们 defer 语句可不是简简单单的延迟执行. 任何函数都会或多或少依赖相应的执行环境,defer 延迟函数也不例外,在本示例中 defer trace(\"foo\")() 延迟函数的 trace(\"foo\") 函数的返回值是函数,然后 trace(\"foo\")() 相当于立即执行返回函数,因而问题可能出现在 trace(\"foo\") 函数中,那么不妨继续看看吧! func foo(){ fmt.Printf(\"foo begin at %s \\n\",time.Now()) defer trace(\"foo\")() time.Sleep(5*time.Second) fmt.Printf(\"foo end at %s \\n\",time.Now()) } func trace(funcName string) func(){ start := time.Now() fmt.Printf(\"function %s enter at %s \\n\",funcName,start) return func(){ fmt.Printf(\"function %s exit at %s(elapsed %s)\",funcName,time.Now(),time.Since(start)) } } 1. foo begin at 2019-11-19 14:06:42.385982 +0800 CST m=+0.000943615 暗示着已经开始进入 foo() 函数内部,接下来的 function foo enter at 2019-11-19 14:06:42.38623 +0800 CST m=+0.001191025 意味着函数并没有执行 time.Sleep(5*time.Second) 而是直接进入了 defer trace(\"foo\")() 语句内部,可见函数依旧是顺序执行,但是 trace(funcName string) func() 函数内部会返回函数,此时函数返回值并没有执行,因为此时并不存在打印输出的日志. 所以 trace(funcName string) func() 函数应该是已经执行了,接下来返回上一层回到主函数 foo() 就遇到了 time.Sleep(5*time.Second) 休息 5s 语句,所以在执行 fmt.Printf(\"foo end at %s \\n\",time.Now()) 语句时输出的时间和最近的上一句差了大概 5s . foo end at 2019-11-19 14:06:47.391581 +0800 CST m=+5.006394415 输出后也就意味着 foo() 函数运行到包围函数的结束处,此时按照延迟语句的第一句,我们知道是时候执行真正的延迟逻辑了. 所以下一句就是 trace(\"foo\")() 的函数返回值的调用,输出了 function foo exit at 2019-11-19 14:06:47.391706 +0800 CST m=+5.006518615(elapsed 5.005327927s)--- PASS: TestFoo (5.01s) 至此,延迟函数执行完毕,单元测试函数也输出了 PASS . === RUN TestFoo foo begin at 2019-11-19 14:06:42.385982 +0800 CST m=+0.000943615 function foo enter at 2019-11-19 14:06:42.38623 +0800 CST m=+0.001191025 foo end at 2019-11-19 14:06:47.391581 +0800 CST m=+5.006394415 function foo exit at 2019-11-19 14:06:47.391706 +0800 CST m=+5.006518615(elapsed 5.005327927s)--- PASS: TestFoo (5.01s) PASS 通过上述分析,可以这么理解,延迟函数也是需要执行环境的,而执行环境就是依赖于定义 defer 语句时的相关环境,这也就是延迟函数的准备阶段或者说入栈. 当遇到包围函数体返回时或到达包围函数体结尾处或发生错误时,包围函数就会调用已存在的延迟函数,这部分就是延迟函数的执行阶段或者说出栈. 无论是否存在延迟函数,均顺序执行函数逻辑 准备阶段的入栈操作会正常运行但不会调用函数 执行阶段的出栈操作在合适时机时会调用函数 同样地,仍然以消防队员作为 Go 的调度器,平民百姓作为无 defer 保护的对比参考,而有 defer 保护的特殊人群作为延迟函数. 有一天,普通百姓和特殊人士都在商场逛街,突发火灾,附近消防员迅速赶紧救人,任务只要一个:那就是按照就近原则快速救出全部特殊人群,因为这些特殊人群都是有头有脸的人物,每个人都有自己的脾气个性. 明星 A : 我进商场前拿着限量版的 LV 包包,这个我也要拿出去! 富二代 B : 我进商场前答应小女友要给他买个礼物,这个是寄存柜地址,别忘了把礼物也带回来! 暴发户 C : 我在商场有个保险柜,存放了大量金条,一定要给我带出去! 消防员很无奈,心里咒骂了一句: 这都生死攸关了,还管什么身外之物啊! 可是,埋怨归埋怨,对于这些特殊人群的照顾,那是一丁点也不敢怠慢,只能照办,终于全部救出了! A 表示声明 defer 语句时已经传递了参数,等到执行 defer 时调用的就是刚才的参数值,而 Go 语言中参数的传递只能是值传递,所以虽然看起来还是那个包,其实已经变了,这里并不是特别准确! B 表示声明 defer 语句时传递的参数不是具体值而是引用,当执行 defer 逻辑时会按图索骥,因此虽然给的是一张寄存柜的密码纸,最后拿出来的却是存在柜子里的礼物. C 表示声明 defer 时什么都没有传递,没有任何入参但是执行 defer 语句中遇到了访问包围函数的需求,这时候延迟函数会扩大搜索范围向上寻找直到找到商场的金库为止. 零依赖而无顾虑 func deferWithoutParams() { // 2 1 defer fmt.Println(1) fmt.Println(2) } 「雪之梦技术驿站」: 入栈时没有任何依赖,出栈时也不会有任何顾虑,非常简单直观输出了 2 1 . 随身携带的牵挂 func deferWithValueParams() { x := 10 defer func(n int) { // 10 fmt.Println(n) }(x) x++ } 「雪之梦技术驿站」: 入栈时存在值参数 func(n int)(10),出栈时需要输出参数的值,而 fmt.Println(n) 涉及到的 n 刚好保存在入栈环境中,所以等到 deferWithValueParams 运行到函数结束后输出的结果就是已缓存的副本 10 . 如果此时匿名函数调用的不是 n 而是 x,而变量 x 并不存在于入栈环境中,此时就会继续扩大范围搜到 deferWithValueParams 函数是否存在变量 x 的声明,本示例中找到的 x=11. func deferWithOuterParams() { x := 10 defer func(n int) { // 11 fmt.Println(x) }(x) x++ } 心有牵挂放不下 func deferWithReferParams() { x := 10 defer func(n *int) { // 11 fmt.Println(*n) }(&x) x++ } 「雪之梦技术驿站」: 入栈时保存的不再是值而是地址,因此出栈时会按图索骥,找到该地址对应的值,也就是 11 . 相信以上案例应该帮助读者理解 defer 语句的一些注意事项了吧? 延迟函数准备阶段的入栈会收集函数运行所需的环境依赖,比如说入参的值,收集结束后即使外界再改变该值也不会影响延迟函数,因为延迟函数用的是缓存副本啊! 出栈会倒序 Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. 相反的,延迟函数会在包围函数返回之前按照被延迟顺序逆序调用. func TestFuncWithMultipleDefer(t *testing.T) { // 「雪之梦技术驿站」: 猜测 defer 底层实现数据结构可能是栈,先进后出. t.Log(\" 「雪之梦技术驿站」: 猜测 defer 底层实现数据结构可能是栈,先进后出.\") // 3 2 1 defer t.Log(1) defer t.Log(2) t.Log(3) } 「雪之梦技术驿站」: 运行阶段的出栈操作会倒序执行多个 defer 延迟函数,所以输出了 3 2 1 . 及时雨插入 That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. 当包围函数通过明确的 return 返回语句返回时,defer 延迟函数会在 result parameters 结果参数被赋值之后且在函数 return 返回之前执行. 按照这句话可以将下面这种代码进行拆解: defer yyy return xxx 其中 return xxx 相当于拆开了两步并且最终返回前及时插入了 defer 语句的执行逻辑,如下: 1. result parameters = xxx 2. 调用 defer 函数 3. return 同样地,我们举例说明: func deferWithExplicitReturn() (result int) { defer func() { // 2. before : result = 10 fmt.Printf(\"before : result = %v\\n\", result) result++ // 3. after : result = 11 fmt.Printf(\"after : result = %v\\n\", result) }() result = 10 // 1. return : result = 10 fmt.Printf(\"return : result = %v\\n\", result) return result } 关于 defer 延迟函数的执行顺序和输出结果已经不再是难点了,现在主要关注下 deferWithExplicitReturn() 函数运行结束后的返回值到底是 10 还是 11 . func TestDeferWithExplicitReturn(t *testing.T) { // TestDeferWithExplicitReturn result = 11 fmt.Printf(\"TestDeferWithExplicitReturn result = %d\\n\",deferWithExplicitReturn()) } 「雪之梦技术驿站」: 测试结果输出了 11,很显然这里是因为延迟函数内部执行了 result++ 操作最终影响了外部函数的返回值. 如果对上述示例进行改造,下面的代码就清晰看出了为什么会影响返回值了. func deferWithExplicitReturnByExplain() (result int) { result = 10 // 1. return : result = 10 fmt.Printf(\"return : result = %v\\n\", result) func() { // 2. before : result = 10 fmt.Printf(\"before : result = %v\\n\", result) result++ // 3. after : result = 11 fmt.Printf(\"after : result = %v\\n\", result) }() return } 「雪之梦技术驿站」: 延迟函数会在 return 返回前有机会对返回值进行更改,这里演示了及时雨插入的逻辑,输出结果不变还是 11. 下面提供一些例题,请自行思考 func surroundingFuncEvaluatedNotInvoked(init int) int { fmt.Printf(\"1.init=%d\\n\",init) defer func() { fmt.Printf(\"2.init=%d\\n\",init) init ++ fmt.Printf(\"3.init=%d\\n\",init) }() fmt.Printf(\"4.init=%d\\n\",init) return init } func noDeferFuncOrderWhenReturn() (result int) { func() { // 1. before : result = 0 fmt.Printf(\"before : result = %v\\n\", result) result++ // 2. after : result = 1 fmt.Printf(\"after : result = %v\\n\", result) }() // 3. return : result = 1 fmt.Printf(\"return : result = %v\\n\", result) return 0 } func deferFuncWithAnonymousReturnValue() int { var retVal int defer func() { retVal++ }() return 0 } func deferFuncWithNamedReturnValue() (retVal int) { defer func() { retVal++ }() return 0 } 「雪之梦技术驿站」: 如果一眼看不出答案,不妨复制到编辑器直接运行,然后在思考为什么. 调用时报错 If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the \"defer\" statement is executed. 如果延迟函数值为 nil,则函数调用时发生错误异常 panic 而不是 defer 语句执行时报错. func deferWithNil() func() { return nil } func TestDeferWithNil(t *testing.T) { fmt.Println(\"begin exec deferWithNil()()\") defer deferWithNil()() fmt.Println(\"end exec deferWithNil()()\") } 公布答案以及总结全文 在上篇文章中留下了两个小问题,相信看到这篇文章的人都能独立完成并自行解释了吧? 下面给出问题以及答案! func deferFuncWithAnonymousReturnValue() int { var retVal int defer func() { retVal++ }() return 0 } func deferFuncWithNamedReturnValue() (retVal int) { defer func() { retVal++ }() return 0 } func TestDeferFuncWhenReturn(t *testing.T) { // 0 t.Log(deferFuncWithAnonymousReturnValue()) // 1 t.Log(deferFuncWithNamedReturnValue()) } 「雪之梦技术驿站」: deferFuncWithAnonymousReturnValue() 函数无明确的返回值参数,而 deferFuncWithNamedReturnValue() 函数已经声明了 (retVal int) 返回值,因为延迟函数并不会影响未命名的函数. 通过本文,我们知道了延迟函数的执行时机以及一些细节,关键是理解 Each time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. 这句话,绝对是重中之重! 简而言之,延迟函数在声明时会收集相关参数赋值拷贝一份入栈,时机合适时再从入栈环境中寻找相关环境参数,如果找不到就扩大范围寻找外层函数是否包含所需变量,执行过程也就是延迟函数的出栈. 有一个消防员专门负责保卫商场的安全,每天商场进进出出很多人流,总有一些重要人物也会来到商场购物,突然有一天,发生了火灾,正在大家惊慌失措中... 这个消防员到底干了什么才能保证重要人物安全的同时也能让他们不遭受财产损失? 请补充你的答案,感谢你的阅读与关注,下一节再见~ 阅读延伸以及参考文档 Defer_statements Built-in_functions Go语言规格说明书 之 内建函数（Built-in functions） go语言快速入门：内建函数(6) 你知道defer的坑吗？ golang语言defer特性详解.md Golang之轻松化解defer的温柔陷阱 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/error/defer.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-19 19:32:21 "},"go/issue/faq.html":{"url":"go/issue/faq.html","title":"常见问题","keywords":"","body":"常见问题 Why are ++ and -- statements and not expressions? And why postfix, not prefix? Without pointer arithmetic, the convenience value of pre- and postfix increment operators drops. By removing them from the expression hierarchy altogether, expression syntax is simplified and the messy issues around order of evaluation of ++ and -- (consider f(i++) and p[i] = q[++i]) are eliminated as well. The simplification is significant. As for postfix vs. prefix, either would work fine but the postfix version is more traditional; insistence on prefix arose with the STL, a library for a language whose name contains, ironically, a postfix increment. Why is there no pointer arithmetic? Safety. Without pointer arithmetic it's possible to create a language that can never derive an illegal address that succeeds incorrectly. Compiler and hardware technology have advanced to the point where a loop using array indices can be as efficient as a loop using pointer arithmetic. Also, the lack of pointer arithmetic can simplify the implementation of the garbage collector. Why are declarations backwards? They're only backwards if you're used to C. In C, the notion is that a variable is declared like an expression denoting its type, which is a nice idea, but the type and expression grammars don't mix very well and the results can be confusing; consider function pointers. Go mostly separates expression and type syntax and that simplifies things (using prefix * for pointers is an exception that proves the rule). In C, the declaration int* a, b; declares a to be a pointer but not b; in Go var a, b *int declares both to be pointers. This is clearer and more regular. Also, the := short declaration form argues that a full variable declaration should present the same order as := so var a uint64 = 1 has the same effect as a := uint64(1) Parsing is also simplified by having a distinct grammar for types that is not just the expression grammar; keywords such as func and chan keep things clear. See the article about Go's Declaration Syntax for more details. Why are maps, slices, and channels references while arrays are values? There's a lot of history on that topic. Early on, maps and channels were syntactically pointers and it was impossible to declare or use a non-pointer instance. Also, we struggled with how arrays should work. Eventually we decided that the strict separation of pointers and values made the language harder to use. Changing these types to act as references to the associated, shared data structures resolved these issues. This change added some regrettable complexity to the language but had a large effect on usability: Go became a more productive, comfortable language when it was introduced. Why don't maps allow slices as keys? Map lookup requires an equality operator, which slices do not implement. They don't implement equality because equality is not well defined on such types; there are multiple considerations involving shallow vs. deep comparison, pointer vs. value comparison, how to deal with recursive types, and so on. We may revisit this issue—and implementing equality for slices will not invalidate any existing programs—but without a clear idea of what equality of slices should mean, it was simpler to leave it out for now. In Go 1, unlike prior releases, equality is defined for structs and arrays, so such types can be used as map keys. Slices still do not have a definition of equality, though. Why are maps built in? The same reason strings are: they are such a powerful and important data structure that providing one excellent implementation with syntactic support makes programming more pleasant. We believe that Go's implementation of maps is strong enough that it will serve for the vast majority of uses. If a specific application can benefit from a custom implementation, it's possible to write one but it will not be as convenient syntactically; this seems a reasonable tradeoff. How do constants work in Go? Although Go is strict about conversion between variables of different numeric types, constants in the language are much more flexible. Literal constants such as 23, 3.14159 and math.Pi occupy a sort of ideal number space, with arbitrary precision and no overflow or underflow. For instance, the value of math.Pi is specified to 63 places in the source code, and constant expressions involving the value keep precision beyond what a float64 could hold. Only when the constant or constant expression is assigned to a variable—a memory location in the program—does it become a \"computer\" number with the usual floating-point properties and precision. Also, because they are just numbers, not typed values, constants in Go can be used more freely than variables, thereby softening some of the awkwardness around the strict conversion rules. One can write expressions such as sqrt2 := math.Sqrt(2) without complaint from the compiler because the ideal number 2 can be converted safely and accurately to a float64 for the call to math.Sqrt. A blog post titled Constants explores this topic in more detail. Why does Go not provide implicit numeric conversions? The convenience of automatic conversion between numeric types in C is outweighed by the confusion it causes. When is an expression unsigned? How big is the value? Does it overflow? Is the result portable, independent of the machine on which it executes? It also complicates the compiler; “the usual arithmetic conversions” are not easy to implement and inconsistent across architectures. For reasons of portability, we decided to make things clear and straightforward at the cost of some explicit conversions in the code. The definition of constants in Go—arbitrary precision values free of signedness and size annotations—ameliorates matters considerably, though. A related detail is that, unlike in C, int and int64 are distinct types even if int is a 64-bit type. The int type is generic; if you care about how many bits an integer holds, Go encourages you to be explicit. Why does Go not have covariant result types? Covariant result types would mean that an interface like type Copyable interface { Copy() interface{} } would be satisfied by the method func (v Value) Copy() Value because Value implements the empty interface. In Go method types must match exactly, so Value does not implement Copyable. Go separates the notion of what a type does—its methods—from the type's implementation. If two methods return different types, they are not doing the same thing. Programmers who want covariant result types are often trying to express a type hierarchy through interfaces. In Go it's more natural to have a clean separation between interface and implementation. Why is my nil error value not equal to nil? Under the covers, interfaces are implemented as two elements, a type T and a value V. V is a concrete value such as an int, struct or pointer, never an interface itself, and has type T. For instance, if we store the int value 3 in an interface, the resulting interface value has, schematically, (T=int, V=3). The value V is also known as the interface's dynamic value, since a given interface variable might hold different values V (and corresponding types T) during the execution of the program. An interface value is nil only if the V and T are both unset, (T=nil, V is not set), In particular, a nil interface will always hold a nil type. If we store a nil pointer of type *int inside an interface value, the inner type will be *int regardless of the value of the pointer: (T=*int, V=nil). Such an interface value will therefore be non-nil even when the pointer value V inside is nil. This situation can be confusing, and arises when a nil value is stored inside an interface value such as an error return: func returnsError() error { var p *MyError = nil if bad() { p = ErrBad } return p // Will always return a non-nil error. } If all goes well, the function returns a nil p, so the return value is an error interface value holding (T=*MyError, V=nil). This means that if the caller compares the returned error to nil, it will always look as if there was an error even if nothing bad happened. To return a proper nil error to the caller, the function must return an explicit nil: func returnsError() error { if bad() { return ErrBad } return nil } It's a good idea for functions that return errors always to use the error type in their signature (as we did above) rather than a concrete type such as *MyError, to help guarantee the error is created correctly. As an example, os.Open returns an error even though, if not nil, it's always of concrete type *os.PathError. Similar situations to those described here can arise whenever interfaces are used. Just keep in mind that if any concrete value has been stored in the interface, the interface will not be nil. For more information, see The Laws of Reflection. Why doesn't Go have \"implements\" declarations? A Go type satisfies an interface by implementing the methods of that interface, nothing more. This property allows interfaces to be defined and used without needing to modify existing code. It enables a kind of structural typing that promotes separation of concerns and improves code re-use, and makes it easier to build on patterns that emerge as the code develops. The semantics of interfaces is one of the main reasons for Go's nimble, lightweight feel. See the question on type inheritance for more detail. Why does Go not support overloading of methods and operators? Method dispatch is simplified if it doesn't need to do type matching as well. Experience with other languages told us that having a variety of methods with the same name but different signatures was occasionally useful but that it could also be confusing and fragile in practice. Matching only by name and requiring consistency in the types was a major simplifying decision in Go's type system. Regarding operator overloading, it seems more a convenience than an absolute requirement. Again, things are simpler without it. Why is len a function and not a method? We debated this issue but decided implementing len and friends as functions was fine in practice and didn't complicate questions about the interface (in the Go type sense) of basic types. Why is there no type inheritance? Object-oriented programming, at least in the best-known languages, involves too much discussion of the relationships between types, relationships that often could be derived automatically. Go takes a different approach. Rather than requiring the programmer to declare ahead of time that two types are related, in Go a type automatically satisfies any interface that specifies a subset of its methods. Besides reducing the bookkeeping, this approach has real advantages. Types can satisfy many interfaces at once, without the complexities of traditional multiple inheritance. Interfaces can be very lightweight—an interface with one or even zero methods can express a useful concept. Interfaces can be added after the fact if a new idea comes along or for testing—without annotating the original types. Because there are no explicit relationships between types and interfaces, there is no type hierarchy to manage or discuss. It's possible to use these ideas to construct something analogous to type-safe Unix pipes. For instance, see how fmt.Fprintf enables formatted printing to any output, not just a file, or how the bufio package can be completely separate from file I/O, or how the image packages generate compressed image files. All these ideas stem from a single interface (io.Writer) representing a single method (Write). And that's only scratching the surface. Go's interfaces have a profound influence on how programs are structured. It takes some getting used to but this implicit style of type dependency is one of the most productive things about Go. How do I get dynamic dispatch of methods? The only way to have dynamically dispatched methods is through an interface. Methods on a struct or any other concrete type are always resolved statically. Is Go an object-oriented language? Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes). Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java. Why are map operations not defined to be atomic? After long discussion it was decided that the typical use of maps did not require safe access from multiple goroutines, and in those cases where it did, the map was probably part of some larger data structure or computation that was already synchronized. Therefore requiring that all map operations grab a mutex would slow down most programs and add safety to few. This was not an easy decision, however, since it means uncontrolled map access can crash the program. The language does not preclude atomic map updates. When required, such as when hosting an untrusted program, the implementation could interlock map access. Map access is unsafe only when updates are occurring. As long as all goroutines are only reading—looking up elements in the map, including iterating through it using a for range loop—and not changing the map by assigning to elements or doing deletions, it is safe for them to access the map concurrently without synchronization. As an aid to correct map use, some implementations of the language contain a special check that automatically reports at run time when a map is modified unsafely by concurrent execution. Why does Go not have assertions? Go doesn't provide assertions. They are undeniably convenient, but our experience has been that programmers use them as a crutch to avoid thinking about proper error handling and reporting. Proper error handling means that servers continue to operate instead of crashing after a non-fatal error. Proper error reporting means that errors are direct and to the point, saving the programmer from interpreting a large crash trace. Precise errors are particularly important when the programmer seeing the errors is not familiar with the code. We understand that this is a point of contention. There are many things in the Go language and libraries that differ from modern practices, simply because we feel it's sometimes worth trying a different approach. Why does Go not have exceptions? We believe that coupling exceptions to a control structure, as in the try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional. Go takes a different approach. For plain error handling, Go's multi-value returns make it easy to report an error without overloading the return value. A canonical error type, coupled with Go's other features, makes error handling pleasant but quite different from that in other languages. Go also has a couple of built-in functions to signal and recover from truly exceptional conditions. The recovery mechanism is executed only as part of a function's state being torn down after an error, which is sufficient to handle catastrophe but requires no extra control structures and, when used well, can result in clean error-handling code. See the Defer, Panic, and Recover article for details. Also, the Errors are values blog post describes one approach to handling errors cleanly in Go by demonstrating that, since errors are just values, the full power of Go can deployed in error handling. Why does Go not have generic types? Generics may well be added at some point. We don't feel an urgency for them, although we understand some programmers do. Go was intended as a language for writing server programs that would be easy to maintain over time. (See this article for more background.) The design concentrated on things like scalability, readability, and concurrency. Polymorphic programming did not seem essential to the language's goals at the time, and so was left out for simplicity. The language is more mature now, and there is scope to consider some form of generic programming. However, there remain some caveats. Generics are convenient but they come at a cost in complexity in the type system and run-time. We haven't yet found a design that gives value proportionate to the complexity, although we continue to think about it. Meanwhile, Go's built-in maps and slices, plus the ability to use the empty interface to construct containers (with explicit unboxing) mean in many cases it is possible to write code that does what generics would enable, if less smoothly. The topic remains open. For a look at several previous unsuccessful attempts to design a good generics solution for Go, see this proposal. What are the guiding principles in the design? When Go was designed, Java and C++ were the most commonly used languages for writing servers, at least at Google. We felt that these languages required too much bookkeeping and repetition. Some programmers reacted by moving towards more dynamic, fluid languages like Python, at the cost of efficiency and type safety. We felt it should be possible to have the efficiency, the safety, and the fluidity in a single language. Go attempts to reduce the amount of typing in both senses of the word. Throughout its design, we have tried to reduce clutter and complexity. There are no forward declarations and no header files; everything is declared exactly once. Initialization is expressive, automatic, and easy to use. Syntax is clean and light on keywords. Stuttering (foo.Foo* myFoo = new(foo.Foo)) is reduced by simple type derivation using the := declare-and-initialize construct. And perhaps most radically, there is no type hierarchy: types just are, they don't have to announce their relationships. These simplifications allow Go to be expressive yet comprehensible without sacrificing, well, sophistication. Another important principle is to keep the concepts orthogonal. Methods can be implemented for any type; structures represent data while interfaces represent abstraction; and so on. Orthogonality makes it easier to understand what happens when things combine. What are Go's ancestors? Go is mostly in the C family (basic syntax), with significant input from the Pascal/Modula/Oberon family (declarations, packages), plus some ideas from languages inspired by Tony Hoare's CSP, such as Newsqueak and Limbo (concurrency). However, it is a new language across the board. In every respect the language was designed by thinking about what programmers do and how to make programming, at least the kind of programming we do, more effective, which means more fun. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/go/issue/faq.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"zero2devops/":{"url":"zero2devops/","title":"从零开始搭建个人服务器","keywords":"","body":"从零开始搭建个人服务器 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/zero2devops/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-15 17:03:44 "},"zero2devops/login-and-logout.html":{"url":"zero2devops/login-and-logout.html","title":"登录和登出远程服务器","keywords":"","body":"登录和登出远程服务器 密码登录 登录 $ ssh @ 示例: ssh root@121.40.223.69 退出 我们可以通过 Ctrl+D 或者 exit 命令退出登录 密钥登录 本机生成密钥 $ ssh-keygen -t rsa 上传公钥到服务器 $ ssh-copy-id @ 示例: ssh-copy-id root@121.40.223.69 免密登录 $ ssh @ 示例: ssh root@121.40.223.69 简化登录 修改 ssh 配置文件 ~/.ssh/config Host HostName User 示例: Host snowdreams1006 HostName 121.40.223.69 User root 快速登录 $ ssh 示例: ssh snowdreams1006 推荐登录 修改 ssh 配置文件 ~/.ssh/config Host HostName User 示例: Host snowdreams1006 HostName 121.40.223.69 User root 本机生成密钥 $ ssh-keygen -t rsa 上传公钥到服务器 $ ssh-copy-id @ 示例: ssh-copy-id root@121.40.223.69 远程登录 $ ssh 示例: ssh snowdreams1006 禁用密码登录 /etc/ssh/ssh_config Host * PasswordAuthentication no 参考文档 SSH简介及两种远程登录的方法 服务器快速免密ssh登录配置 linux 信息查看及命令 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/zero2devops/login-and-logout.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-15 17:10:15 "},"zero2devops/nginx-https.html":{"url":"zero2devops/nginx-https.html","title":"免费实现https访问网站","keywords":"","body":"免费实现https访问网站 Let's Encrypt免费证书签发过程包含以下三个阶段： 在本地服务器上安装Certbot，Certbot是签发/更新证书的客户端程序； 运行Certbot获取SSL/TLS证书，证书有效期为3个月； 设置定时脚本每周运行一次Certbot更新证书。如果证书有效期小于30天，Certbot会更新证书； 实际运行 安装 certbot yum install -y epel-release certbot 申请证书 使用方法：certbot certonly --webroot -w [Web站点目录] -d [站点域名] -m [联系人email地址] --agree-tos sudo certbot certonly --webroot -w ~/snowdreams1006.github.io -d snowdreams1006.cn -m snowdreams1006@163.com --agree-tos pip install --upgrade --force-reinstall 'requests==2.6.0' urllib3 证书位置: tree /etc/letsencrypt/live/snowdreams1006.cn /etc/letsencrypt/live/snowdreams1006.cn ├── cert.pem -> ../../archive/snowdreams1006.cn/cert1.pem ├── chain.pem -> ../../archive/snowdreams1006.cn/chain1.pem ├── fullchain.pem -> ../../archive/snowdreams1006.cn/fullchain1.pem ├── privkey.pem -> ../../archive/snowdreams1006.cn/privkey1.pem └── README IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/snowdreams1006.cn/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/snowdreams1006.cn/privkey.pem Your cert will expire on 2020-02-17. To obtain a new or tweaked version of this certificate in the future, simply run certbot again. To non-interactively renew *all* of your certificates, run \"certbot renew\" - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 查看命令有效期 openssl x509 -noout -dates -in /etc/letsencrypt/live/snowdreams1006.cn/cert.pem 定时自动更新 yum install -y vixie-cron crontabs service crond status service crond restart # +---------------- minute 分钟(0 - 59) # | +------------- hour 小时(0 - 23) # | | +---------- day 日期(1 - 31) # | | | +------- month 月份(1 - 12) # | | | | +---- week 星期(0 - 7) (星期天=0 or 7) # | | | | | # * * * * * 要运行的命令 配置crontab，每月1号5时更新证书,并重启docker容器 00 05 01 * * sudo /usr/bin/certbot renew --quiet && sudo docker restart nginx crontab -u //设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数 crontab -l //列出某个用户cron服务的详细内容 　　 crontab -r //删除没个用户的cron服务 　　 crontab -e //编辑某个用户的cron服务 生成 PFS 键值 #创建目录 mkdir -p /etc/ssl/private/ #执行命令 cd /etc/ssl/private/ openssl dhparam 2048 -out dhparam.pem docker 启动 nginx docker run --name nginx -d -p 80:80 -p 443:443 \\ -v ~/snowdreams1006.github.io:/usr/share/nginx/html \\ -v ~/nginx/nginx.conf:/etc/nginx/nginx.conf \\ -v ~/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \\ -v ~/nginx/logs:/var/log/nginx \\ -v /etc/letsencrypt:/etc/letsencrypt \\ -v /etc/ssl:/etc/ssl \\ nginx server { listen 80; server_name snowdreams1006.cn www.snowdreams1006.cn; return 301 https://$host$request_uri; } server { listen 443 ssl http2; server_name snowdreams1006.cn www.snowdreams1006.cn; access_log /var/log/nginx/access-blog.log main; error_log /var/log/nginx/error-blog.log warn; root ~/snowdreams1006.github.io; index index.html index.htm; ssl on; ssl_certificate /etc/letsencrypt/live/snowdreams1006.cn/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/snowdreams1006.cn/privkey.pem; ssl_session_timeout 1d; ssl_session_cache shared:SSL:50m; ssl_session_tickets on; ssl_buffer_size 8k; ssl_dhparam /etc/ssl/private/dhparam.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 一般推荐使用的ssl_ciphers值: https://wiki.mozilla.org/Security/Server_Side_TLS ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128:AES256:AES:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK'; ssl_prefer_server_ciphers on; location / { #security headers add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"; add_header X-XSS-Protection \"1; mode=block\" always; add_header X-Content-Type-Options \"nosniff\" always; add_header X-Frame-Options \"DENY\" always; #CSP add_header Content-Security-Policy \"frame-src 'self'; default-src 'self'; script-src 'self' 'unsafe-inline' https://maxcdn.bootstrapcdn.com https://ajax.googleapis.com; img-src 'self'; style-src 'self' https://maxcdn.bootstrapcdn.com; font-src 'self' data: https://maxcdn.bootstrapcdn.com; form-action 'self'; upgrade-insecure-requests;\" always; add_header Referrer-Policy \"strict-origin-when-cross-origin\" always; } location ~* ^.+\\.(jpg|jpeg|gif|png|bmp|css|js|swf)$ { access_log off; #break; } } certbot certonly -d *.snowdreams1006.cn --manual \\ --preferred-challenges dns \\ --server https://acme-v02.api.letsencrypt.org/directory IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/snowdreams1006.cn-0001/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/snowdreams1006.cn-0001/privkey.pem Your cert will expire on 2020-02-18. To obtain a new or tweaked version of this certificate in the future, simply run certbot again. To non-interactively renew *all* of your certificates, run \"certbot renew\" - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le ls /etc/letsencrypt/live/snowdreams1006.cn/ 参考文档 User Guide centos7下docker部署nginx使用let's encrypt免费证书 ImportError: No module named 'requests.packages.urllib3 centos crontab详解 在Docker容器环境中用Let's Encrypt部署HTTPS Docker环境下自动更新Let’s Encrypt SSL证书 申请 Let's Encrypt 通配符 HTTPS 证书 Centos通过acme申请Let’s Encrypt通配符HTTPS证书-简单粗暴 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/zero2devops/nginx-https.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-20 10:24:51 "},"devops/":{"url":"devops/","title":"运维部署","keywords":"","body":"运维部署 密码登录 登录 $ ssh @ 示例: ssh root@121.40.223.69 退出 我们可以通过 Ctrl+D 或者 exit 命令退出登录 密钥登录 本机生成密钥 $ ssh-keygen -t rsa 上传公钥到服务器 $ ssh-copy-id @ 示例: ssh-copy-id root@121.40.223.69 免密登录 $ ssh @ 示例: ssh root@121.40.223.69 简化登录 修改 ssh 配置文件 ~/.ssh/config Host HostName User 示例: Host snowdreams1006 HostName 121.40.223.69 User root 快速登录 $ ssh 示例: ssh snowdreams1006 推荐登录 修改 ssh 配置文件 ~/.ssh/config Host HostName User 示例: Host snowdreams1006 HostName 121.40.223.69 User root 本机生成密钥 $ ssh-keygen -t rsa 上传公钥到服务器 $ ssh-copy-id @ 示例: ssh-copy-id root@121.40.223.69 远程登录 $ ssh 示例: ssh snowdreams1006 禁用密码登录 /etc/ssh/ssh_config Host * PasswordAuthentication no 系统版本 查看系统版本 $ uname -a cat /proc/version 查看 centos 版本号 $ cat /etc/centos-release 内存配额 $ free -h 公网 ip ifconfig.me $ curl ifconfig.me icanhazip.com $ curl icanhazip.com 内网 ip $ ifconfig eth0 登录用户 who $ who -u last $ last -a | head -5 高设置SSH空闲超时退出时间 | 服务配置 描述 设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险 检查提示 -- 加固建议 编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0-3之间。 ClientAliveInterval 600 ClientAliveCountMax 2 TODO 清单 使用 ansible 做自动化运维 使用 docker 高效部署前端应用 前端部署演化史 linux 调优各项监控指标小记 sed 命令使用及示例 jq: 命令行下的 json 处理工具 博客域名更换记录以及衍生问题解决方案 使用 Let's Encrypt 为 Traefik 制作证书并自动续期 github 托管私有仓库，并结合 github action 做 CI/CD quay 构建镜像 cloudflare 免费的 CDN sentry 异常上报 aws-lambda 简单的 API 参考文档 SSH简介及两种远程登录的方法 服务器快速免密ssh登录配置 linux 信息查看及命令 LICENSE 知识共享许可协议 Figure: 知识共享许可协议 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/devops/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-18 20:12:52 "},"devops/docker-env.html":{"url":"devops/docker-env.html","title":"docker 环境","keywords":"","body":"docker 环境 Docker 官方文档, CentOS 官方安装文档. 注意: 以下方式安装的是社区免费版 docker-ce 前提条件 目前在Linux系统上安装Docker，对系统版本有以下要求： CentOS：7 Debian：7.7(Wheezy LTS)、8.0(Jessie LTS)、9(Stretch) Fedora：24、25 Ubuntu：16.04(Xenial LTS)、14.04(Trusty LTS)、17.04(Zesty) 通过 uname -r 命令查看内核版本 uname -r 安装 docker 移除旧版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装必要系统依赖 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存 sudo yum makecache fast 安装 docker-ce sudo yum -y install docker-ce 运行 docker 启动 docker sudo systemctl start docker 测试 hello-world docker run hello-world 镜像加速 镜像地址: http://hub-mirror.c.163.com 配置文件: /etc/docker/daemon.json { \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"] } 卸载 docker sudo yum remove docker-ce sudo rm -rf /var/lib/docker 快速安装 安装 # step 1: 安装必要的一些系统工具 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 # Step 2: 添加软件源信息 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # Step 3: 更新并安装Docker-CE sudo yum makecache fast sudo yum -y install docker-ce # Step 4: 开启Docker服务 sudo service docker start # 注意： # 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。 # vim /etc/yum.repos.d/docker-ee.repo # 将[docker-ce-test]下方的enabled=0修改为enabled=1 # # 安装指定版本的Docker-CE: # Step 1: 查找Docker-CE的版本: # yum list docker-ce.x86_64 --showduplicates | sort -r # Loading mirror speeds from cached hostfile # Loaded plugins: branch, fastestmirror, langpacks # docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable # docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable # docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable # Available Packages # Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos) # sudo yum -y install docker-ce-[VERSION] 验证 docker version 安装记录 卸载旧版本 [root@iZbp19ryeo103foh7nc3rmZ ~]# sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装必要软件 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加软件源 官方源 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 阿里源 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 更新缓存 sudo yum makecache fast 安装 docker-ce sudo yum install -y docker-ce docker-ce-cli containerd.io docker 版本 docker version 启动 docker sudo systemctl start docker 查看状态 sudo systemctl status docker 测试 docker sudo docker run hello-world 镜像加速 针对Docker客户端版本大于 1.10.0 的用户 /etc/docker/daemon.json 阿里私人镜像地址: 例如： 公网Mirror：[系统分配前缀].mirror.aliyuncs.com https://8upnmlh3.mirror.aliyuncs.com docker info 重新加载 systemctl daemon-reload 重启 docker sudo systemctl restart docker 参考资料 Get Docker Engine - Community for CentOS Linux（Centos版本）如何快速安装docker 安装Docker 官方镜像加速 镜像仓库概述 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/devops/docker-env.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-11 16:17:47 "},"devops/docker-ops.html":{"url":"devops/docker-ops.html","title":"docker 操作","keywords":"","body":"docker 操作 docker login sudo docker login --username=雪之梦技术驿站 registry.cn-hangzhou.aliyuncs.com config.json cat ~/.docker/config.json `` ## docker pull ## docker images ## docker push ## 从零开始学习 docker ```shell docker docker 帮助命令 docker command --help 运行容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] docker run -it ubuntu /bin/bash 退出容器 exit 查看容器 docker ps -a 启动容器 docker start b750bbbcfd88 后台运行 docker run -itd --name ubuntu-test ubuntu /bin/bash 停止容器 docker stop 重启容器 docker restart 进入容器 docker attach 和 docker exec docker attach 1e560fca3906 注意: 如果从这个容器退出,会导致容器的停止. docker exec -it 243c32535da7 /bin/bash 导出容器 docker export 1e560fca3906 > ubuntu.tar 导入容器 docker import - test/ubuntu:v1 删除容器 docker rm -f 1e560fca3906 清理掉所有处于终止状态的容器 docker container prune 端口映射 docker port bf08b7f2cd89 查看容器日志 docker logs -f bf08b7f2cd89 查看容器进程 docker top wizardly_chandrasekhar 镜像操作 列出镜像 docker images 下载镜像 docker pull 查找镜像 docker search httpd 删除镜像 docker rmi hello-world 创建镜像 docker commit -m=\"updated\" -a=\"snowdreams1006\" eb3c83541f05 snowdreams1006/ubuntu 构建镜像 FROM centos:6.7 MAINTAINER Fisher \"fisher@sudops.com\" RUN /bin/echo 'root:123456' |chpasswd RUN useradd runoob RUN /bin/echo 'runoob:123456' |chpasswd RUN /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" >/etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D Dockerfile docker build -t runoob/centos:6.7 . 设置镜像标签 docker tag 860c279d2fec runoob/centos:dev web 应用 随机映射 docker run -d -P training/webapp python app.py 指定端口 docker run -d -p 5000:5000 training/webapp python app.py 指定地址 docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py 容器互联 命名容器 docker run -d -P --name runoob training/webapp python app.py 新建网络 docker network create -d bridge test-net 连接容器 docker run -itd --name test1 --network test-net ubuntu /bin/bash var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/devops/docker-ops.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-13 18:35:47 "},"devops/docker-gitbook.html":{"url":"devops/docker-gitbook.html","title":"docker + gitbook","keywords":"","body":"docker + gitbook docker 搜索镜像 docker search nginx 列出镜像 docker images 下载镜像 docker pull nginx 运行容器 docker ps 启动容器 docker run --name nginx-test -p 80:80 -d nginx 部署到 nginx 服务器创建 nginx 文件 mkdir -p ~/nginx/www ~/nginx/conf ~/nginx/logs 拷贝到容器内部 docker cp 6dd4380ba708:/etc/nginx/nginx.conf ~/nginx/conf 部署 nginx docker run -d -p 80:80 --name blob.snodreams1006.cn -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx nginx 重新载入 nginx docker kill -s HUP container-name 重启 nginx 容器 docker restart container-name 实际情况 安装 tree yum install -y tree 启动容器 docker run --name blob.snodreams1006.cn -p 80:80 -d nginx 拷贝到容器内部 docker cp 6af3f4d1911c:/etc/nginx/nginx.conf ~/nginx/conf 停止容器 docker stop blob.snodreams1006.cn 上传服务器 scp -r /Users/snowdreams1006/Documents/workspace/snowdreams1006.github.io/_book/* root@121.40.223.69:~/nginx/www 部署 nginx docker run -d -p 80:80 --name blob.snowdreams1006.cn -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx nginx 参考资料 Docker 安装 Nginx 检查TCP 80端口是否正常工作 安全组应用案例 Docker 安装 Nginx Mac/Linux/Centos终端中上传文件到Linux云服务器 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/devops/docker-gitbook.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-16 15:46:06 "},"tools/":{"url":"tools/","title":"工具资源","keywords":"","body":"工具资源 总结记录下使用过程中值得推荐的软件,正所谓\"授人以鱼不如授人以渔\",有些博主总结的更加全面有用,在此也分享下. 工具资源 快典小报 快典小报，每周不定期精选优质内容！ Chrome插件英雄榜 Chrome插件英雄榜, 为优秀的Chrome插件写一本中文说明书, 让Chrome插件英雄们造福人类~ Github星聚弃疗榜(Github星爆沙雕榜) 为Github创意项目写一本推荐书，让Github优秀项目造福人类~ IRM Markdowner | 微信排版编辑器 微信公众号格式化工具 : https://github.com/hadeshe93/irm-markdowner WeChat Format | 微信公众号排版编辑器 微信公众号排版编辑器 : https://github.com/lyricat/wechat-format 微信公众号格式化工具 在线Markdown转换器 : https://github.com/dyc87112/online-markdown/ -图表秀帮助文档 最好用的在线图表制作网站 : https://www.tubiaoxiu.com/ Cocos Creator v2.0 用户手册 gitbook 搭建的 Cocos Creator v2.0 用户手册 https://docs.cocos.com/creator/manual/zh/ OpenFalcon 产品文档 OpenFalcon是一款企业级、高可用、可扩展的开源监控解决方案 : http://book.open-falcon.org/ azk docs/ azk 是本地化开发的开源协调器 : http://docs.azk.io/ Learning Git Branching | 闯关游戏顺便学 git 游戏闯关中学习 git 常用技巧 : https://github.com/pcottle/learnGitBranching carbon | 源码转图片 将源码转成图片分享出去! https://github.com/dawnlabs/carbon GPSspg | 在线地图经度纬度查询 基于Google谷歌地图、百度地图、腾讯地图QQ地图、高德地图、图吧地图在线地图技术，可实现经度纬度查询地名位置、地名查询经度纬度位置、任意地图位置解析经纬度。海拔高度查询。 Regexper | 正则表达式可视化工具 正则表达式可视化工具 : https://gitlab.com/javallone/regexper-static sourceforge | 开源软件托管平台 完全开源和商业软件平台 : https://sourceforge.net/ Pandownload | 网盘下载神器 在线解析百度网盘资源,加速下载不封号 : https://www.baiduwp.com/ convert anything to anything 功能强大且免费的文档转换工具 : https://cloudconvert.com/ 博客主页 八一菜刀 有志者,事竟成!苦心人,天不负!加油吧~！！！ Lyric 歌词经理,是一名产品经理. 程序猿DD 《Spring Cloud微服务实战》作者，SpringCloud中文社区创始人（bbs.springcloud.com.cn），Spring4All社区联合发起人（spring4all.com) 大大的微笑 博客最核心的还是内容, 内容为王! 再华丽的简介也只是表象, 有内涵才是关键! 敖小剑的博客 敖小剑，资深码农，十六年软件开发经验，微服务专家，Service Mesh布道师，Servicemesher社区联合创始人。专注于基础架构，Cloud Native 拥护者，敏捷实践者，坚守开发一线打磨匠艺的架构师。曾在亚信、爱立信、唯品会等任职，对基础架构和微服务有过深入研究和实践. 沈煜的博客 我叫沈煜，目前是个码农。上学的时候效仿业界大佬，整了个博客，那时候用的域名还不是现在用的这个，现在看到这个博客内容已经重新开始，不定期会写点什么，内容比较随意。 Zhang Jikai的博客 暂无个人介绍,来源于 gitbook 学习而关注. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"tools/mac-install-vmware.html":{"url":"tools/mac-install-vmware.html","title":"给 mac 装个 vmware 虚拟机","keywords":"","body":"给mac装个vmware虚拟机 mac 系统安装虚拟机目前有两种主流软件,一种是 Parallels Desktop ,另一种是 vmware. 本教程选用的是 vmware ,因为我之前 windows 上安装的虚拟机软件就是vmware,所以当然选择熟悉的方式鼓捣 mac 虚拟机了啊! 如果你没听说过虚拟机,可能你走错门了,不太适合看这篇教程.如果你执意要了解一下新知识,那我只能用自己浅薄的知识简单介绍下虚拟机的基本概念,一家之言,仅供参考哟! 正常来说,我们当前使用的电脑一般只有一个系统,比如你买的是 mac 笔记本,那么电脑系统就是 mac 操作系统,肯定不会是 windows 操作系统,所以你在 mac 电脑上看不到 windows 的办公软件三件套(word,excel,ppt). 当然你的电脑如果是 联想,戴尔,华硕,神舟 等等品牌的话 ,操作系统一般都是 windows,自然也不会是看到 mac 电脑上的 xcode 软件. 这一点很好理解,每种电脑与生俱来自带特定的操作系统,但是,竟然有一种方法能够突破这层限制! 什么是虚拟机 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能,运行在一个完全隔离环境中的完整计算机系统. 虚拟机,顾名思义是虚拟的机器.虚拟意味着不是真实的,机器意味着功能像是一台机器. 所以,我们能够理解上述百度百科的定义,虚拟机就是通过软件模拟实现真实机器功能. 软件模拟硬件是手段,实现机器功能是目的,既然如此理论上应该能够模拟任何操作系统,从而实现一台真实的物理机可以有多种不同的操作系统! 这样一来是不是很神奇?一台 mac 可以模拟出 Windows 电脑,也可以模拟出 linux 电脑. 换言之,只要有一台真实的物理机,通过软件我们就可以模拟出任意操作系统,这种软件就是我们接下来要介绍的 vmware . 虚拟机的使用场景 作为软件开发者,尽管很多语言支持跨平台运行,但是为了检验真实效果,我们需要运行到不同的环境中,比如windows 和 linux 系统的差异就不是一星半点! 或者为了教程的完整性,需要在各个平台测试运行后才能放心讲解某个知识点,不然别人按照教程发现运行不了,既浪费了别人的时间,又惹得人家不高兴,好心办坏事,大家都不好受. 所以,多个系统是刚需,如果真实环境中能够提供的话,那么自然不需要虚拟机. 只有实际情况下,不能提供真实的多种操作系统的情况下,我们才使用虚拟机技术来模拟不同的操作系统. 为什么是 vmware 通过软件模拟实现虚拟机目标,关键在于软件能力如何,所以选择哪一款软件直接决定了我们的虚拟机性能如何. 市面上,这种软件并不是唯一一家,至少目前我了解的就有 vmware ,Parallels Desktop 和 virtualbox .那么为什么选择 vmware 呢? 没有为什么,因为我之前用过 vmware 而已,对于小白的我,并没研究过三者软件有什么区别,哪一种更好,只要操作足够简单,市面上足够流行就可以了. 快速体验 vmware 本教程使用的是 mac 电脑,利用虚拟机安装了三种不同系统,分别是 win7旗舰版 , centos7.5 和 Ubuntu18. windows 虚拟机 启动 windows7 旗舰版 虚拟机,并且打开 chrome 浏览器测试. centos 虚拟机 启动 centos7.5 虚拟机,并且输入 pwd 命令测试. ubuntu 虚拟机 启动 ubuntu18 虚拟机,并且输入 pwd 命令测试. 如何安装 vmware 需要实现准备好下载工具以及留下足够的内存空间,因为虚拟机和镜像毕竟都挺大,下载挺费时间,安装也比较占内存,毕竟是完整的虚拟机. 下载软件以及序列号生成工具 链接: https://pan.baidu.com/s/1D0LL_muZ_YEbmgS4A6l3pw 提取码: ti8v 复制这段内容后打开百度网盘手机App，操作更方便哦 VMware-Fusion-11.0.3-12992109.dmg [必选] 安装软件 vmware 软件是收费软件,有一段时间的试用期,这里采用序列号激活方式,有条件的话,建议支持下正版. KeyMaker.app [可选] 序列号生成工具 如果是选择官网试用版或者已购买正版,自然不需要序列号生成功能. 安装 VMware-Fusion 软件 双击安装 VMware-Fusion-11.0.3-12992109.dmg 软件,接下来一路允许按照提示操作即可. 双击安装,因为软件源不是从 App Store 下载的,所以苹果默认策略不允许安装第三方来源. 既然询问是否打开软件,当然打开,不然怎么安装呢? 然而,还是太年轻,尽管刚才已经选择打开软件,然而苹果怕是担心我们不小心安装了有害应用吧?还是需要再问我们一遍,你确定要安装吗?我确定!我怎么知道是你本人?你输入管理员密码试试,密码正确我就让你安装. 千呼万呼使出来,你终于相信我是我了,安装进行中... 安装到一定程度时,会让我们输入产品密钥进行激活,否则只能试用30天,到期会再次提醒输入密钥,接下来我们来获取序列号. 打开 KeyMaker 软件 双击运行 KeyMaker.app ,弹出一系列序列号,随意选择某一行的序列号复制到上一步安装VMware-Fusion 的产品密钥并验证. Some good serial numbers.. KGLWE-VA5KZ-D1QHT-2R51Q-ZKQVV VTZMD-ZYTKX-D1ZCR-C6QCZ-QZZEV GQZX9-ZFX3T-Z1Z6Y-AFPCW-ZZ5GZ THQQR-00TZQ-81L0R-10LEG-G2ZTZ P1VXR-GFNGC-R1JJR-JXG3T-PQ7XT ZXYXY-VMTKZ-Y1YCX-7MQ9X-MQQ6V Here another one GK9QC-9KEM4-V1VAQ-P8JEP-MK77V Greets to Corby 随便复制一个序列号,继续正常安装. 输入产品密钥后基本上就是 vmware 用户,除非你不同意它的产品协议,当然同意了! 本以为安装到此结束,没想到还想要获取辅助功能权限,没办法,既然你想要,那我就给你啊,保不齐缺胳膊少腿的. 和安装相同,不是你选择允许苹果就允许,仍然需要你提供管理员密码以此确保主观操作意愿. 授予辅助功能权限,并再次锁定该项操作,可以与想的是,以后有应用想要申请辅助功能,必须经过管理员同意才可以,为了安全需要这么多步骤,好吧. 我只想安安静静使用 vmware 产品,不希望使用数据被上传收集,当然也有点小担心,毕竟也不是正儿八经的用户,所以才不加入体验计划呢! 验证 vmware 软件 在访达或启动台中找到 VMware-Fusion 软件单击启动,测试能否正常运行软件. 小结 本节主要介绍了什么是虚拟机,虚拟机的使用场景以及如何安装虚拟机,下一节我们将介绍如何给虚拟机加点料,让虚拟机派上练武之地! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/mac-install-vmware.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/mac-vmware-install-windows.html":{"url":"tools/mac-vmware-install-windows.html","title":"给 mac 虚拟机装个 windows","keywords":"","body":"给 mac 虚拟机装个 windows 前面我们介绍了如何在 mac 宿主机安装 VMware 虚拟机软件,本节我们将继续介绍如何给虚拟机安装 windows 镜像,切换不同的操作系统. VMware 软件是容器,镜像是内核,这里的镜像指的是操作系统. 下载镜像 windows 操作系统下载: https://msdn.itellyou.cn/ 按照实际需要选择适合自己的操作系统,这里选择的是 win7 旗舰版 ,然后选择详情会弹出下载链接. 一般需要使用迅雷等第三方工具下载种子链接,大小一般在 3g 多,下载时间稍微比较久! ed2k://|file|cn_windows_7_ultimate_x64_dvd_x15-66043.iso|3341268992|7DD7FA757CE6D2DB78B6901F81A6907A|/ 配置镜像 准备好已下载的镜像文件: cn_windows_7_ultimate_x64_dvd_x15-66043.iso 打开 VMware 软件,选择 文件->新建 选项开始安装镜像文件. 弹出安装配置界面,选择 从光盘或镜像中安装 选项,然后将已下载的镜像文件拖动到安装区进行识别. 识别到镜像文件后选中该文件,点击 继续 准备下一步安装. 配置账号信息以及产品密钥等信息,暂时不需要激活的话,也可以不填写产品密钥. 集成方式选择 更加独立 ,然后点击 继续. 提示下载 VMware Tools 工具,如果可以的话,最好还是先下载,也可以安装完毕后再手动下载. 确认配置信息无误后,点击 完成 ,等待镜像安装,,, 安装镜像 人生若只如初见,远远望见熟悉的背影,便确定了你就是我要安装的操作系统. 期待花开,耐心等待你的文件复制进程. 花开花落又是一年,你说重启才能遇到最美的季节,那我便等待你的凤凰涅槃. 见证你的凤凰涅槃,期待你的浴火重生. 浴火重生后的操作系统,还差最后一步就能欣赏你的容颜. 千呼万唤始出来,犹抱琵琶半遮面,正在进行最后的准备桌面. 终于等到你,还好我没放弃! 小结 总体来说,mac 系统安装 windows 镜像配置比较简单,基本上按照默认配置即可. 下载镜像时文件一般比较大,需要利用专门的第三方工具下载,比如本文提供的下载链接是种子文件,选择的第三方工具就是迅雷. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/mac-vmware-install-windows.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/mac-vmware-install-centos.html":{"url":"tools/mac-vmware-install-centos.html","title":"给 mac 虚拟机装个 centos","keywords":"","body":"给 mac 虚拟机装个 centos 前文我们已经讲解了如何在 mac 系统上安装虚拟机软件,这节我们接着讲解如何利用虚拟机安装 centos 镜像. 安装镜像的大致步骤基本相同,只不过是配置项略显不同而已,如果需要安装其他系统镜像,请参考另外两篇教程. 下载镜像 centos 操作系统下载: https://www.centos.org/download/ DVD ISO 和 Minimal ISO 两种类型,普通用户推荐选择前一种标准版,开发用户建议选择后一种最小版. 标准版功能比较齐全,最小版保证最小依赖,后续缺啥填啥,比较灵活节省空间内存. 按照实际需要选择适合自己的操作系统,这里选择的是 centos7.6 ,然后选择合适的下载方式(直接下载或下载种子链接). 建议选择镜像服务器下载,如果直接下载官网的地址,速度感人,时间有点长. 依次选择 list of current mirrors -> http://mirrors.aliyun.com/centos/ -> 7.6.1810/ -> isos/ -> x86_64/ -> CentOS-7-x86_64-Minimal-1810.iso 选择合适的版本点击下载. 配置镜像 准备好已下载的镜像文件: CentOS-7-x86_64-Minimal-1804.iso 打开 VMware 软件,选择 文件->新建 选项开始安装镜像文件. 弹出安装配置界面,选择 从光盘或镜像中安装 选项,然后将已下载的镜像文件拖动到安装区进行识别. 识别到镜像文件后选中该文件,点击 继续 准备下一步安装. 选择固件类型,默认方式 传统 BIOS .然后点击 继续 . 确认配置信息无误后,点击 完成 ,等待镜像安装,,, 安装镜像 只因在人群中看见了 centos ,便确定了你就是我要安装的操作系统. 阅览安装摘要信息,等待继续安装. 设置用户信息,包括设置 root 用户密码和创建初始用户账号信息. 花开花落又是一年,你说重启才能遇到最美的季节,那我便等待你的凤凰涅槃. 终于等到你,还好我没放弃! 按照之前配置的用户信息登录系统,打印出当前路径,证明安装成功. 小结 总体来说,mac 系统安装 centos 镜像配置比较简单,基本上按照默认配置即可. 下载镜像时文件一般比较大,需要利用专门的第三方工具下载,既可以选择下载种子链接也可以直接下载. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/mac-vmware-install-centos.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/mac-vmware-install-ubuntu.html":{"url":"tools/mac-vmware-install-ubuntu.html","title":"给 mac 虚拟机装个 ubuntu","keywords":"","body":"给 mac 虚拟机装个 ubuntu 前文我们已经讲解了如何在 mac 系统上安装虚拟机软件,这节我们接着讲解如何利用虚拟机安装 Ubuntu 镜像. 安装镜像的大致步骤基本相同,只不过是配置项略显不同而已,如果需要安装其他系统镜像,请参考另外两篇教程. 下载镜像 Ubuntu 操作系统下载: https://www.ubuntu.com/download 这里我们选择桌面版(Ubuntu Desktop),接着选择 LTS 长期支持版进行下载安装. 按照实际需要选择适合自己的操作系统,这里选择的是 Ubuntu18 LTS ,然后选择下载. 配置镜像 准备好已下载的镜像文件: ubuntu-18.04.2-desktop-amd64.iso 打开 VMware 软件,选择 文件->新建 选项开始安装镜像文件. 弹出安装配置界面,选择 从光盘或镜像中安装 选项,然后将已下载的镜像文件拖动到安装区进行识别. 识别到镜像文件后选中该文件,点击 继续 准备下一步安装. linux 快捷安装选项中配置用户信息,点击 继续 . 确认配置信息无误后,点击 完成 ,等待镜像安装... 安装镜像 只因在人群中看见了 Ubuntu ,便确定了你就是我要安装的操作系统. 惊鸿一瞥,容颜出现,安装进行时. 熟悉的命令行,成功只差一步. 现在输入之前配置的账号信息,开始登陆系统,见证奇迹的时刻即将来临... 终于等到你,还好我没放弃! 小结 总体来说,mac 系统安装 Ubuntu 镜像配置比较简单,基本上按照默认配置即可. 下载镜像时文件一般比较大,需要利用专门的第三方工具下载,既可以选择下载种子链接也可以直接下载. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/mac-vmware-install-ubuntu.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/windows-install-vmware.html":{"url":"tools/windows-install-vmware.html","title":"给 windows 装个 vmware 虚拟机","keywords":"","body":"给 windows 装个 vmware 虚拟机 如果长时间处于同一种环境,慢慢得我们会觉得有些无聊,所以适当地出去走走看看外面的世界能带给我们不一样的体验. 所以,何不出去走走,看看另一个世界? 然而,平时需要工作很难抽身无所顾忌地潇洒走开,这是不是意味着无法离开,要画地为牢了呢? 既然是工作问题,那么我们就从工作本身开始改变,我们每个人的电脑正常来说都只有一个操作系统,如果有一种方式能够让你切换到另一种操作系统上,岂不是相当于计算机的旅游了吗? 虽然我们本人不能亲身去另外一个地方看看,就让计算机代替我们去体验不同的环境吧! 虚拟机理论上支持任何操作系统,换句话说,Windows 系统可以装 Windows ,也可以装 Mac 和 Linux 等等. 如何换个新环境 Windows 电脑想要体验另一种操作系统,最简单的方式莫过于借助虚拟机方式,何为虚拟机? 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能,运行在一个完全隔离环境中的完整计算机系统. 虚拟机,顾名思义就是虚拟的计算机,虚拟意味着并不是真正的,计算机意味着拥有普通电脑的基本功能. 所以虚拟机要表达的意思就是说,创建一台并不是真实的计算机,但这种计算机却拥有普通计算机的基本能力. 正是由于虚拟机概念的提出,使得原本单一的操作系统支持多种不同的操作系统.Windows 计算机可以装Windows ,也可以装 Mac ,当然还有开发人员专用的 Linux. 原来的计算机称之为物理机也叫作宿主机,新产生的计算机就是虚拟机. 只要有明确的目标,虚拟机就能带你的计算机去另外一个世界. 平时不敢在物理机进行的秘密实验,你可以搬到虚拟机去实验; 羡慕键盘如飞的电脑黑客,你可以装个 Linux 虚拟机去体验一把命令行操作的灵活自由; 某些操作只能使用 Mac 电脑完成而苦于身边没有 Mac 电脑,也可以装个 Mac 虚拟机感受一下苹果的优雅. ... 不论是哪一种应用场景,虚拟机基本上都能满足,值得注意的是,虚拟机虽好,不要贪多哟! 只有物理机的性能足够强劲,才建议安装虚拟机,否则的话,病怏怏的身体怎么承受得住活泼好动灵魂的折腾. 安装虚拟机软件 市面上的虚拟机软件可选性有不少,而我主要介绍的是 VMware 软件的解决方案. VMware 软件不仅支持 Windows 宿主机,也支持 Mac 宿主机,而且一直在用也挺好的. 既然应认定了 VMware ,那还等什么,赶紧出来让我们看一眼吧! 百度搜索 vmware 或者直接进入 https://www.vmware.com/cn.html 即可访问 vmware 官网. 如果无法访问,可能需要另辟蹊径,具体原因你猜猜看. 打开 下载 > 免费产品试用版和演示 > Workstation Pro 查看下载页面. 跳转到下载页面后,选择 Windows 版本,点击 立即下载,耐心等待文件下载. Windows 下载链接: https://www.vmware.com/go/getworkstation-win 下载完毕后,双击 VMware-workstation-full-15.0.4-12990004.exe 进行默认安装,安装过程比较简单,以下动图仅供参考. 产品密钥可以使用 KeyGen.exe 自动生成,也可以从下列密钥中随意挑选一个. GF1T2-D8G97-M85MY-LDMNC-PZA96 AV34H-DDG8L-48EXQ-CQZET-ZZUR2 YY51H-FJXEQ-H85YQ-U5M5X-Q38D0 VY74R-FXX81-085PQ-DMMQT-X2AF6 VY10K-8WY03-H808Y-35YZE-NKKV2 YY11K-8UY46-M88MP-VMYEE-MYAF6 AA30K-27ZEL-480DQ-3DZ7C-MQKU4 VV7N8-D2E41-M852Q-8EQEX-ZQRU0 VC190-46W06-08E8P-TGQ5T-MLR8D AZ3NH-DQX9N-488RP-15ZXC-Q68VA 现在 vmware 已经安装成功,接下来我们将创建新的虚拟机,开始真正的计算机换装旅行吧! 在菜单栏依次点击 帮助 > 关于 确认一下是否注册成功. 虽然提供激活码注册方式,但是还是想说有条件的小伙伴请支持正版! 回顾总结 本文主要介绍了什么是虚拟机和虚拟机的应用场景以及如何安装 Vmware 软件从而安装虚拟机. 简单来说,虚拟机就是运行在本机上的一个虚拟独立的计算机,虽然不是真实的物理机,但是却拥有计算机的基本属性,不论是想在新电脑上瞎折腾还是想体验不同的操作系统,虚拟机都可以满足你的需求. 值得注意的是,虚拟机虽好,不要贪多哟,毕竟虚拟机很占资源,如果宿主机本身不给力的话,虚拟机也很难流畅地运行. 下节预告: 给 windows 虚拟机装个 windows 给 windows 虚拟机装个 centos 给 windows 虚拟机装个 ubantu var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/windows-install-vmware.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/windows-vmware-install-mac.html":{"url":"tools/windows-vmware-install-mac.html","title":"给 windows 虚拟机装个 mac","keywords":"","body":"给 windows 虚拟机装个 mac 众所周知,Mac 很好但也很贵,对一般大众而言,漂亮简洁高颜值,对软件开发者而言,方便省心有点贵. 好到什么程度? 内置大量常用的开发工具,省去了初学者安装配置环境的麻烦,版本控制工具 svn 默认已安装,web 服务器 apache 默认已安装,编程开发环境 php 默认已安装等等,例子很多就不一一列举了. 除此之外,Mac 系统不同于 Windows 系统,Mac 系统是一种类 Unix 操作系统,命令行工具很好用,相当于提前熟悉 Linux 语法了,这一点是 Windows 望尘莫及的. 贵到什么程度? 随随便便的普通版七八千,如果再稍微挑挑拣拣,起码一两万! 如果预算不够但又想体验一下 Mac 电脑,该怎么办? 答案很简单,直线去去线下苹果体验店啊! 哈哈,我是开玩笑的,言归正传,买不起真实的苹果笔记本也没关系,我们可以像安装普通软件那样,安装一个苹果笔记本! 下面我们将介绍一种方法,让你能够在 Windows 电脑上安装一个苹果笔记本,用起来和真的一样,只不过你我都心知肚明,那并不是真实的机器! 知识扫盲 虚拟机是相对于真实的物理机而言的概念,是在我们当前正在使用的计算机基础上,通过软件或硬件的方式创造的新的计算机. VMware 是常用的虚拟机软件之一,物理机安装好 VMware 软件就可以利用该软件虚拟出任意计算机即虚拟机. VMware 支持 Windows ,Mac 和 Linux 等常见操作系统,是名副其实的跨平台软件. 镜像 是一种特殊格式的文件,文件后缀名一般是 .iso ,但也要例外,比如本文安装的 macOS Mojave 10.14 18A391 Lazy Installer(MD5-CDD5EDA714D8BCC8E799F8272556CF3B).cdr 的后缀名却是 .cdr ,镜像文件就是创建虚拟机的必要程序,有了它 VMware 软件才能创建出虚拟机. 总的来说,VMware 软件加载 xxos.iso 镜像文件创建出 xxos 虚拟机. 所以,阅读教程前请务必准备好 VMware 虚拟机以及相应的镜像文件. 安装准备 虚拟机技术能够虚拟出任何操作系统,并不局限于 Windows 安装 Mac ,也可以安装 Linux 或者 Windows . 同理,虚拟机技术也不局限于 VMware ,也可以是 VirtualBox 或者 Parallels Desktop 等等. 为了避免选择困难症,下面以 VMware 虚拟机安装 Mac 为例,简单演示一下安装流程. 安装 Mac 操作系统需要两个前提条件: Windows 电脑已安装好 VMware 虚拟机. Windows 电脑已下载好 Mac 操作系统镜像. 链接: https://pan.baidu.com/s/1zL7-nB7ukif6nWBQ8KyOMA 提取码: hrgr 给 windows 装个 vmware 虚拟机 给 mac 装个 vmware 虚拟机 如果尚未安装 VMware 虚拟机,请参考上述链接进行安装,如果链接已失效,请私信我补发. macOS Unlocker for VMware v3.0.2.zip 解锁文件,是安装镜像文件的前提. macOS Mojave 10.14 18A391 Lazy Installer(MD5-CDD5EDA714D8BCC8E799F8272556CF3B).cdr 镜像文件,是安装 Mac 操作系统的灵魂. 友情提示,百度云下载大文件限速太厉害,一定要准备好下载方案或者开通超级VIP进行下载. 安装镜像 解锁镜像 打开 VMware 软件,选择 文件-> 创建新的虚拟机 或者在主页中选择 创建新的虚拟机 . 选择已下载好的镜像文件,选择文件时默认后缀名是 .iso 而我们安装的镜像文件是 .cdr ,因此一定要选择全部文件,这样就能选中 macOS Mojave 10.14 18A391 Lazy Installer(MD5-CDD5EDA714D8BCC8E799F8272556CF3B).cdr 镜像文件了! 虽然已经加载镜像文件,但是存在警告信息: 无法检测此光盘镜像中的操作系统. 无关紧要,下一步手动指定安装的镜像文件是 Mac 10.14 操作系统即可! 当我们理所当然点击下一步时,顿时傻眼了,竟然没有 Mac os 操作系统,凭什么?! 客户机操作系统选项没有 Mac 操作系统是不是因为上一步的警告信息呢?还真不是,因为并没有解锁! 解压 macOS Unlocker for VMware v3.0.2.zip 并找到 win-install.cmd 文件,选中该文件右键以管理员身份运行! 测试时运行效果是一闪而过,应该也无碍,只要再次安装镜像时出现 Mac Os 操作系统就是解锁成功. 如果没有解锁成功,打开 windows 任务管理器 并杀死 vmware 相关的全部进程,再次运行win-install.cmd 命令. 继续安装 解锁成功后,再次打开 VMware 软件继续安装镜像文件,此时已经出现 Mac os 操作系统选项了,如果没有出现该选项,请返回上一步. 接下来正常安装,傻瓜式操作均采用默认配置,直接点击下一步,直到安装完成. 安装虚拟机后,有啥秘密试验都可以在虚拟机上进行操作啦,再也不担心会不小心损坏物理机了呢! 开机体验 虚拟机安装完毕后,选择启动该虚拟机,正如物理机按开机按键一样,静静等待传说中的黑苹果! 安装一会接着提示\"无法在更新服务器上找到组件\",这是因为网络不通或者破解软件的原因,可以暂时忽略该错误. 设置语言,使劲往下滑直到最后,然后选择简体中文,紧接着下一步. 开始安装 macOS 操作系统,选择\"继续\". 同意协议并继续下一步. 不好意思,我又指了一条错误的安装道路! 下一步无路可走,只好返回,现在又回到准备安装的界面,看来我们必须准备好安装磁盘才能继续! 选择 实用工具->磁盘工具 开始准备安装磁盘. 打开的新页面左侧有两块磁盘,选择下面以 VMWare 开头的磁盘,编辑好磁盘名称(如 snowdreams1006),然后点击抹掉. 完成后关闭当前页面并返回到开始安装页面,紧接着继续下一步直到上次停留的页面. 现在已经出现了安装磁盘,选择刚刚命名的 snowdreams1006 安装磁盘,继续愉快的下一步! 虽然说还剩 16min ,实测感觉要长多了,幸运的是,接下来的安装步骤没有特别需要注意点,因此整理成动图略过. 终于安装完毕,退出安装光盘,大功告成! 并不是所有的安装版本都是最新版,当初的最新版也不一定是现在的最初版,如果追求最新操作系统,那你可以手动升级啊! 总结 VMware 软件是一款跨平台的虚拟机操作软件,加载到有效的镜像文件就能创造出虚拟机,值得注意的是,由于创造的虚拟机是一个完整的操作系统,占用了物理机一定的资源,因此物理机性能不够强劲的话,不要创建过多的虚拟机. 一两个虚拟机足矣,不使用虚拟机时一定要及时关机,否则电脑卡到怀疑人生! 安装虚拟机的必要文件是各种各种的镜像文件,有个镜像文件就有了相应的虚拟机,一般来说,镜像文件都是网络上别人制作好的或者官方提供的,当然,如果你愿意的话,你也可以制作自己的镜像供别人下载使用. 镜像文件一般都是比较大的,小则 3g ,大则 7g ,因此下载镜像文件比较费时,不同镜像文件安装时间也不尽相同,快则 1h,慢则 3h. 至于虚拟机配置方面,一般来说采用系统默认值即可,除非你有特殊需求或者明白你正在设置的选项含义,否则不要随意更改推荐设置. 安装虚拟机中途可能会多次重启虚拟机,请耐心等待,不要中断安装操作,该完成时自会完成! 最后,感谢你的阅读,希望能够对你有所帮助! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/windows-vmware-install-mac.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/windows-vmware-install-windows.html":{"url":"tools/windows-vmware-install-windows.html","title":"给 windows 虚拟机装个 windows","keywords":"","body":"给 windows 虚拟机装个 windows 前面我们已经介绍了如何在 Windows 宿主机安装 VMware 虚拟机,这节我们将利用安装好的 VMware 软件安装 Windows 系统. 前情回顾 虚拟机是相对于真实的物理机而言的概念,是在我们当前正在使用的计算机基础上,通过软件或硬件的方式创造的新的计算机. 本文主要介绍的是 VMware 虚拟机,下载并安装 VMware 软件再安装操作系统即可模拟出另一台计算机的效果,这种模拟出来的计算机就是虚拟机. VMware 不仅支持 Windows 也支持 Linux ,对于 Mac 系统也是支持的,如需了解 Mac 宿主机如何安装使用虚拟机,可以参考工具资源系列之给mac装个虚拟机. Windows 物理机如何安装虚拟机请参考 给 windows 装个 vmware 虚拟机 下载镜像 VMware 为我们安装虚拟机提供了环境,真正的虚拟机到底是 Windows 系统还是 Linux 系统取决于我们要安装什么操作系统. 安装操作系统最简单便捷的方式就是下载操作系统的镜像文件,VMware 识别到镜像文件后就会一步一步安装操作系统. 所以我们第一步要做的就是寻找镜像文件,正所谓\"知自知彼方能百战不殆\",意味着首先要确定下我们到底要安装哪一个版本的操作系统? Windows 操作系统有很多种,有 Win7 ,Win8 和 Win10 ,还有旗舰版和家庭版. 如果我们购买真实的计算机,那肯定要好好考虑一下,毕竟金钱要花的有价值,然而我们要安装的虚拟机,并不收费,这么多版本我们可以任意挑选安装! 如果有明确的目标,可以按照实际需求自行下载相应的操作系统; 如果没有明确的目标,不妨和我一样安装一个和本机相似的虚拟机,一来操作比较熟悉,而来可以在虚拟机进行任意实验. 所以,首先我要看一下本机的系统版本,因此我决定安装同款 Win7 旗舰版! 选择 我的电脑 > 右键属性 > 查看计算机的相关属性 ,我的电脑是 Windows 7 旗舰版 现在已经明确了虚拟机的操作系统,那我们去哪里下载目标虚拟机的镜像文件呢? 这里推荐一下 https://msdn.itellyou.cn/ 网站,方便使用,好评! Windows 7 Enterprise (x64) - DVD (Chinese-Simplified) : 64 位企业版 Windows 7 Enterprise (x86) - DVD (Chinese-Simplified) : 32 位企业版 Windows 7 Enterprise with Service Pack 1 (x64) - DVD (Chinese-Simplified) : 64 位企业版且带有service package 1 Windows 7 Enterprise with Service Pack 1 (x86) - DVD (Chinese-Simplified) : 32 位企业版且带有service package 1 Windows 7 Home Basic (x86) - DVD (Chinese-Simplified) : 32 位家庭普通版 Windows 7 Home Basic with Service Pack 1 (x86) - DVD (Chinese-Simplified) : 32 位家庭普通版且带有service package 1 Windows 7 Home Premium (x64) - DVD (Chinese-Simplified) : 64 位家庭高级版 Windows 7 Home Premium (x86) - DVD (Chinese-Simplified) : 32 位家庭高级版 Windows 7 Home Premium with Service Pack 1 (x64) - DVD (Chinese-Simplified) : 64 位家庭高级版且带有service package 1 Windows 7 Home Premium with Service Pack 1 (x86) - DVD (Chinese-Simplified) : 32 位家庭高级版且带有service package 1 Windows 7 Professional (x64) - DVD (Chinese-Simplified) : 64 位专业版 Windows 7 Professional (x86) - DVD (Chinese-Simplified) : 32 位专业版 Windows 7 Professional with Service Pack 1 (x64) - DVD (Chinese-Simplified) : 64 位专业版且带有service package 1 Windows 7 Professional with Service Pack 1 (x86) - DVD (Chinese-Simplified) : 32 位专业版且带有service package 1 Windows 7 Professional with Service Pack 1, VL Build (x64) - DVD (Chinese-Simplified) : 64 位专业版且带有service package 1,并基于 VL 进行构建. Windows 7 Professional with Service Pack 1, VL Build (x86) - DVD (Chinese-Simplified) : 32 位专业版且带有service package 1,并基于 VL 进行构建. Windows 7 Professional, VL Build (x64) - DVD (Chinese-Simplified) : 64 位专业版并基于 VL 进行构建. Windows 7 Professional, VL Build (x86) - DVD (Chinese-Simplified) : 32 位专业版并基于 VL 进行构建. Windows 7 Starter (x86) - DVD (Chinese-Simplified) : 32 位初级版 Windows 7 Starter with Service Pack 1 (x86) - DVD (Chinese-Simplified) : 32 位初级版且带有service package 1 Windows 7 Ultimate (x64) - DVD (Chinese-Simplified) : 64 位旗舰版 Windows 7 Ultimate (x86) - DVD (Chinese-Simplified) : 32 位旗舰版 Windows 7 Ultimate with Service Pack 1 (x64) - DVD (Chinese-Simplified) : 64 位旗舰版且带有service package 1 Windows 7 Ultimate with Service Pack 1 (x86) - DVD (Chinese-Simplified) : 32 位旗舰版且带有service package 1 Windows Automated Installation Kit for Windows 7 and Windows Server 2008 R2 (x86, x64, ia64) - DVD (Chinese-Simplified) : Windows 7 and Windows Server 2008 R2 (x86, x64, ia64) 自动安装包套件 Windows Automated Installation Kit for Windows 7 and Windows Server 2008 R2 Service Pack 1 (x86, x64, ia64) - DVD (Chinese-Simplified) : Windows 7 and Windows Server 2008 R2 Service Pack 1 (x86, x64, ia64) 自动安装包套件 上述这么多的版本是不是让人有些眼花缭乱,具体版本之间有何差异以及自己适合哪一种请百度一下再理性分析! 以下以 64 位旗舰版且带有服务包操作系统为例进行演示,主要是创建一个和宿主机一样的操作环境,方便后续进行秘密实验! cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso 镜像文件,其中 cn 表示中文简体语言, Windows_7 表示 Win7 操作系统, ultimate 表示旗舰版,sp1 表示service package 1 ,x64 表示 64 位操作系统,dvd 表示 DVD 安装方式,677408 应该是版本号,.iso 是镜像文件的后缀. ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ 由于镜像文件本身比较大,因此推荐使用专业的下载工具进行,这里使用的是迅雷下载磁力链接. 镜像文件: cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso ,其中后缀是 .iso ,千万不要解压! 不要解压! 不要解压! 安装镜像 准备好已下载的镜像文件: cn_windows_7_ultimate_x64_dvd_x15-66043.iso 打开 VMware 软件,选择 文件-> 创建新的虚拟机 或者在主页中选择 创建新的虚拟机 . 总体来说,安装过程比较简单,前面相关配置按照默认值即可,后面真正安装过程可能耗费时间比较长,耐心等待安装完成. VMware 仅能识别出镜像文件基本信息,具体版本信息还是需要手动校准,下载的镜像文件是 Win7 旗舰版 ,因此安装版本也是 Win7 旗舰版 . 一系列安装配置完毕后,还有最后一步配置确认操作,确认无误后点击 完成 就可以真正进行安装虚拟机了! 安装过程中可能要求输入产品密钥以及设置用户,这些操作和新买计算机刚开机时操作一模一样,百度找一下相应版本的产品密钥即可,可以设置登录用户也可以不设置用户. 至此,安装成功! 安装虚拟机后,有啥秘密试验都可以在虚拟机上进行操作啦,再也不担心会不小心损坏物理机了呢! 回忆总结 VMware 软件提供了虚拟机环境,差一个操作系统就能创建出虚拟机,而这种操作系统大部分是 .iso镜像文件. 镜像文件基本上至少 3g ,下载镜像文件也比较耗时,可以利用专业第三方下载工具进行下载. 虚拟机配置比较简单,采用推荐的默认值进行设置即可,除非你有特殊需求或者明白你正在设置的选项含义,否则不要随意更改推荐设置. 安装虚拟机中途可能会多次重启虚拟机,请耐心等待,不要中断安装操作,完成后自会完成! 工具资源系列之给windows装个虚拟机 工具资源系列之给mac装个虚拟机 工具资源系列之给mac虚拟机装个windows 如果觉得本文写的不错,欢迎点赞留言和转发哟! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/windows-vmware-install-windows.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/windows-vmware-install-centos.html":{"url":"tools/windows-vmware-install-centos.html","title":"给 windows 虚拟机装个 centos","keywords":"","body":"给 windows 虚拟机装个 centos 前面我们已经介绍了如何在 Windows 宿主机安装 VMware 虚拟机,这节我们将利用安装好的 VMware 软件安装 centos 系统. 前情回顾 由于大多数人使用的 Windows 电脑而工作中可能需要一台 centos 电脑,如果条件允许的话,一般公司会有相应的测试服务器. 但是,如果是个人使用的话,公司的测试服务器就不能轻易做各种实验了,毕竟测试服务器是大家公用的,万一不小心搞坏了影响了他人的使用就不好交代了. 因此,最好能够有一台私有的 centos 计算机,可以随意鼓捣还不用担心影响到其他人,这种情况下虚拟机提供了很好的解决思路. 虚拟机是相对宿主机而言较为独立的计算机,即使不小心把虚拟机搞崩了也不要紧,重新装下虚拟机就好了,也不会损坏真实的宿主机. 而我们介绍的虚拟机软件是 VMware ,跨平台支持三大主流操作系统,因此无论是 Windows 还是 Mac 或者 Linux 系统都可以借壳生蛋,继续创造出不同的操作系统. 给 windows 装个 vmware 虚拟机 给 mac 装个 vmware 虚拟机 下载镜像 centos 操作系统下载: https://www.centos.org/download/ 安装 centos 操作系统需要镜像文件,寻找镜像文件最简单的方法是 centos 自己的官网,因此我们直接去官方看一下吧! 这里提供了 DVD ISO 和 Minimal ISO 两种类型,普通用户推荐选择前一种标准版,开发用户建议选择后一种最小版. 标准版功能比较齐全,最小版保证最小依赖,后续缺啥填啥,比较灵活节省空间内存. 按照实际需要选择适合自己的操作系统,这里选择的是 centos7.6 ,然后选择合适的下载方式(直接下载或下载种子链接). 建议选择镜像服务器下载,如果直接下载官网的地址,速度感人,时间有点长. 依次选择 list of current mirrors -> http://mirrors.aliyun.com/centos/ -> 7.6.1810/ -> isos/ -> x86_64/ -> CentOS-7-x86_64-Minimal-1810.iso 选择合适的版本点击下载. 镜像文件: CentOS-7-x86_64-Minimal-1810.iso ,其中后缀是 .iso ,千万不要解压! 不要解压! 不要解压! 安装镜像 准备好已下载的镜像文件: CentOS-7-x86_64-Minimal-1810.iso 打开 VMware 软件,选择 文件-> 创建新的虚拟机 或者在主页中选择 创建新的虚拟机 . 总体来说,安装过程比较简单,前面相关配置按照默认值即可,后面真正安装过程可能耗费时间比较长,耐心等待安装完成. 一系列安装配置完毕后,还有最后一步配置确认操作,确认无误后点击 完成 就可以真正进行安装虚拟机了! 安装过程中配置语言,默认是英语,中文简体在最下面,一直往下翻选择简体中文即可. 设置超级管理员密码以及添加用户,用于安装完毕后登陆系统. 至此,安装成功! 安装虚拟机后,有啥秘密试验都可以在虚拟机上进行操作啦,再也不担心会不小心损坏物理机了呢! 回忆总结 VMware 软件提供了虚拟机环境,只要一个操作系统的镜像文件就能轻易创建出虚拟机,认准镜像文件的后缀名是 .iso . VMware 虚拟机配置比较简单,基本上采用默认值进行设置即可,除非你有特殊需求或者明白你正在设置的选项含义,否则不要随意更改推荐设置. 安装虚拟机中途可能会多次重启虚拟机,请耐心等待,不要中断安装操作,完成后自会完成! 工具资源系列之给windows装个虚拟机 工具资源系列之给mac装个虚拟机 工具资源系列之给虚拟机装个centos 如果觉得本文写的不错,欢迎点赞留言和转发哟! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/windows-vmware-install-centos.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/windows-vmware-install-ubuntu.html":{"url":"tools/windows-vmware-install-ubuntu.html","title":"给 windows 虚拟机装个 ubuntu","keywords":"","body":"给 windows 虚拟机装个 ubuntu 前面我们已经介绍了如何在 Windows 宿主机安装 VMware 虚拟机,这节我们将利用安装好的 VMware 软件安装 Ubuntu 系统. 前情回顾 虚拟机为我们在 Windows 宿主机体验别的系统提供了可能,虚拟机的强大之处在于我们可以自由安装任意操作系统,不管是同款 Windows 还是 Linux 都可以! 关于如何安装 VMware 软件可以参考上一篇文章,这里给出 Windows 和 Mac 的安装教程. 给 windows 装个 vmware 虚拟机 给 mac 装个 vmware 虚拟机 下载镜像 Ubuntu 操作系统下载: https://www.ubuntu.com/download 这里我们选择桌面版(Ubuntu Desktop),接着选择 LTS 长期支持版进行下载安装. 按照实际需要选择适合自己的操作系统,这里选择的是 Ubuntu18 LTS ,然后选择下载. 镜像文件: ubuntu-18.04.2-desktop-amd64.iso ,其中后缀是 .iso ,千万不要解压! 不要解压! 不要解压! 安装镜像 准备好已下载的镜像文件: ubuntu-18.04.2-desktop-amd64.iso 打开 VMware 软件,选择 文件-> 创建新的虚拟机 或者在主页中选择 创建新的虚拟机 . 总体来说,安装过程比较简单,前面相关配置按照默认值即可,后面真正安装过程可能耗费时间比较长,耐心等待安装完成. 一系列安装配置完毕后,还有最后一步配置确认操作,确认无误后点击 完成 就可以真正进行安装虚拟机了! 安装过程中需要添加用户,用于安装完毕后登陆系统. 至此,安装成功! 安装虚拟机后,有啥秘密试验都可以在虚拟机上进行操作啦,再也不担心会不小心损坏物理机了呢! 回忆总结 VMware 虚拟机配置比较简单,安装 Ubuntu 镜像文件时耗费时间相当长,慢慢等待一切会自动安装好的. 安装虚拟机过程可能会重启虚拟机,请耐心等待,不要中断安装操作,完成后自会完成! 工具资源系列之给windows装个虚拟机 工具资源系列之给mac装个虚拟机 工具资源系列之给虚拟机装个ubuntu 如果觉得本文写的不错,欢迎点赞留言和转发哟! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/windows-vmware-install-ubuntu.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"tools/chrome-extend-learn.html":{"url":"tools/chrome-extend-learn.html","title":"学习开发自己的 chrome 插件","keywords":"","body":"学习开发自己的 chrome 插件 Extend the Browser 【干货】Chrome插件(扩展)开发全攻略 Chrome插件（chrome Extensions）开发攻略 一篇文章教你顺利入门和开发chrome扩展程序（插件） 【干货】Chrome插件(扩展)开发全攻略 手把手教你开发chrome扩展一：开发Chrome Extenstion其实很简单 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/tools/chrome-extend-learn.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"write/":{"url":"write/","title":"如何写作","keywords":"","body":"如何写作 越来越多的人想写个人博客或者打算做自媒体,笔者也是一样. 最近在学习如何写博客,分享下创作经历,避免走弯路. 首先在于定位,不同的定位决定了不同的平台.由于笔者分享的大多是技术类博客,所以主战场是各大主流的技术类博客论坛,当然还搭建了自己的官网. 考虑到前期仅仅是分享技术博客,无需购买专门的服务器,因此寻求免费的解决方案. 笔者采用的是 github 搭建个人项目官网,优点是不花一分钱,就能免费开启 https 服务,缺点是国内访问速度慢. 下面分为两部分介绍博客的创作平台,一部分是个人官网,另一部分是第三方平台. 个人官网 首先注册 github 账号(例如:用户名 snowdreams1006),然后新建特定规则的项目(例如:项目名 snowdreams1006.github.io),最后在项目下创建首页 index.html .现在访问 https://用户名.github.io/ (https://snowdreams1006.github.io/)即可. 个人官网的基本流程和特点如下: 利用 gitbook 技术将 markdown 源码文件输出为 html 静态网页. 将项目按照特定规则上传到 github 网站公开托管,生成免费网站. 源代码更新后再生成输出文件,然后一起上传到 github,个人官网自动更新. 项目源码 snowdreams1006.github.io,项目官网 https://snowdreams1006.github.io/ 点击图片会自动跳转到 https://snowdreams1006.github.io/ 第三方平台 这里列举了常逛的第三方平台,将从新手视觉看待各家平台特点,试图分析各家平台特点从而决定是否适合自身. 一家之言,仅供各位参考. 排名不分顺序,只是笔者文章依次同步的顺序而已. 1. CSDN https://www.csdn.net/ SEO 优化不错,阅读量稳定,网页端阅读体验一般,手机端干净清爽,阅读量相对稳定. 不限制作者本人点赞,重复统计本人浏览记录,突出阅读数,其次是评论数和点赞数. 2. 博客园 https://www.cnblogs.com/ SEO 优化不错,博客开通需审核,支持发布首页,但也可能因质量不达标而被移除.页面风格满满的时代感,目前暂无手机端. 限制作者本人推荐,不统计本人浏览记录,突出推荐数,其次是阅读量和评论数. 3. 开源中国 https://www.oschina.net/ 国内版 github ,高质量文章可能会被推荐至首页,否则阅读量几乎为零. 限制作者本人点赞,不统计本人浏览记录,突出访问量,其次评论数和点赞数. 4. 简书 https://www.jianshu.com/ 文艺范的自媒体平台,简洁优美文艺性十足,SEO 优化不错,日更活动鼓励持续更新,简书钻和简书贝等虚拟货币增添写作乐趣! 不限制作者本人喜欢,不统计本人浏览记录,突出简书钻,其次阅读量,评论数和点赞数. 5. 思否 https://segmentfault.com/ 国内版Stack OverFlow,专注于技术问答,界面风格绿色清新,SEO 优化不错,但忽略阅读量. 限制作者本人点赞,不统计本人浏览记录,首次发布专栏需要审核,突出投票数,其次是收藏数,最后是阅读数. 6. 掘金 https://juejin.im/timeline 异军突起,风头正盛,时间流布局,掘金小册子是一大亮点,但SEO 很差! 不限制作者本人点赞,不重复统计本人浏览记录,突出点赞数,其次是评论数,最后是阅读量. 7. 慕课网手记 https://www.imooc.com/article 丰富的免费教学视频,正所谓\"成也萧何败萧何\",手记模块相比其他专业平台还有着不少的差距,SEO 一般. 不限制作者本人点赞,重复统计本人浏览记录,文章需要审核,手记功能更像是配套教学视频而诞生的笔记,不太像专门博客. 8. 微信公众号 https://mp.weixin.qq.com/ 目前仅支持富文本编辑器,依靠粉丝流量,碎片化阅读体验,SEO 几乎没有. 需要花费精力运营公众号,限定当天阅读量和\"在看\"数,如果没有粉丝,那肯定没有阅读量. 9. B站专栏 https://www.bilibili.com/ 弹幕视频网站,开通专栏投稿,目前仅支持富文本编辑器,不适合博客,SEO 可忽略. 适合视频教程,暂不适合博客且投稿专栏限制较多,毕竟不是专业做博客的平台,谁让我误入了呢! 总结 大多数平台都有阅读量,评论,点赞等维度数据统计,但不同平台有着不同的推荐策略,优缺点如下: csdn : SEO 不错,阅读量稳定,适合新手积累信心. 博客园 : SEO 不错,阅读量有保障,适合新手提高自信. 开源中国 : SEO 一般,阅读量有挑战,适合优质文章博取官方推荐. 简书 : SEO 不错,阅读量很少,日更活动和简书钻奖励等形式鼓励持续创作,适合自我督促. 思否 : SEO 一般,阅读量一般,适合技术问答. 掘金 : SEO 很差,阅读量一般,适合优质文章. 慕课网手记 : SEO 一般,适合教学视频的配套笔记. 微信公众号 : SEO 很差,适合粉丝用户. B站 : SEO 很差,适合教学视频. 从以上分析中可以看出,只要是优质文章无论到哪都受欢迎,然而\"罗马并非一日建成\",优质文章的诞生不在一朝一夕,所以新手期应该选择适合自己的平台发展,积累到一定程度后方能\"春风得意马蹄疾,一日看遍长安花\". 个人建议: 选择简书平台,保持日更,同步到CSDN积累自信,推送到博客园,提高自信. 官网保持更新,运营公众号慢慢积累粉丝,最后再考虑开源中国,掘金和思否. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/write/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"write/markdownOrRichText.html":{"url":"write/markdownOrRichText.html","title":"markdown 和富文本","keywords":"","body":"markdown和富文本 不知道你是否留意过平时写作时的编辑器,有的是 markdown 编辑器,有的是各种富文本编辑器,到底选择哪一个相信你有自己的判断. 如果只是在某一家平台上写作,哪一种编辑器都无所谓,只要你喜欢就好. 可是如果你需要同时发布到各个平台呢?此时,真的需要停下来思考一下,我该使用哪一种编辑器了? 各家的编辑器的界面设计风格迥然不同,不仅按钮排序顺序不一样,而且最终输出效果也不尽相同. 这就给我们带来了一个问题,明明已经排好版的文章,复制到另外一家平台样式不一样了,或者格式被清除了?! 心中一万只羊驼呼啸而过,尽管如此,还是在心里告诉自己要冷静,要冷静! 既然我们追求的一处编写,到处复制,那么我就有必要郑重向你推荐 markdown 编辑器. 简单地说,markdown 编辑器是一种标记语言,写的是源码,输出的是 html. 所以很多情况下, markdown 更适合技术人员写文章,不用关心排版布局,回归写作本质,而富文本格式适合文学工作者,强调布局美观,重视审美体验. 两者看似相互独立,实际上最终展示效果几乎太大差别, markdown 格式和富文本格式最终都输出 html 格式,毕竟绝大多数阅读媒介还是各种浏览器. markdown 语法支持嵌套 html 语法,从而可以实现较为复杂的排版布局. markdown 格式 如果使用的是 markdown 格式编写文章,首先需要记忆常用的基本语法,半个小时足够入门写博客了,比txt 高级,比 html 简洁,取代 word 地位! 正是因为 markdown 语法规范,所以可以说是跨平台的写作语言,基本上各大主流的博客平台均支持 markdown 格式,保证了\"一处编写,到处复制\"的优良特性. 值得注意的是,不同平台对 markdown 格式的渲染结果稍有差异,甚至语法支持度不同,这要求我们尽量写通用语法或者因地制宜有针对性编写文章. ## markdown 二号标题 - markdown 无序列表1 - markdown 无序列表2 - markdown 无序列表3 **markdown 加粗文字效果** [markdown 超链接文字](https://snowdreams1006.github.io/markdown/) ![markdown 图片文字](./images/markdown-preview.png) markdown 快速入门 富文本格式 平常熟悉的 word 编辑器可以理解为一种富文本格式,布局,标题,超链接,图片等均以控件的形式展示,需要填写标题了点一下按钮,需要加粗效果再点一下按钮,效果直观,不需要二次渲染,但不同的平台自然是不同的布局. 一家平台的布局还不一定能够完美复制到另一家平台,虽然适合大多数人,但可移植性差! 如果需要同时发布到多家平台,简直不敢相信,复制不了样式,需要重新排版等问题绝对是一种折磨. 小结 markdown : 拥有编程经验,不关心排版布局,专注写作多家平台发表首选 markdown 编辑器,\"一处编写,到处复制\",可移植性好,最值渲染效果也不错! 富文本格式: 可视化书写文章,无需编程经验的话,首选富文本编辑器,调整鼠标就能搞定页面布局还是很轻松的,同步更新到多家平台时,页面布局格式差强人意,后期维护难度大! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/write/markdownOrRichText.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"write/markdown2richText.html":{"url":"write/markdown2richText.html","title":"markdown 转富文本","keywords":"","body":"markdown转富文本 正常情况下不太希望你能看到这篇文章,可天不遂人愿, 总有些平台至今不支持 markdown 语言,没办法只能迁就它! 现在遇到的问题是,部分平台仅支持富文本格式,不支持 markdown 格式.既然想要在这些平台上发表文章,不得不按照他们的规定做事. 下面总结下笔者在用的一些方法: 1. markdown转富文本 适合已有 markdown 格式的文章,想要优雅转换成富文本格式,这种情况下我们只要能够获取到渲染后的富文本内容,然后复制到平台的编辑器即可. 不少 markdown 编辑器支持实时预览,一边是 markdown 源码,另一边是 富文本 预览,选中富文本然后复制,相当简单. 或者,将 markdown 源码上传到第三方平台在线转换成富文本格式,推荐 Markdown Here 插件或 在线工具. Markdown Here chrome插件的使用方法: 下载安装 Markdown Here 插件 各大浏览器基本上都有相应插件,如需翻墙,请自行解决. 配置插件并重启浏览器 支持自定义css样式,内嵌多套主题可供选择. 使用快捷键或命令面板转换 默认快捷键CTRL + ALT + M,或者复制到插件的预览窗口,点击Markdown 转换 目标富文本内容拷贝回富文本编辑器 选中渲染后的富文本内容拷贝到目标编辑器 online-markdown 在线工具的使用方法: 复制源 markdown 内容转换成目标富文本格式 将源 markdown 内容复制到左侧代码区,右侧可实时预览富文本效果 目标富文本内容拷贝回富文本编辑器 点击复制后到目标编辑器选择粘贴 2. 截图分享 适合懒癌晚期的作者,第一种方法转换后的富文本可能无法完美移植到某些平台时,而笔者又懒得重新编辑富文本,因此选择截图分享方式发布在该平台,只不过这种体验上稍差些,毕竟图片加载速度比文字相对来说还是慢很多! 简书和开源中国的 app 均支持截长图保存分享,网页端的话滚动截屏插件很多,目前在用fireshot还不错. 3. 重新编辑 适合认真负责的完美主义者,既然不支持 markdown 语言,那就用富文本编辑器重新编辑一份,素材和效果都有参考,再写一遍应该也不至于特别耗费时间,如果需要重写多份的话,那就另当别论了! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/write/markdown2richText.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"write/static-semi-manual-with-csv.html":{"url":"write/static-semi-manual-with-csv.html","title":"csv 半手动数据统计","keywords":"","body":"csv半手动数据统计 背景 作为正在探索如何写作并发表到各大博客平台的新人,目前虽然已基本弄清写作和发表的基本流程,但是离打造个人知名度还差很大很大一段距离. 尤其处于新手阶段,需要的更是自信与外界的积极反馈,看着各平台日益增长的阅读量和粉丝量,心中自然不甚欣喜. 但是,持续的技术输出能否坚持下去很大程度上靠的是外界的积极反馈,如果写的文章基本没人看,或者反映并不理想,估计也很难再坚持创作了. 所以笔者每天晚上都会统计一下各个平台的数据,看一下有哪些收获,只有看得见的数据才能给我安全感和自信心. 下面简单展示一下每日数据统计效果: 每日数据统计 这里列出的平台默认是没有提供数据分析功能,而有些平台已经提供数据分析,说不定还要丰富图表分析功能,自然不用像下面这般复杂操作. 所以,针对没有提供数据分析的平台,只好采用人工方式进行每日数据统计,一开始文章比较少,用肉眼加计算器就能很轻松得到阅读量和粉丝数等数据. 但是,随着文章的每日更新,不断累加的文章越来越多,人工方式简直让我崩溃,比如昨晚在统计慕课网手记相关数据时就意外被一旁的小侄子打断三次! 简直不可忍受,穷则思变,懒则想法偷懒,所以是时候探索新的方式解决纯手动的弊端了! 全网汇总数据 慕课手记 简书 博客园 腾讯云社区 图表渲染效果来自 gitbook 的 chart 插件,详情请参考 官网文档 懒则想法偷懒 回顾操作流程 要想解放重复劳动量,必须先知道问题瓶颈,现在先回顾一下手动操作流程. 登录各大博客平台后台,找到文章列表. 打开计算器按照阅读量等指标累加每篇文章的相关数据. 更新统计页面数据,利用 chart 插件渲染图标. 修改 chart 渲染数据语法,截图渲染效果. 确认渲染效果并推送到 github 网站 本来不必利用截图表示图表的,只是无奈 github 不支持 chart 插件语法,只好用截图代替了. 思考问题瓶颈 分析上述流程后不难发现,最复杂也是最费时费力的便是第二步的数据统计,由于要肉眼统计文章并用计算器累加,简直是手脑并用,只有高度专注才能保证统计数据的准确性和可靠性. 这也就解释了被打断三次后的崩溃了,找到问题的根源了,想办法如何解决吧! 最容易想到的解决办法是手动复制文章列表数据,然后程序分析提取关键数据,最后再统计数据. 又是三步操作,再分解一下步骤,看看目前能够解决哪部分. 手动复制文章列表数据 程序分析提取关键数据 统计指标数据 在这三步中,只有第二步最为关键,也是目前我能做到的事情,因为第一步可能需要爬虫技术或模拟接口调用,总体来说,总体来说还是比较麻烦的,以后再继续优化吧. 梳理操作流程 因此,现在先着手如何将复制后的文章列表转化成程序能够处理的文件格式,进而调用程序统计. 下面以慕课网手记文章为例,简单介绍下处理流程. 手动复制文章 现在文章已复制到文件,应该保存成什么格式呢?这又是一个思考点. 由于文件内容最终需要被程序处理,而程序处理要求数据需要具备一定的格式,因此自然不能是 txt 或 word 这类文档,平常接触比较多的文档数据处理一般就是 excel 或者 json 类型的文档. 这里需要 excel 这种格式文档,但是 excel 比较笨重,还需要相关软件才能打开 excel 文件,好像并不是很适合,怎么办呢? 但是我真的需要这种一行一行的数据格式啊,有没有折中的处理方案? 当然有!轻量级的 csv 格式不是巧合适合简单文档处理吗? csv 和 excel 具有类似的特征,大体上都是一行一行一列一列地存储数据,最适合统计数据了. 看着乱七八糟的文章列表,csv 也无法处理这种复杂数据啊,接下来还是要手动格式化数据,整理一下数据. 程序分析提取 至此,我们已经完成数据分析的第一步了,接下来是如何读取 csv 文件,由于本人是 java 程序员,所以我要看一下 java 如何处理 csv 文件. 需求很简单,编写一个 csv 工具类并实现基本的写入和读取操作即可. 说到工具类当然首选现成的开源工具了,毕竟小小的需求不值得造轮子. 寻求解决方案 说到开源工具,脑海中第一个闪现的是 Apache Commons 工具类,所以先去 maven 上搜一下有没有 csv 相关的工具类. 在线搜索 commons-csv 天不负我!果然有 csv 相关工具类,下面就开始研究如何调用吧! 集成 commons-csv 工具类 org.apache.commons commons-csv 1.6 编写工具类 /** * 写入csv文件 * * @param data 数据内容 * @param filePath 文件路径 * @throws IOException **/ public static void writeCsv(List data, String filePath) throws IOException { FileWriter fw = new FileWriter(new File(filePath)); final CSVPrinter printer = CSVFormat.EXCEL.print(fw); printer.printRecords(data); printer.flush(); printer.close(); } /** * 读取csv文件 * * @param filePath 文件路径 * @return CSVRecord 迭代对象 * @throws IOException **/ public static Iterable readCSV(String filePath) throws IOException { InputStream inputStream = new FileInputStream(filePath); InputStreamReader isr = new InputStreamReader(inputStream); Iterable records = CSVFormat.EXCEL.parse(isr); return records; } /** * 测试写入并读取csv 文件 */ private static void testWriteAndRead() throws IOException { //写入数据 List data = new ArrayList(); data.add(new String[]{\"张三\", \"18\", \"3000\"}); data.add(new String[]{\"李四\", \"20\", \"4000\"}); data.add(new String[]{\"王二\", \"25\", \"5000\"}); //写入文件路径 String path = \"/Users/sunpo/Downloads/testWriteAndRead.csv\"; //写入 csv 文件 writeCsv(data, path); //读取文件 Iterable records = readCSV(path); for (CSVRecord record : records) { for (String string : record) { System.out.print(string); System.out.print(\" \"); } System.out.println(); } } 测试写入并读取功能 测试结果真实可用,工具类基本功能编写完成. 制定解决方案 已经有了 csv 工具类,那么现在就要想办法解决实际问题,再看一下当前慕课网手记的内容格式吧! 148浏览 2推荐 0评论 204浏览 2推荐 0评论 181浏览 2推荐 0评论 分析上述内容格式有以下特点: 内容数据一行一条数据,可能需要换行符问题 每一行数据以空格分割,可分割成数组或列表再处理 已分割后的列表项包括了有效数据和文字说明,可能需要过滤出有效数据 按照上述分析结果,开始 coding 逐个解决,下面展示下关键代码. 按照空格将每一行数据分割成列表 List row = StringTools.splitToListString(string, \" \"); StringTools.splitToListString 方式是笔者封装的分割字符串方法,目的将字符串按照指定分隔符分割成字符串列表 处理分割后字符串列表并过来出有效数据 String readCountWithDescString = row.get(0); String readCountString = StringUtils.substringBefore(readCountWithDescString, \"浏览\"); String recommendCountWithDescString = row.get(1); String recommendCountString = StringUtils.substringBefore(recommendCountWithDescString, \"推荐\"); String commentCountWithDescString = row.get(2); String commentCountString = StringUtils.substringBefore(commentCountWithDescString, \"评论\"); StringUtils.substringBefore 方法也是Apache Commons 工具类,具体来源于 org.apache.commons.lang3 ,下述涉及到的 StringUtils 静态方法 也是,不再单独说明. 最后一步即统计分析 //浏览数 int readCount = 0; //推荐数 int recommendCount = 0; //评论数 int commentCount = 0; readCount += Integer.parseInt(readCountString); recommendCount += Integer.parseInt(recommendCountString); commentCount += Integer.parseInt(commentCountString); 实施解决方案 如此一来,三步均已解决,现在运行以下统计方法,看一下真实效果如何. /** * 统计慕课手记 * * @throws IOException */ private static void countImooc() throws IOException { //昨日统计数据 String yesterday = DateFormatUtils.format(DateUtils.addDays(new Date(), -1), \"yyyyMMdd\"); String path = String.format(\"/Users/sunpo/Documents/workspace/count/imooc-%s.csv\", yesterday); //总行数 int allRows = 0; //有效行数 int allValidRows = 0; //当前行是否有效 boolean isValidRow = true; //浏览数 int readCount = 0; //推荐数 int recommendCount = 0; //评论数 int commentCount = 0; Iterable records = readCSV(path); for (CSVRecord record : records) { allRows++; for (String string : record) { System.out.println(string); if (StringUtils.isBlank(string)) { isValidRow = false; break; } List row = StringTools.splitToListString(string, \" \"); String readCountWithDescString = row.get(0); String readCountString = StringUtils.substringBefore(readCountWithDescString, \"浏览\"); String recommendCountWithDescString = row.get(1); String recommendCountString = StringUtils.substringBefore(recommendCountWithDescString, \"推荐\"); String commentCountWithDescString = row.get(2); String commentCountString = StringUtils.substringBefore(commentCountWithDescString, \"评论\"); readCount += Integer.parseInt(readCountString); recommendCount += Integer.parseInt(recommendCountString); commentCount += Integer.parseInt(commentCountString); } if (isValidRow) { allValidRows++; } isValidRow = true; } System.out.println(); System.out.println(String.format(\"[慕课手记] 一共读取%d行,有效行: allValidRows = %d ,其中浏览数: readCount = %d ,推荐数: recommendCount = %d ,评论数: commentCount = %d\", allRows, allValidRows, readCount, recommendCount, commentCount)); System.out.println(); } 很完美,终于不必再肉眼统计数据了,虽然很长程度上仍然依赖人工整理好 csv 文件,但是目前已经解决了纯手动的弊端. 因此,上述解决方案是半手动的方式,仍然还有很多可以优化的地方,等下次忍受不了这种方案时再解决! 小结 本文主要介绍了纯手工统计报表遇到的诸多问题,寻求一种相对简单的解决方案. 基本流程大致可以分为下述流程: 手动复制文章列表(包括阅读量,评论量和点赞数),并整理成标准的 csv 格式文件. 编写各个平台的 csv 工具处理类,解析并统计 csv 文件内容. 运行工具类得到最终统计数据,大功告成! 本文主要介绍的是解决问题的思路,对于其中涉及到的相关技术点并未深入展开,关键源码已经贴上,如果还想要更详细的完整源码,可以留言回复. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/write/static-semi-manual-with-csv.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"write/static-semi-manual-with-js.html":{"url":"write/static-semi-manual-with-js.html","title":"js 半手动数据统计","keywords":"","body":"js半手动数据统计 在日常文章数据统计的过程中,纯手动方式已经难以应付,于是乎,逐步开始了程序介入方式进行统计. 在上一节中,探索利用 csv 文件格式进行文章数据统计,本来以为能够应付一阵子,没想到仅仅一天我就放弃了. 原因还不是因为我懒,需要复制文章内容,然后整理成特定的 csv 格式,最后利用已编写的 java 工具类进行统计. 在这三步操作中,第一步复制文章内容最简单,第二步整理文章格式最麻烦,第三步编写 csv 工具类最技术. 因此,能不能再简单点?懒癌晚期,必须继续寻求新的解决方案. 关于如何利用 csv 文件处理统计数据,可以参考 https://snowdreams1006.github.io/static-semi-manual-with-csv.html 实现效果 慕课手记 慕课手记 : https://www.imooc.com/u/5224488/articles c3.generate({\"bindto\":\"#plugin-chart-1\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-04-01\", \"2019-04-02\", \"2019-04-03\", \"2019-04-04\", \"2019-04-05\", \"2019-04-06\", \"2019-04-07\", \"2019-04-08\", \"2019-04-09\", \"2019-04-10\", \"2019-04-11\", \"2019-04-12\" ], [ \"粉丝\", 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9 ], [ \"阅读量\", 3508, 3645, 3650, 4356, 4528, 4864, 5276, 5593, 5872, 5912, 6271, 6400 ], [ \"手记\", 32, 33, 34, 36, 38, 39, 40, 41, 42, 42, 44, 44 ], [ \"推荐\", 36, 36, 37, 39, 41, 42, 48, 49, 50, 50, 52, 52 ], [ \"积分\", 107, 118, 118, 130, 130, 141, 152, 173, 173, 173, 194, 195 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 简书 简书 : https://www.jianshu.com/u/577b0d76ab87 c3.generate({\"bindto\":\"#plugin-chart-2\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-04-01\", \"2019-04-02\", \"2019-04-03\", \"2019-04-04\", \"2019-04-05\", \"2019-04-06\", \"2019-04-07\", \"2019-04-08\", \"2019-04-09\", \"2019-04-10\", \"2019-04-11\", \"2019-04-12\" ], [ \"粉丝\", 7, 7, 6, 7, 6, 5, 5, 5, 5, 5, 5, 5 ], [ \"阅读量\", 343, 335, 342, 358, 374, 443, 468, 512, 548, 552, 611, 624 ], [ \"文章\", 33, 34, 35, 37, 39, 40, 41, 42, 43, 43, 46, 46 ], [ \"喜欢\", 57, 58, 59, 60, 62, 64, 65, 67, 68, 68, 68, 71, 71 ], [ \"简书钻\", 27, 28, 28, 9,9 ,9, 10, 10, 10, 10, 11, 11 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 博客园 博客园 : https://www.cnblogs.com/snowdreams1006/ c3.generate({\"bindto\":\"#plugin-chart-3\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-04-01\", \"2019-04-02\", \"2019-04-03\", \"2019-04-04\", \"2019-04-05\", \"2019-04-06\", \"2019-04-07\", \"2019-04-08\", \"2019-04-09\", \"2019-04-10\", \"2019-04-11\", \"2019-04-12\" ], [ \"粉丝\", 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18 ], [ \"阅读数\", 3889, 4096, 4207, 4388, 4411, 4435, 4471, 4728, 4866, 4867, 5189, 5274 ], [ \"随笔\", 31, 32, 33, 34, 36, 38, 39, 41, 41, 41, 43, 43 ], [ \"评论数\", 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 腾讯云社区 腾讯云社区 : https://cloud.tencent.com/developer/user/2952369/activities c3.generate({\"bindto\":\"#plugin-chart-4\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-04-04\", \"2019-04-05\", \"2019-04-06\", \"2019-04-07\", \"2019-04-08\", \"2019-04-09\", \"2019-04-10\", \"2019-04-11\", \"2019-04-12\" ], [ \"粉丝\", 13, 13, 13, 13, 13, 13, 13, 13, 13 ], [ \"阅读量\", 1192, 1561, 2131, 2144, 2149, 2158, 2159, 2163, 2165 ], [ \"文章\", 34, 34, 34, 34, 34, 34, 34, 34, 34 ], [ \"点赞\", 107, 108, 110, 107, 107, 107, 107, 107, 107 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); js 抓取分析数据 下面以 chrome 浏览器为例,说明如何利用默认控制台抓取关键数据,本文需要一定的 jQuery 基础. 慕课手记 在目标页面右键选择检查选项,打开默认开发者控制台,点击最左侧的小鼠标箭头,然后选中关键数据,比如浏览量. 此时,开发者控制台自动滚动到元素(Elements)选项卡,在目标数据上右键点击复制(Copy),接着点击复制选择器(Copy selector),现在已经定位到阅读量的节点. 点击控制台(Console)选项卡,并且将选择器更改成 jQuery 选择器,即$(\"复制的选择器\").text(),现在在控制台直接输出内容,看一下能否抓取到浏览量吧! 现在已经成功定位到指定元素,而我们要统计的是全部文章的阅读量,因此需要定位到全部元素. $(\"#articlesList > div:nth-child(1) > div.item-btm.clearfix > div > div:nth-child(1) > em\").text(); 简单分析下文章结构结合选择器分析,可以得知, 浏览,推荐和评论三者文档基本一致,唯一不同之处就是排列顺序而已,因此想要准确定位到浏览数,需要定位到第一个元素,推荐量则是第二个元素,因此类推. 83浏览 1推荐 0评论 弄清楚基本文档结构后,开始着手改造选择器使其定位到全部文章的浏览量,我们做如下改造. $(\"#articlesList div:nth-child(1) > em\").text(); 仅仅保留头部和尾部,再去掉中间部分 > div:nth-child(1) > div.item-btm.clearfix > div > ,这样就轻松定位到全部元素的浏览量了,是不是很简单? 看到控制台输出结果,心里瞬间踏实了,这不刚好是第一页全部文章的浏览量吗?观察输出内容格式可知,我们需要将整个字符串按照空格分割成字符串数组. 需要注意的是,行首还有一个空格哟,因此在分割成字符串数组前,我们先将行首的空格去除掉. // 去除空格前:\" 83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览\" $(\"#articlesList div:nth-child(1) > em\").text().trim(); // 去除空格后: \"83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览\" 现在我们再将这整个字符串按照空格分割成字符串数组. // 分割字符串前: \"83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览\" $(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"); // 分割字符串后: [\"83浏览\", \"91浏览\", \"114浏览\", \"150浏览\", \"129浏览\", \"175浏览\", \"222浏览\", \"173浏览\", \"225浏览\", \"200浏览\", \"201浏览\", \"217浏览\", \"291浏览\", \"202浏览\", \"229浏览\", \"184浏览\", \"226浏览\", \"155浏览\", \"153浏览\", \"211浏览\"] 现在我们已经够将整个字符串分割成一个个小的字符串,下面需要再将83浏览中的浏览去掉,仅仅保留数字83. $.each($(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"),function(idx,ele){ console.log(ele.substr(0,ele.lastIndexOf(\"浏览\"))); }); 现在我们已经抓取到真正的浏览量,接下来就比较简单了,直接将这些浏览量进行累加即可,需要注意的是,这里的浏览数还是字符串类型,需要转换成数字类型才能进行累加运算哟! //阅读量 var readCount = 0; $.each($(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"),function(idx,ele){ readCount += parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); }); console.log(\"阅读量: \" + readCount); 小结 我们以 chrome 浏览器为例,讲解了如何利用自带的控制台工具抓取关键数据,从页面结构分析入口,一步一个脚印提取有效数据,最终从一条数据变成多条数据,进而实现数据的累加统计. 总体来说,还是比较简单的,并不需要太多的基础知识,但还是稍微总结其中涉及到的 jQuery 知识点吧! 定位到具体元素: $(\"这里是复制的选择器\") 定位到具体元素内容: $(\"这里是复制的选择器\").text() 去除字符串首尾空格: $(\"这里是复制的选择器\").text().trim() 将字符串按照空格分割成字符串数组: $(\"这里是复制的选择器\").text().trim().split(\" \") 截取字符串指定部分: ele.substr(0,ele.lastIndexOf(\"浏览\") 将字符串转化成数字类型: parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); 变量累加求和: readCount += parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); 完整示例: //阅读量 var readCount = 0; $.each($(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"),function(idx,ele){ readCount += parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); }); console.log(\"阅读量: \" + readCount); //推荐量 var recommendCount = 0; $.each($(\"#articlesList div:nth-child(2) > em\").text().trim().split(\" \"),function(idx,ele){ recommendCount += parseInt(ele.substr(0,ele.lastIndexOf(\"推荐\"))); }); console.log(\"推荐量: \" + recommendCount); //评论量 var commendCount = 0; $.each($(\"#articlesList div:nth-child(3) > em\").text().trim().split(\" \"),function(idx,ele){ commendCount += parseInt(ele.substr(0,ele.lastIndexOf(\"评论\"))); }); console.log(\"评论量: \" + commendCount); 简书 简书的文章数据不一定很规整,比如有的发布文章还没有简书钻,所以阅读量的排列顺序就是不确定的,这一点不像前面介绍的慕课手记,但是简书的关键数据前面是有小图标的,因此我们可以利用图标定位到旁边的数据. 按照前面介绍的步骤,我们仍然定位到阅读量,然而 #note-44847909 > div > div > a:nth-child(2) > i 却不能直接使用,因为我们刚刚分析了,简书不能利用顺序定位只能用图标辅助定位. 所以,还是先看看文档结构,尝试着直接定位到全部的阅读量小图标. 经过分析文章结构,我们可以很轻松定位到全部阅读小图标,当然这是一个元素数组,并不是字符串数组哟! $(\"#list-container .ic-list-read\") 接下来我们看一下能否正确定位到每一个小图标,进而定位到小图标左侧的阅读量. 现在我们已经能够定位到全部的阅读量小图标,现在思考如何定位到旁边的真正阅读量呢? 0.2 2 0 1 昨天 10:39 分析文章结构,我们发现阅读量是小图标的父节点的内容,这一下就简单了,我们顺藤摸瓜定位到父节点自然就能定位到阅读量了! $(\"#list-container .ic-list-read\").each(function(idx,ele){ console.log($(ele).parent().text().trim()); }); 现在既然已经能够定位到阅读量,那么首先累加求和就很简单了. //阅读量 var readCount = 0; $(\"#list-container .ic-list-read\").each(function(idx,ele){ readCount += parseInt($(ele).parent().text().trim()); }); console.log(\"阅读量: \" + readCount); 小结 首先分析文章基本结构发现,简书的阅读量需要定位到阅读量小图标,进而定位到父节点,然后父节点的内容才是真正的阅读量. 定位到真正的阅读量后,一切问题迎刃而解,总结一下新增 jQuery 知识点. 定位到当前节点的父节点: $(ele).parent() 完整示例: //阅读量 var readCount = 0; $(\"#list-container .ic-list-read\").each(function(idx,ele){ readCount += parseInt($(ele).parent().text().trim()); }); console.log(\"阅读量: \" + readCount); //评论量 var commendCount = 0; $(\"#list-container .ic-list-comments\").each(function(idx,ele){ commendCount += parseInt($(ele).parent().text().trim()); }); console.log(\"评论量: \" + commendCount); //喜欢量 var recommendCount = 0; $(\"#list-container .ic-list-like\").each(function(idx,ele){ recommendCount += parseInt($(ele).parent().text().trim()); }); console.log(\"喜欢量: \" + recommendCount); 博客园 博客园的文章列表比较复古,传统的 table 布局,是这几个平台中最简单的,基本上不同怎么介绍. 复制到阅读量选择器: #post-row-10694598 > td:nth-child(4) 此时再结合文章结构,因此我们可以得到全部文章的阅读量选择器. $(\"#post_list td:nth-child(4)\") 接下来需要遍历数组,看看能否抓取到当前页面全部文章的阅读量. $(\"#post_list td:nth-child(4)\").each(function(idx,ele){ console.log($(ele).text().trim()); }); 成功抓取到阅读量,现在开始累加当前页面全部文章的阅读量. //阅读数 var readCount = 0; $(\"#post_list td:nth-child(4)\").each(function(idx,ele){ readCount += parseInt($(ele).text().trim()); }); console.log(\"阅读数: \" + readCount); 小结 中规中矩的传统 table 布局,只需要顺序定位到具体的元素即可,需要注意的是,博客园文章页面采用了分页,如果需要统计全部文章的阅读量,需要将每页的阅读量手动累加计算. 完整示例: //评论数 var commendCount = 0; $(\"#post_list td:nth-child(3)\").each(function(idx,ele){ commendCount += parseInt($(ele).text().trim()); }); console.log(\"评论数: \" + commendCount); //阅读数 var readCount = 0; $(\"#post_list td:nth-child(4)\").each(function(idx,ele){ readCount += parseInt($(ele).text().trim()); }); console.log(\"阅读数: \" + readCount); 腾讯云社区 大致分析腾讯云社区的文章结构,基本上和简书结构差不多,既可以像简书那种采用图标定位方式,也可以像慕课网和博客园那种直接顺序定位. 为了较为精准的定位,现在采用图标定位方式来获取阅读量. #react-root > div:nth-child(1) > div.J-body.com-body.with-bg > section > div > section > div > div.com-log-list > section:nth-child(1) > section > div > div > span > span 既然要根据图标定位,我们需要分析图标和阅读量的关系. 76 3 因此,我们需要做如下改造才能定位到与阅读量. $(\"#react-root .com-i-view\").each(function(idx,ele){ console.log($(ele).next().text().trim()); }); 定位到阅读量,接下来就是简单的数据累加求和了. //阅读量 var readCount = 0; $(\"#react-root .com-i-view\").each(function(idx,ele){ readCount += parseInt($(ele).next().text().trim()); }); console.log(\"阅读量: \" + readCount); 小结 腾讯云社区和简书一样,采用的分页叠加模式,因此需要统计全部文章的话,只需要一直滚动直到加载出全部文章即可. 总结一下涉及到的新增 jQuery 知识点: 获取当前节点的下一个节点: $(ele).next() 完整示例: //阅读量 var readCount = 0; $(\"#react-root .com-i-view\").each(function(idx,ele){ readCount += parseInt($(ele).next().text().trim()); }); console.log(\"阅读量: \" + readCount); //点赞量 var recommendCount = 0; $(\"#react-root .com-i-like\").each(function(idx,ele){ recommendCount += parseInt($(ele).next().text().trim()); }); console.log(\"点赞量: \" + recommendCount); 小结 本文通过 jQuery 方式直接抓取文章数据,简单方便,学习成本低,能够快速上手. 慕课网和博客园的文章列表存在分页,如果需要统计全部文章浏览量,需要将每一页的文章累加,直到最后一页. 简书和腾讯云社区的文章列表虽然也有分支,但会自动累加,所以统计全部文章时只需要先等全部文章加载完毕,再利用 js 脚本一次性统计即可. 好了,本次分享到此结束,如果你觉得本文对你有所帮助,欢迎分享让更多人看到哦,对了,上一篇文章也是解决统计问题的,不过使用的是 java 读取 csv 文件方式,如果有兴趣,也可以看一看. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/write/static-semi-manual-with-js.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"write/jianshu-optimize-static.html":{"url":"write/jianshu-optimize-static.html","title":"简述优选文章统计","keywords":"","body":"简述优选文章统计 c3.generate({\"bindto\":\"#plugin-chart-5\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\" ], [ \"阅读量\", 14000, \t\t\t\t10000, \t\t\t\t12000, \t\t\t\t9073, \t\t\t\t15000, \t\t\t\t7988, \t\t\t\t18000, \t\t\t\t17036, \t\t\t\t13146, \t\t\t\t16087, \t\t\t\t18788, \t\t\t\t14861, \t\t\t\t19771, \t\t\t\t27232, \t\t\t\t11637, \t\t\t\t12835, \t\t\t\t14173, \t\t\t\t9256, \t\t\t\t31607, \t\t\t\t12552, \t\t\t\t21840, \t\t\t\t10745, \t\t\t\t12573, \t\t\t\t8760, \t\t\t\t10981, \t\t\t\t22641, \t\t\t\t33164, \t\t\t\t28793, \t\t\t\t22393, \t\t\t\t17709, \t\t\t\t16965, \t\t\t\t29429, \t\t\t\t12264, \t\t\t\t25831, \t\t\t\t14984, \t\t\t\t15204 ], [ \"点赞量\", 174, \t\t\t\t70, \t\t\t\t69, \t\t\t\t30, \t\t\t\t191, \t\t\t\t57, \t\t\t\t117, \t\t\t\t124, \t\t\t\t54, \t\t\t\t101, \t\t\t\t101, \t\t\t\t41, \t\t\t\t32, \t\t\t\t83, \t\t\t\t76, \t\t\t\t70, \t\t\t\t61, \t\t\t\t48, \t\t\t\t72, \t\t\t\t74, \t\t\t\t88, \t\t\t\t55, \t\t\t\t28, \t\t\t\t39, \t\t\t\t13, \t\t\t\t36, \t\t\t\t61, \t\t\t\t111, \t\t\t\t28, \t\t\t\t102, \t\t\t\t23, \t\t\t\t55, \t\t\t\t41, \t\t\t\t28, \t\t\t\t31, \t\t\t\t60 ], [ \"评论量\", 57, \t\t\t\t37, \t\t\t\t22, \t\t\t\t43, \t\t\t\t32, \t\t\t\t16, \t\t\t\t57, \t\t\t\t100, \t\t\t\t39, \t\t\t\t67, \t\t\t\t71, \t\t\t\t25, \t\t\t\t59, \t\t\t\t90, \t\t\t\t15, \t\t\t\t96, \t\t\t\t77, \t\t\t\t17, \t\t\t\t37, \t\t\t\t27, \t\t\t\t62, \t\t\t\t17, \t\t\t\t29, \t\t\t\t39, \t\t\t\t11, \t\t\t\t65, \t\t\t\t64, \t\t\t\t41, \t\t\t\t33, \t\t\t\t26, \t\t\t\t27, \t\t\t\t25, \t\t\t\t38, \t\t\t\t36, \t\t\t\t46, \t\t\t\t36 ] ], \"axes\": { \"阅读量\": \"y2\" }, \"types\": { \"阅读量\": \"bar\" } }, \"axis\": { \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"阅读量\", \"position\": \"outer-middle\" } } } }); 阅读量优先 第一名: 27 号 “女生第1次和第5次的区别”,有些东西,只有经历了才懂得 目前为止阅读量最高,33164 次阅读,其中 61 个点赞,评论数也不错,64 个评论,入选精选留言 44. 第二名: 19 号 “叔叔阿姨,那个...能小点声吗？” 阅读量 31607 ,也是不错的成绩,和第一名相比也就差了一两千,但是评论数只有第一名的一半 37,其中入选精选留言数是 34,看样子只要比较正常的留言都入选了,点赞数有 72 比第一名稍微高点. 第三名: 32 号 蔡少芬直言当过小三:老天给了她一手烂牌,她却打出了王炸 阅读量和第二名相差不多,差一点就 3w ,29429 和 31607 相比也是差了一两千,这一点比较有意思了,前三名的阅读量几乎都是差一两千? 评论数有 25 ,入选留言 20 ,点赞数 55 ,和前两名相比中规中矩,没有特别突出之处. 倒数第一名: 6 号 为什么大多数人宁愿吃生活的苦,也不愿吃学习的苦？ 7988 次阅读量,排名垫底,评论数是 16 ,入选留言数 12 ,但是点赞数 57 ,数据并不是很差. 倒数第一的阅读量却拥有第三阅读量的点赞数,这一点足以证明该篇文章的优秀,看得人比较少可能是不愿正视自己吧? 倒数第二名: 24 号 “好不容易上个大学,谈什么恋爱啊” 倒数阅读量的标准本身有些歧视,8760 和 倒数第一名的 7988 相差不到一千,39 次评论,入选 33 条留言,并且点赞数 39 ,各项成绩比较平均. 倒数第三名: 4 号 毕业了,谁又不曾有过爱情的遗憾 和倒数第二名的阅读量相差只有一两百,这个差距应该不是很大,至少不是一两千的差距,遗憾的是仍然是倒数的排名. 9073 次阅读,43 条评论,34 条入选留言,30 个点赞. 站在阅读量优先的立场分析前三名与倒数后三名,不难发现这么一个规律: 简述公众号的受众应该偏向中年,娱乐八卦的话题永远不缺观众,校园生活或者毕业季话题虽然有一定的受众,但是远远不是大众化标准. 暗示色情的标题很大程度上吸引人阅读,但是老司机都明白的是,公众号一般不会真正的色情,所以文章一般都是柳暗花明又一村,如果你想歪了,那就证明你不纯洁! 所以这类文章阅读量比较高,有一种上当受骗的感觉不说点什么觉得对不起自己,所以留言也不错,如果能将这类文章转发出去恶搞一下朋友,这是极好的呢! 点赞量优先 第一名: 5 号 越优秀的人,越不安分 目前为止点赞量第一名,191 次的点赞数,阅读量只有 1.5w ,要知道阅读量前三名都是 3w 啊,仅仅用了一半的阅读量就收获了高于近乎 3 倍的点赞数. 可见,文章的阅读量和点赞量没有必然联系,优秀的文章能够令人深思,愿意主动分享出去,同时这篇文章的评论是是 32,入选留言 22 ,数据比较普通,突出之处就是点赞数. 第二名: 1 号 不合群的你,其实也很酷 点赞数 174 ,很第一名相差一二十而已,评论数是 57,入选留言 45 ,阅读量 1.4w ,从三项指标来看,和第一名不差上下,阅读量虽然少一点,但是评论数却多一点. 有意思的是,点赞数前两名都是和个人修养有关的文章,阅读量 1.5w 是最高阅读量 3w 的一半,也就是说虽然没有大众化口味,但是文章本身的内容非常好,愿意积极进取的中青年看过都说好! 第三名: 8 号 你这么内向,那应该找不到对象吧 124 次点赞稳居排行榜第三名,100 条留言,入选 81 条足以证明该话题引发的讨论是多么激烈,可见话题本身具有一定的爆炸性. 1.7w 的阅读量比前两名的阅读量都要高出两三千,但是点赞数却少了五六十,难不成多出的人是纯粹看热闹的吗? 倒数第一名: 25 号 2060年,那个失踪的宇航员回来了...... 13 次点赞创造历史,10981 次阅读仅仅换来 11 条留言,其中 9 条入选精选留言,除了阅读量高,另外两方面都比较地,我猜是不明所以的人点进来看科幻小说,结果失望而归,所以才没太大人气. 倒数第二名: 31 号 微信朋友圈查访客记录：我和我的“朋友圈”爱人 23 次点赞是本次排名的倒数第二,16965 次阅读本可以像 5 号那样收获最高的点赞数,无奈只有 23 个,27 条留言中入选 24 条,说明文章具备一定的话题性,但是质量还不足以让人主动点赞分享. 倒数第三名: 23 号,29 号,34 号 23 富家女离奇死亡,摩天轮内发现惊人一幕 12573 次阅读量还不错,29 条留言中入选 23 条,点赞数是 28 ,平均下来每一条留言就有一人点赞. 典型的编故事,最终效果竟然还不错,有点不理解. 29 我那个从事裸体艺术的前女友去世了... 22393 次阅读,33 条留言中 26 条入选,最终收获的点赞数也是 28 ,比 23 号多了一半的人都是打酱油的. 34 成为谁,也不要成为小s 大致情况和 29 号差不多,25831 次阅读量本身足够优秀,最高的阅读量也就 3w 啊,36 次留言入选了 23 条,最终点赞数只有 28 . 看样子明星的生活有人愿意看,但是不敢苟同你的观点啊. 分析了点赞排名,发现一个有意思现象,点赞量靠前的文章阅读量不一定很高,可能只有最高阅读量的一半左右,但是优秀的文章天生具备传播性,容易让人点赞分享. 前三名文章竟然无一例外都是和个人修养方面有关的,或者反省自身或者看热闹不留名,总而言之,积极地主旋律应该差不了. 然而倒数后三名的情况有些不一样了,标题带有较为明显的虚假故事情节,离奇猎奇的标题一定程度上吸引了更多人阅读,也引发了一定程度上的讨论,但是最终愿意分享点赞的人却寥寥无几,逞一时之快罢了! 评论量优先 第一名: 8 号 你这么内向,那应该找不到对象吧 又见熟悉的 8 号,内向的我找不到女朋友,记得这篇文章的点赞量 124应该是前三名的,没想到评论数 100 竟然是第一名? 100 次留言,入选 81 条,剩下的 19 条难不成是幸灾乐祸的,所以没入选精选留言? 17036 次阅读不仅是评论量第一名还是点赞量的前三名,即使放到阅读量排名中这个成绩也是不错的. 难不成公众号的粉丝都比较内向,不是说好的奋斗的中青年人设吗? 第二名: 16 号 十年工厂生涯,我活成了没有梦想的中年人 96 次评论入选 74 条留言说明关注这类话题的人确实不少,12835 次阅读中有 70 次点赞,各方面的成绩都挺不错的. 中年人压力很大,简述这一类的用户应该也不少,通过阅读量和点赞量分析来看,不难理解这篇文章为什么如何受欢迎了. 第三名: 14 号 谢谢你,给我18厘米的爱情 首先承认我自己不是纯洁的人,谁让标题起得这么露骨,可是点进去发现我错了,90 次的评论,虽然只有 55 条入选,但是 27232 次阅读量不是吹的,而且 83 次点赞也是很不错的成绩. 倒数第一名: 25 号 2060年,那个失踪的宇航员回来了...... 未来的宇航员又见面了,上一次见面好像是点赞量倒数后三名的时候,没想到评论量后三名又一次出现了. 11 次评论,有 9 条留言入选,明明有 10981 次阅读量,至少不是倒数的阅读量可是评论量和点赞量都不是太理想,点赞数只有区区的 13 个. 倒数第二名: 15 号 你现在这么努力,是为了有朝一日“有得选” 15 次评论有 11 个入选精选留言,11637 次阅读如果不能证明文章很好,那 76 个点赞数应该可以自证清白了吧? 或许是这么一个心理: 你说的都对,我不想评论,还是静静的点赞吧! 倒数第三名: 6 号 为什么大多数人宁愿吃生活的苦,也不愿吃学习的苦？ 又是熟悉的面孔,虽然从标题上看,有些刺眼,但是自古忠言逆耳,更何况标题给人一种事后诸葛亮的感觉,所以阅读量才 7988 垫底,流失了大批读者后并没有影响到点赞量,可见文章还是有一定的质量的. 最终可惜的是,评论量和阅读量双惨淡,未免让人唏嘘! 如果仅仅考虑评论数的多寡,那么只要是话题性文章或者争议性文章,个个都能收获不少的评论数,如果标题带有一定的性暗示,那么话题自然就来了,阅读量不错,评论量也不错,如果文章也不错的话,那么点赞量也不会差. 如果是自身经历的故事情节,也能唤起很多人的共鸣,可惜的是劝学类文章空有内涵,不受待见,阅读量低,评论量自然也不会太高. 优质文章总结 前面从阅读量,点赞量和评论量三个不同纬度排名了 36 篇简书优质文章,从最终的结果上看,大致发现如下规律: 阅读量高的总体质量不会太差,一般都有着不错的评论量和点赞量. 评论量高的总体质量一般不错,阅读量和点赞量也会相当靠前. 点赞量高的总体质量可能不错,阅读量和评论量都无法保证. 情感类的文章阅读量都不错,因为这方面的文章受众比较广,无论是在校学生还是出入职场菜鸟亦或是油腻的中年,对于这类文章都毫无招架之力,如果文章话题性不错的话,随随便便就几十条留言,质量可以的话,点赞分享更是几十,这类文章堪称王者. 励志类的文章一般能够收获不错的点赞量,人人都需要心灵鸡汤的自我催眠,积极进取是奋斗的主旋律,虽然这类文章可能阅读量没有情感类的那么巨大,评论量也可能不是太多,但这类文章确实占据一席之地. 社会类的文章容易引发共鸣,吸引大量读者留言评论,这类文章阅读量和评论量都很不错,但是点赞量就不那么确定了,考虑到因人而异的社会经历,有一定的探险猎奇心理,也是优质文章的一部分. 优质文章有标准,不那么成功的文章也有案列,以下文章可能就不太适合简书公众号. 25 号 : 2060年,那个失踪的宇航员回来了...... 点赞量和评论量均倒数,阅读量中等偏下,因此可能不太适合简书公众号. 科幻小说,字数有些长,不适合公众号阅读,故事本身结局有些突兀,还没看够呢,感觉要走点击购买电子书的套路? 公众号文章一般都是碎片化阅读,此类小说适合专栏故事形式进行连载,或者购买电子书进行引流. 6 号 : 为什么大多数人宁愿吃生活的苦,也不愿吃学习的苦？ 阅读量和评论量均倒数,点赞量中等,因此可能也不太适合. 苦口婆心劝学类文章本不应该太差,可惜标题给人一种事后诸葛亮的说教,但是内容却还不错,文章重点还有加粗标注,点赞量也还可以,所以这篇文章败在标题上,有些遗憾. 数据分析及处理 js 版本数据统计分析示例 var articleStatic = ` 36 https://mp.weixin.qq.com/s/JA_H5y0SHOcS0V-pn8V7Jw 为什么在一线城市待久的人,就很难再回去？ 36 23 15204 60 35 https://mp.weixin.qq.com/s/yqcT5VlIcLh9d7Eyz4uyFw 我嫂子——那个“恶女人”的前半生:你哥他...不行 46 30 14984 31 34 https://mp.weixin.qq.com/s/xJRtW340VwRNDU1hxQc0wA 成为谁,也不要成为小s 36 23 25831 28 33 https://mp.weixin.qq.com/s/TTqzmPeof8FN3D1kErSnJQ 你真傻,念念不忘,是没有回响的 38 31 12264 41 32 https://mp.weixin.qq.com/s/TTqzmPeof8FN3D1kErSnJQ 蔡少芬直言当过小三:老天给了她一手烂牌,她却打出了王炸 25 20 29429 55 31 https://mp.weixin.qq.com/s/7aTGbUziPgWijye1xKF7LA 微信朋友圈查访客记录：我和我的“朋友圈”爱人 27 24 16965 23 30 https://mp.weixin.qq.com/s/sNiSuR7acH43kwnP5yox9g 我的好胜心害死了好朋友······ 26 19 17709 102 29 https://mp.weixin.qq.com/s/i7xqmHHbYrmbBHy__aaGfA 我那个从事裸体艺术的前女友去世了... 33 26 22393 28 28 https://mp.weixin.qq.com/s/85tALM-OAaCet78rfQ59Hw 贾玲,你也是活该！ 41 28 28793 111 27 https://mp.weixin.qq.com/s/bhKFbcoeXDrVmfDhpyDiUA “女生第1次和第5次的区别”,有些东西,只有经历了才懂得 64 44 33164 61 26 https://mp.weixin.qq.com/s/lG3mGfKAvTrI7UL383D6Kw 我的3次相亲经历，次次都教我做人 65 31 22641 36 25 https://mp.weixin.qq.com/s/bT33bHJcsf_Jpwx9mjswNg 2060年,那个失踪的宇航员回来了...... 11 9 10981 13 24 https://mp.weixin.qq.com/s/FBzJZzmzNrpeNtcQBSY4fQ “好不容易上个大学,谈什么恋爱啊” 39 33 8760 39 23 https://mp.weixin.qq.com/s/1JBaS5FTcrzRnylIBaoAKg 富家女离奇死亡,摩天轮内发现惊人一幕 29 23 12573 28 22 https://mp.weixin.qq.com/s/pfqKkHNI9bQDbhdv4gPAnw 有好教养的人,总是闪闪发光的啊 17 12 10745 55 21 https://mp.weixin.qq.com/s/o6aGhHp5uI3Nquy0usaaww 优质男:姑娘,我凭什么娶你？ 62 50 21840 88 20 https://mp.weixin.qq.com/s/PoiHroXm3V1kKjj3u1jnAw 那个改变了我一生的老男人······ 27 20 12552 74 19 https://mp.weixin.qq.com/s/IpXCQ6YPFrq39T1hFu4P-g “叔叔阿姨,那个...能小点声吗？” 37 34 31607 72 18 https://mp.weixin.qq.com/s/8WOH-pBrSCyEyByf8AOi3A “我,23岁,拖延癌晚期，还有救吗？” 17 13 9256 48 17 https://mp.weixin.qq.com/s/74gJMnvGILwajfFMwWFc_g “十二年了,我才没那么想他” 77 71 14173 61 16 https://mp.weixin.qq.com/s/Fb6Ygp07QkaQYFh-O2OBOw 十年工厂生涯,我活成了没有梦想的中年人 96 74 12835 70 15 https://mp.weixin.qq.com/s/n7mTI2dOAPQjG312gXP_8g 你现在这么努力,是为了有朝一日“有得选” 15 11 11637 76 14 https://mp.weixin.qq.com/s/vJpJkwMlqZLLvmf6W342gg 谢谢你,给我18厘米的爱情 90 55 27232 83 13 https://mp.weixin.qq.com/s/TJrq7zNELA48CG_WUJRtnA 我爱上了隔壁那个被家暴的女人 59 40 19771 32 12 https://mp.weixin.qq.com/s/zOQrwG5q7lwvypabYDs27w 你以为是丑拒,其实是...... 25 11 14861 41 11 https://mp.weixin.qq.com/s/jUHhqDS2fjLjTXY551Bn5w 追我那么久,请你放过我 71 64 18788 101 10 https://mp.weixin.qq.com/s/8y2jAt5be1ndl1JNV4H-1A 我犯了一种罪,叫长的不好看 67 34 16087 101 9 https://mp.weixin.qq.com/s/k8uidACpKxz6a8YCg-kwzQ 你都用不起SK-II,还敢熬这么深的夜？ 39 34 13146 54 8 https://mp.weixin.qq.com/s/Vt_nd4xx5gEhNXgyzojAcQ 你这么内向,那应该找不到对象吧 100 81 17036 124 7 https://mp.weixin.qq.com/s/SU3CHUNT7l5Hy0P8WWYPAw 想用自律打败低配人生,你配吗？ 57 46 1.8w 117 6 https://mp.weixin.qq.com/s/FoKMrZ-gvzn1RWUtsFQzJQ 为什么大多数人宁愿吃生活的苦,也不愿吃学习的苦？ 16 12 7988 57 5 https://mp.weixin.qq.com/s/ugG71ETZOAygI-DhMruCEA 越优秀的人,越不安分 32 22 1.5w 191 4 https://mp.weixin.qq.com/s/e1mif6nhCJ-XeRoilhW83A 毕业了,谁又不曾有过爱情的遗憾 43 34 9073 30 3 https://mp.weixin.qq.com/s/nHhoFhuNojiAqqHKkfBYLQ 经营一段亲密关系,难吗？ 22 18 1.2w 69 2 https://mp.weixin.qq.com/s/RqrH9kdgUHIiAfS_vxg3QA 婆媳之间,何止是缘分？ 37 27 1.0w 70 1 https://mp.weixin.qq.com/s/QMEy489ohNGHiETixElgMQ 不合群的你,其实也很酷 57 45 1.4w 174 `; var untreatedArticles = articleStatic.split('\\n'); var treatedArticles = untreatedArticles.slice(1,untreatedArticles.length-1); var nums = []; var comments = []; var reads = []; var likes = []; for (i = 0; i 简书公众号 36 篇优质文章数据 编号 标题 阅读量 点赞量 评论量 36 为什么在一线城市待久的人,就很难再回去？ 15204 60 36 35 我嫂子——那个“恶女人”的前半生:你哥他...不行 14984 31 46 34 成为谁,也不要成为小s 25831 28 36 33 你真傻,念念不忘,是没有回响的 12264 41 38 32 蔡少芬直言当过小三:老天给了她一手烂牌,她却打出了王炸 29429 55 25 31 微信朋友圈查访客记录：我和我的“朋友圈”爱人 16965 23 27 30 我的好胜心害死了好朋友······ 17709 102 26 29 我那个从事裸体艺术的前女友去世了... 22393 28 33 28 贾玲,你也是活该！ 28793 111 41 27 “女生第1次和第5次的区别”,有些东西,只有经历了才懂得 33164 61 64 26 我的3次相亲经历，次次都教我做人 22641 36 65 25 2060年,那个失踪的宇航员回来了...... 10981 13 11 24 “好不容易上个大学,谈什么恋爱啊” 8760 39 39 23 富家女离奇死亡,摩天轮内发现惊人一幕 12573 28 29 22 有好教养的人,总是闪闪发光的啊 10745 55 17 21 优质男:姑娘,我凭什么娶你？ 21840 88 62 20 那个改变了我一生的老男人······ 12552 74 27 19 “叔叔阿姨,那个...能小点声吗？” 31607 72 37 18 “我,23岁,拖延癌晚期，还有救吗？” 9256 48 17 17 “十二年了,我才没那么想他” 14173 61 77 16 十年工厂生涯,我活成了没有梦想的中年人 12835 70 96 15 你现在这么努力,是为了有朝一日“有得选” 11637 76 15 14 谢谢你,给我18厘米的爱情 27232 83 90 13 我爱上了隔壁那个被家暴的女人 19771 32 59 12 你以为是丑拒,其实是...... 14861 41 25 11 追我那么久,请你放过我 18788 101 71 10 我犯了一种罪,叫长的不好看 16087 101 67 9 你都用不起SK-II,还敢熬这么深的夜？ 13146 54 39 8 你这么内向,那应该找不到对象吧 17036 124 100 7 想用自律打败低配人生,你配吗？ 1.8w 117 57 6 为什么大多数人宁愿吃生活的苦,也不愿吃学习的苦？ 7988 57 16 5 越优秀的人,越不安分 1.5w 191 32 4 毕业了,谁又不曾有过爱情的遗憾 9073 30 43 3 经营一段亲密关系,难吗？ 1.2w 69 22 2 婆媳之间,何止是缘分？ 1.0w 70 37 1 不合群的你,其实也很酷 1.4w 174 57 36 https://mp.weixin.qq.com/s/JA_H5y0SHOcS0V-pn8V7Jw 为什么在一线城市待久的人，就很难再回去？ 36 23 15204 60 35 https://mp.weixin.qq.com/s/yqcT5VlIcLh9d7Eyz4uyFw 我嫂子——那个“恶女人”的前半生：你哥他...不行 46 30 14984 31 34 https://mp.weixin.qq.com/s/xJRtW340VwRNDU1hxQc0wA 成为谁，也不要成为小s 36 23 25831 28 33 https://mp.weixin.qq.com/s/TTqzmPeof8FN3D1kErSnJQ 你真傻，念念不忘，是没有回响的 38 31 12264 41 32 https://mp.weixin.qq.com/s/TTqzmPeof8FN3D1kErSnJQ 蔡少芬直言当过小三：老天给了她一手烂牌，她却打出了王炸 25 20 29429 55 31 https://mp.weixin.qq.com/s/7aTGbUziPgWijye1xKF7LA 微信朋友圈查访客记录：我和我的“朋友圈”爱人 27 24 16965 23 30 https://mp.weixin.qq.com/s/sNiSuR7acH43kwnP5yox9g 我的好胜心害死了好朋友······ 26 19 17709 102 29 https://mp.weixin.qq.com/s/i7xqmHHbYrmbBHy__aaGfA 我那个从事裸体艺术的前女友去世了... 33 26 22393 28 28 https://mp.weixin.qq.com/s/85tALM-OAaCet78rfQ59Hw 贾玲，你也是活该！ 41 28 28793 111 27 https://mp.weixin.qq.com/s/bhKFbcoeXDrVmfDhpyDiUA “女生第1次和第5次的区别”，有些东西，只有经历了才懂得 64 44 33164 61 26 https://mp.weixin.qq.com/s/lG3mGfKAvTrI7UL383D6Kw 我的3次相亲经历，次次都教我做人 65 31 22641 36 25 https://mp.weixin.qq.com/s/bT33bHJcsf_Jpwx9mjswNg 2060年，那个失踪的宇航员回来了...... 11 9 10981 13 24 https://mp.weixin.qq.com/s/FBzJZzmzNrpeNtcQBSY4fQ “好不容易上个大学，谈什么恋爱啊” 39 33 8760 39 23 https://mp.weixin.qq.com/s/1JBaS5FTcrzRnylIBaoAKg 富家女离奇死亡，摩天轮内发现惊人一幕 29 23 12573 28 22 https://mp.weixin.qq.com/s/pfqKkHNI9bQDbhdv4gPAnw 有好教养的人，总是闪闪发光的啊 17 12 10745 55 21 https://mp.weixin.qq.com/s/o6aGhHp5uI3Nquy0usaaww 优质男：姑娘，我凭什么娶你？ 62 50 21840 88 20 https://mp.weixin.qq.com/s/PoiHroXm3V1kKjj3u1jnAw 那个改变了我一生的老男人······ 27 20 12552 74 19 https://mp.weixin.qq.com/s/IpXCQ6YPFrq39T1hFu4P-g “叔叔阿姨，那个...能小点声吗？” 37 34 31607 72 18 https://mp.weixin.qq.com/s/8WOH-pBrSCyEyByf8AOi3A “我，23岁，拖延癌晚期，还有救吗？” 17 13 9256 48 17 https://mp.weixin.qq.com/s/74gJMnvGILwajfFMwWFc_g “十二年了，我才没那么想他” 77 71 14173 61 16 https://mp.weixin.qq.com/s/Fb6Ygp07QkaQYFh-O2OBOw 十年工厂生涯，我活成了没有梦想的中年人 96 74 12835 70 15 https://mp.weixin.qq.com/s/n7mTI2dOAPQjG312gXP_8g 你现在这么努力，是为了有朝一日“有得选” 15 11 11637 76 14 https://mp.weixin.qq.com/s/vJpJkwMlqZLLvmf6W342gg 谢谢你，给我18厘米的爱情 90 55 27232 83 13 https://mp.weixin.qq.com/s/TJrq7zNELA48CG_WUJRtnA 我爱上了隔壁那个被家暴的女人 59 40 19771 32 12 https://mp.weixin.qq.com/s/zOQrwG5q7lwvypabYDs27w 你以为是丑拒，其实是...... 25 11 14861 41 11 https://mp.weixin.qq.com/s/l5GKBMa0RMYa5Zs_Z-J1bQ 越是难熬的日子，越要有事可做 22 18 13294 101 11 https://mp.weixin.qq.com/s/jUHhqDS2fjLjTXY551Bn5w 追我那么久，请你放过我 71 64 18788 101 10 https://mp.weixin.qq.com/s/8y2jAt5be1ndl1JNV4H-1A 我犯了一种罪，叫长的不好看 67 34 16087 101 9 https://mp.weixin.qq.com/s/k8uidACpKxz6a8YCg-kwzQ 你都用不起SK-II ，还敢熬这么深的夜？ 39 34 13146 54 8 https://mp.weixin.qq.com/s/Vt_nd4xx5gEhNXgyzojAcQ 你这么内向，那应该找不到对象吧 100 81 17036 124 7 https://mp.weixin.qq.com/s/SU3CHUNT7l5Hy0P8WWYPAw 想用自律打败低配人生，你配吗？ 57 46 1.8w 117 6 https://mp.weixin.qq.com/s/FoKMrZ-gvzn1RWUtsFQzJQ 为什么大多数人宁愿吃生活的苦，也不愿吃学习的苦？ 16 12 7988 57 5 https://mp.weixin.qq.com/s/ugG71ETZOAygI-DhMruCEA 越优秀的人，越不安分 32 22 1.5w 191 4 https://mp.weixin.qq.com/s/e1mif6nhCJ-XeRoilhW83A 毕业了，谁又不曾有过爱情的遗憾 43 34 9073 30 3 https://mp.weixin.qq.com/s/nHhoFhuNojiAqqHKkfBYLQ 经营一段亲密关系，难吗？ 22 18 1.2w 69 2 https://mp.weixin.qq.com/s/RqrH9kdgUHIiAfS_vxg3QA 婆媳之间，何止是缘分？ 37 27 1.0w 70 1 https://mp.weixin.qq.com/s/QMEy489ohNGHiETixElgMQ 不合群的你，其实也很酷 57 45 1.4w 174 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/write/jianshu-optimize-static.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"write/faq.html":{"url":"write/faq.html","title":"常见问题","keywords":"","body":"常见问题 The page build failed for the master branch with the following error 问题描述 看到这封邮件,一脸懵逼,本地运行 gitbook 服务是正常渲染的,控制台并没有任何报错,谁知道推送到 github 时就报错了! 登录到 github 网站查看网站源码已经同步过来了,但是静态网站无法同步,本地实在找不到任何报错信息,这让我如何是好? 再看 github 反馈用的邮件中说道,如有问题可以回复邮件(If you have any questions you can contact us by replying to this email.). 然后死马当活马医,尝试阐释了我的问题,请求帮助定位错误日志,没想到当天下午就收到 github 的回复邮件,提供了解决办法! 问题是由于 Liquid Warning: Liquid syntax error (line 334) 错误,然而我确定这部分代码是没有任何问题的,因为这是我改造 gitbook-plugin-tbfed-pagefooter 插件时的一段代码,反复确认后发现并没有复制粘贴出错啊! var moment = require('moment'); module.exports = { book: { assets: './assets', css: [ 'footer.css' ], }, hooks: { 'page:before': function(page) { var _label = '最后更新时间: ', _format = 'YYYY-MM-DD', _copy = 'powered by snowdreams1006' if(this.options.pluginsConfig['tbfed-pagefooter']) { _label = this.options.pluginsConfig['tbfed-pagefooter']['modify_label'] || _label; _format = this.options.pluginsConfig['tbfed-pagefooter']['modify_format'] || _format; var _c = this.options.pluginsConfig['tbfed-pagefooter']['copyright']; _copy = _c ? _c + ' all right reserved，' + _copy : _copy; } var _copy = ''+_copy+''; var str = ' \\n\\n' + _copy + '' + _label + '\\n{{file.mtime | date(\"' + _format + '\")}}\\n'; str += '\\n\\n'+ '\\n\\n'+ '\\n\\n'+ '\\n\\n'; page.content = page.content + str; return page; } }, filters: { date: function(d, format) { return moment(d).format(format) } } }; 来源于 gitbook-plugin-tbfed-pagefooter 插件的 index.js 文件,这里为了兼容 gitalk 插件而集成了相关代码,详情请参考 gitalk 评论插件 解决方案 根据邮件回复,定位到出错代码片段,真的没发现有什么问题啊? 既然已经确定不是我的问题,那很可能就是 github 的问题了,邮件中推荐我使用 Jekyll 进行构建网站,不不不! 既然已经选择 gitbook 搭建静态网站,那就没必要再使用 Jekyll ,我可不想那么麻烦! If you are not using Jekyll you can disable it by including a .nojekyll file in the root of your repository. 所以我不妨试试新增 .nojekyll 文件,说不定就好使了呢! $ touch .nojekyll $ git add .nojekyll $ git commit -m \"add .nojekyll\" $ git push 天不负我!竟然真的好使了,再也没有收到 github 的报错邮件反馈了,源码和网站都正常更新了! 小结 据我推测,可能是 github 误认为我的网站是使用 Jekyll 工具构建的,实际上,是使用 gitbook 构建的! 因此,增加 .nojekyll 文件禁用 Jekyll 工具,自然不会再受相关语法限制而报错了. 所以,遇到问题时,不仅要多思考,更应该寻求官方人员的帮助,即使不回你,你也要尝试一下! var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/write/faq.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:37 "},"bigDataWave/":{"url":"bigDataWave/","title":"大数据浪潮之巅:新技术商业制胜之道","keywords":"","body":"大数据浪潮之巅:新技术商业制胜之道 这本书讲述了大数据的发展史,描述了一幅波澜壮阔的宏大场面,有的公司迎难而上抓住机遇,有的公司错失良机失之交臂,看到的不是技术而是一系列的历史事件. 富有趣味性,让人爱不释手,通宵看完意犹未尽,值得推荐,好书! 作者简介 徐飞,著名大数据专家.拥有浙江大学本科学位,美国佛罗里达大学计算机博士学位,研究方向为数据库系统. 从事大数据的基础架构研发 10 余年,先后在微软和 Tableau 等知名公司的大数据核心团队工作.担任过首席架构师. 在国际顶尖会议和杂志上发表论文 10 余篇. 2016 年开通微信公众号\"飞总聊 IT\",并原创\"大数据那些事\"系列文章,系统阐述了大数据发展史,以及发展过程中的种种技术和商业决策案例,受到广泛好评. 内容简介 本书以各个企业在大数据浪潮中跌宕起伏的经历为核心来讲述大数据发展史,并分析各个大数据企业迥异的发展历程,探讨在新技术浪潮来临时应该如何应对. 本书主要分为两部分,前半部分讲述谷歌,微软,IBM,雅虎,亚马逊,阿里巴巴等大公司在大数据浪潮中的发展史,后半部分讲述各个大数据创业公司的发展历程和现状. 在每部分的后面,还通过专门的文章分析并总结了各企业在大数据浪潮中的作为和选择所产生的影响. 全书从公司的视角出发为大家呈现了一幅波澜壮阔的大数据领域发展史,读者不仅可以了解大数据技术,更能领略大数据领域的全貌,从各公司的故事中吸取教训,学习思路. 本书适合对大数据技术和商业思维有兴趣的读者阅读. 目录 谷歌的大数据路: 从拥有\"三驾马车\"到丧失先发优势 谷歌的“三驾马车”开启了大数据时代,然而在这个新时代里,谷歌却丧失了先发优势. 这是为什么呢?我认为是谷歌对待开放架构的态度相对保守导致的. 谷歌的大数据路: 一场影响深远的论战 在大数据发展史上,以迈克尔·斯通布雷克为代表的数据库元老级人物,针对MapReduce向谷歌提出了质疑. 这场著名的论战给整个业界带来了动荡,最后诞生了Spark. 谷歌的大数据路: 谷歌的\"黑科技\" 在大数据的上半场,谷歌以\"三驾马车\"引领时代,但后来因为决策失误丧失了先发优势; 而在大数据的下半场,谷歌带着\"黑科技\"Spanner数据库系统闪亮登场,效果如何呢？ 如何读懂类似谷歌\"三驾马车\"这样的技术论文 读懂一篇技术论文,首先需要明白\"论文是写给谁看的\"和\"论文是怎么写出来的\"这两个基本问题,然后就可以有针对性地提升自己阅读论文的功力. 雅虎：大数据领域的\"活雷锋\" 雅虎,这个早已淡出我们视线的公司,却是大数据领域的\"活雷锋\",可以说正是它促成了今天的Hadoop生态圈.这篇文章就来说说它的故事. IBM的大数据路——起早贪黑赶了个晚集 作为历史悠久的计算机公司,IBM早早涉足了大数据领域,最终却只能寄希望于比自己的产品起步还要晚的Spark,我们来看看其中发生了什么. 三大社交媒体公司对Hadoop生态圈的贡献 雅虎把Hadoop开源以后,当时著名的三大社交媒体公司Facebook,LinkedIn和Twitter都加入了这个生态圈,并做出了巨大贡献.Hadoop生态圈给我们的启示是,抱团取暖才是生存之道. 微软的大数据发展史: 微软硅谷研究院 微软硅谷研究院曾经在微软的大数据发展历程中扮演了非常特殊的角色,它推出的Dryad和DryadLINQ可以说是两个另类的产品,虽然未曾大受欢迎,却对大数据的发展有着不可磨灭的贡献. 微软的大数据发展史: 必应的Cosmos Cosmos是微软必应搜索引擎下面的团队开发的大数据基础架构,代表了微软在大数据方面的最高成就. 微软的大数据发展史: Azure的发展 微软大数据发展史上的另一个分支是微软云计算平台下的大数据项目Azure. 这个项目产生了HDInsight,Azure Data Lake,CosmosDB三大平台,但最后只有CosmosDB取得成功. 亚马逊的大数据故事: 从先驱者到一味索取者 在大数据技术发展的早期,亚马逊发表了Dynamo系统的论文,成为和谷歌\"三驾马车\"的论文一样具有深远影响的论文. 然而随着大数据的发展和Hadoop生态圈的建立,亚马逊对大数据圈的贡献极少,但亚马逊自己却从中获得了巨大的利益. 亚马逊的大数据故事: 创新和\"拿来\"并存的云服务 亚马逊不仅在Hadoop生态系统里蓬勃发展，还推出了自己的数据分析产品.这些产品有些是亚马逊自己研发的,有些则只是对开源的产品进行了包装.但是，亚马逊一如既往地没有反哺开源项目. 阿里巴巴的大数据故事: 数据分析平台发展史 国内大数据平台做得最好的公司当属阿里巴巴. 本文就来介绍一下阿里巴巴数据分析平台的发展情况: 数据分析平台的叠加开发. 阿里巴巴的大数据故事: 流计算引擎发展史 在阿里巴巴的发展过程中,流数据处理一直是一项十分重要的技术,阿里巴巴也在这方面做了很多有意义的项目. 本文就来介绍一下阿里巴巴的流计算引擎JStorm与Blink的发展史. 大公司的大数据战略得失: 自建\"轮子\"成本高 大公司的大数据平台可分为两类,一类是自己搭的基础架构(自建\"轮子\"),另一类是抱团取暖所形成的Hadoop生态圈,两者各有利弊.本文将分析第1种情况,主要以谷歌,微软,阿里巴巴自己搭建的大数据平台架构为代表. 大公司的大数据战略得失: 抱团取暖的Hadoop生态圈 除了自建\"轮子\"的公司,其他各大公司走向了一条抱团取暖的道路,就是你搭一个模块,我搭一个模块,大家一起开源出来,最后组成了一个叫作Hadoop的生态圈. 其中有为社区积极做贡献的公司,也有以赚钱为目的的公司,还有一味索取的公司. Hadoop三国之\"魏国\"——Cloudera Hadoop领域曾经有三家发行商互相角逐,其中不乏各种战术与谋略,仔细琢磨,你会发现这三家公司的关系与三国时期的魏蜀吴之间的关系非常相似.本文讲述Hadoop三国之\"魏国\"——Cloudera的故事. Hadoop三国之\"吴国\"——MapR Hadoop三国之\"吴国\"MapR,实力强大却很少参与竞争,这篇文章就来说说它特立独行的故事. Hadoop三国之\"蜀国\"——Hortonworks Hadoop三国之\"蜀国\"Hortonworks始终坚持100%开源,本文讲述它的故事. Hadoop及其发行商的未来 Hadoop已诞生十多年,围绕其生态圈诞生了诸多企业,例如前面讲的社交媒体公司,三大发行商,而亚马逊却最终成为最大的受益者. 文档数据库的缔造者MongoDB(上) MongoDB的诞生像一场意外.它是一个文档型数据库,由10gen公司开发,以易用性闻名. 本文就来讲述MongoDB团队的开发重心,商业运作模式和产品盈利方式. 文档数据库的缔造者MongoDB(下) MongoDB的开发团队一向重视用户体验而不重视核心功能,其负面影响终于以一次安全危机的方式暴露. 加上公司曾经获得具有CIA背景的风投公司的投资,这一并引起了很多人的顾虑. 当然,这一切都挡不住MongoDB公司最终的成功上市. 以MongoDB为例,看基础架构类产品创业 作为一款基础架构类产品,MongoDB以其易用性闻名,然而MongoDB的开发者不注重系统的可靠性,只注重可用性,导致很多MongoDB的用户转向了其他产品. 基础架构类产品的创业者应该如何平衡可用性和可靠性?这是一个值得深思的问题. 直面MongoDB,谈微软的N0SQL战略 2013年,MongoDB在数据库市场中的占有率很高,成为很多创业者和初创企业的首选. 微软究竟做了哪些事情,将Cosmos DB变成能与MongoDB竞争的产品的呢? Palantir: 神秘的大数据独角兽公司 Palantir是一家神秘的大数据创业公司,由硅谷著名投资人彼得·蒂尔创办,其主要服务对象是美国政府部门,特情组织和军队,所以外界对其了解甚少. Splunk: 机器日志数据分析帝国 Splunk是大数据圈里少有的盈利并且蓬勃发展的企业. 它主要服务于机器日志数据分析领域,随后又不断拓展业务,演变开发了若干不同类型的软件. 在本文中我们就来好好聊聊Splunk的进阶史. Confluent: Kafka项目背后的公司 Kafka是LinkedIn开发的开源项目,它主要通过日志文件传输的方式在不同的数据源之间同步数据. 而Confluent公司是Kafka开源项目的创始人离开LinkedIn以后所创立的公司,主要致力于Kafka项目的商业化. 在本文中,我们来讲讲这家公司的故事. Powerset: HBase的\"老东家\" Powerset是一家在多年前被微软收购的创业公司,目前在语义搜索方面开疆拓土. 它为开源社区贡献了BigTable的Hadoop版实现. 本文就来讲讲这家公司的发展史. Cassandra和DataStax公司的故事 Cassandra是开源社区仿照Amazon Dynamo开发的产品,它最初由Facebook开发并开源,却又被公司内部弃用. 创业公司DataStax对Cassandra大力支持,造就了今日繁荣的Cassandra社区。 Databricks: Spark的数据\"金砖\"王国 Spark是Hadoop生态圈里大红大紫的项目,它甚至取代了Hadoop MapReduce的地位. Databricks是对这个项目进行商业化的企业. 本文就来聊聊这家企业的故事. Data Artisans和浴火重生的新一代大数据计算引擎Flink Data Artisans是对Flink进行商业化的公司. Apache Flink是一个年轻的新型处理引擎,是Hadoop社区里Spark的主要竞争对手. Flink设计理念先进,但是工程实现方面相对落后. Dremio: 基于Drill和Arrow的大数据公司 Dremio是另外一家大数据创业公司,其创始人是从MapR公司跳槽出来的. Dremio的主要产品就是Dremio项目,它吸收了MapR主导的开源项目Drill的精华,以开源项目Arrow为核心开发. 本文就来讲讲Dremio公司和Dremio平台的来龙去脉. Imply: 基于Druid的大数据分析公司 开源大数据项目Druid由Metamarkets开发. 开始时籍籍无名,后来被一些大公司,尤其是Airbnb使用和推广以后,受到了很多关注. Kyligence: 麒麟背后的大数据公司 麒麟(英文名字是Kylin)是第1个全部由中国人主导的Apache顶级开源项目,Kyligence则是对这个项目进行商业化的公司. 本文就来看看麒麟和Kyligence的故事. Snowflake: 云端的弹性数据仓库 Snowflake是一个构建在云端的弹性数据仓库,它背后的公司与之同名. Snowflake公司的创始人和管理层都有强大的背景,本文就来讲一下Snowflake及其公司的故事. TiDB：一个国产新数据库的创业故事 TiDB是位于北京的一家创业公司PingCAP的产品,它的目标是实现一个开源的类似谷歌Spanner的系统,这个产品非常有特色,本文就来聊聊TiDB和它背后的公司. 大数据创业公司的前景: 红海vs.蓝海 关于创业的市场,通常有红海和蓝海的说法,蓝海容易成功,红海相对艰难. 对大数据创业公司来说,蓝海多半指的是应用软件类的市场,而红海指的则是基础架构软件类的市场. 本文将对比分析一下这两类市场. 如何通过分析企业的技术积累来判断其发展前景 通过分析企业的技术积累,能够有效地判断企业的发展前景如何. 我们需要关注三个方面: 技术适用的场景是否有巨大的盈利空间,技术本身是否有领先和独到之处,以及技术的积累是否足够深和广. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/bigDataWave/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "},"greet/":{"url":"greet/","title":"晚安","keywords":"","body":"晚安 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/greet/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"other/":{"url":"other/","title":"其他","keywords":"","body":"其他 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/other/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"other/transformation.html":{"url":"other/transformation.html","title":"转型之路","keywords":"","body":"转型之路 视频来自腾讯课堂: 程序员转型之路 如何学习?什么叫理财? 01.如何正确认识学习? 知识: 靠记忆 (20%) 技能: 靠练习 (30%) 态度: 靠发心 (50%) 纸上谈兵一万次,不如战场来一遍 02.谈转型 graph LR product((产品)) -.- management((管理)) management -.- freelance((自由职业)) freelance -.- market((市场)) market -.- entrepreneurship((创业)) 03.如何更高效学习与运用 保持持续性学习 学会跳出自己的\"舒适区\" 思维转变,换个角度看世界 04.学习思路 graph LR empty_cup_mentality[空杯心态] --- closing_comments[关闭评论] closing_comments --- know_and_use[知用合一] know_and_use --- timely_output[及时输出] 如何让自己快速拥有10万+流量,并且快速变现 各大平台特点 抖音 今日头条 微信公众号 知乎 新浪博客 简书 大鱼号 百家号 搜狐自媒体 熊掌号 一点资讯 抖音分为商家版和个人版,成立专门团队,越专业越成功! 到底如何写内容 标题的重要性 字数在20字以内 出乎意料 带数字 给人感觉像故事或干货 人格化定位 引导转发和分享 如何把流量快速变现 如何写出可以直接收钱的文案 如何30分钟学会演讲,客服种种心里障碍 如何复制转型成功的程序员称为自有职业者,月收入是5万+ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/other/transformation.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"other/static.html":{"url":"other/static.html","title":"历史统计","keywords":"","body":"历史统计 全网统计 c3.generate({\"bindto\":\"#plugin-chart-6\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 110, 115, 115, 116, 134, 197, 285 ], [ \"阅读\", 49453, 53447, 53829, 54106, 71422, 91544, 115362 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 慕课手记 慕课手记 : https://www.imooc.com/u/5224488/articles c3.generate({\"bindto\":\"#plugin-chart-7\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 18, 18, 18, 18, 19, 24, 27 ], [ \"阅读量\", 16448, 18037, 18215, 18313, 24293, 29870, 34813 ], [ \"手记\", 61, 61, 61, 61, 64, 75, 79 ], [ \"推荐\", 78, 79, 79, 79, 85, 99, 105 ], [ \"积分\", 334, 341, 342, 342, 421, 555, 632 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 简书 简书 : https://www.jianshu.com/u/577b0d76ab87 c3.generate({\"bindto\":\"#plugin-chart-8\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 21, 24, 24, 24, 28, 41, 49 ], [ \"阅读量\", 2825, 3242, 3287, 3317, 4869, 6194, 8277 ], [ \"文章\", 61, 61, 61, 61, 64, 74, 79 ], [ \"喜欢\", 121, 125, 126, 127, 135, 151, 174 ], [ \"简书钻\", 107, 24, 24, 24, 26, 69, 95 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); CSDN CSDN : https://blog.csdn.net/weixin_38171180 c3.generate({\"bindto\":\"#plugin-chart-9\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 0, 0, 0, 0, 0, 11, 53 ], [ \"访问量\", 2872, 2846, 2858, 2858, 3306, 4097, 10484 ], [ \"原创\", 59, 60, 60, 60, 62, 72, 99 ], [ \"喜欢\", 55, 55, 55, 55, 59, 68, 90 ], [ \"积分\", 669, 669, 669, 669, 706, 820, 954 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 博客园 博客园 : https://www.cnblogs.com/snowdreams1006/ c3.generate({\"bindto\":\"#plugin-chart-10\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 21, 21, 21, 21, 21, 23, 25 ], [ \"阅读数\", 7756, 8256, 8298, 8329, 11240, 14397, 16256 ], [ \"随笔\", 61, 62, 62, 62, 64, 74, 78 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 掘金 掘金 : https://juejin.im/user/582d5cb667f356006331e586 c3.generate({\"bindto\":\"#plugin-chart-11\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"关注者\", 10, 10, 10, 10, 15, 33, 51 ], [ \"阅读数\", 1885, 2086, 2093, 2105, 3246, 4984, 7005 ], [ \"专栏\", 60, 60, 60, 60, 63, 74, 79 ], [ \"点赞数\", 89, 89, 90, 91, 107, 147, 168 ], [ \"掘力值\", 106, 109, 110, 110, 138, 194, 235 ] ], \"axes\": { \"关注者\": \"y2\" }, \"types\": { \"关注者\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"关注者\", \"position\": \"outer-middle\" } } } }); 思否 思否 : https://segmentfault.com/blog/snowdreams1006 c3.generate({\"bindto\":\"#plugin-chart-12\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 2, 2, 2, 2, 3, 4, 4 ], [ \"阅读量\", 6063, 6980, 7073, 7156, 10591, 15226, 18746 ], [ \"内容数\", 62, 62, 62, 62, 65, 75, 80 ], [ \"点赞数\", 23, 23, 23, 23, 27, 29, 37 ], [ \"声望\", 91, 91, 91, 91, 97, 101, 123 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 开源中国 开源中国 : https://my.oschina.net/snowdreams1006 c3.generate({\"bindto\":\"#plugin-chart-13\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 17, 17, 17, 17, 17, 22, 27 ], [ \"访问量\", 6307, 6374, 6376, 6383, 6593, 7756, 9389 ], [ \"博文\", 61, 61, 61, 61, 64, 74, 79 ], [ \"推荐\", 13, 13, 13, 13, 13, 15, 16 ], [ \"积分\", 13, 13, 13, 13, 13, 14, 17 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); 腾讯云社区 腾讯云社区 : https://cloud.tencent.com/developer/user/2952369/activities c3.generate({\"bindto\":\"#plugin-chart-14\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 13, 13, 13, 13, 13, 13, 13 ], [ \"阅读量\", 4809, 5062, 5065, 5076, 6324, 7642, 8573 ], [ \"文章\", 62, 62, 62, 62, 67, 77, 80 ], [ \"点赞\", 199, 199, 199, 199, 215, 248, 256 ], [ \"订阅\", 11, 12, 12, 12, 12, 12, 12 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); B站专栏 B站专栏 : https://member.bilibili.com/v2#/upload-manager/text c3.generate({\"bindto\":\"#plugin-chart-15\", \"data\": { \"x\": \"x\", \"columns\": [ [ \"x\", \"2019-03-31\", \"2019-04-30\", \"2019-05-31\", \"2019-06-30\", \"2019-07-31\", \"2019-08-31\", \"2019-09-30\" ], [ \"粉丝\", 10, 10, 10, 11, 18, 26, 36 ], [ \"阅读量\", 490, 564, 564, 569, 960, 1378, 1819 ], [ \"投稿\", 56, 56, 56, 56, 59, 70, 75 ], [ \"点赞\", 65, 65, 65, 65, 70, 78, 91 ], [ \"收藏\", 16, 22, 22, 23, 35, 46, 63 ], [ \"投币\", 1, 1, 1, 1, 1, 1, 1 ] ], \"axes\": { \"粉丝\": \"y2\" }, \"types\": { \"粉丝\": \"bar\" } }, \"axis\": { \"x\": { \"type\": \"timeseries\", \"tick\": { \"format\": \"%Y-%m-%d\" } }, \"y2\": { \"show\": \"true\", \"label\": { \"text\": \"粉丝\", \"position\": \"outer-middle\" } } } }); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/other/static.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"other/me.html":{"url":"other/me.html","title":"关于作者","keywords":"","body":"关于作者 慕课网认证作者,今日头条优质科技领域创作者,微信公众号「雪之梦技术驿站」号主,目前专注于后端领域,主要技术栈有 Java,Go 和 NodeJs 等. var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/other/me.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"other/donate.html":{"url":"other/donate.html","title":"捐赠支持","keywords":"","body":"捐赠支持 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/other/donate.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:36 "},"todo/":{"url":"todo/","title":"TODO清单","keywords":"","body":"TODO清单 nodejs-操作文件系统读取写入文件 10分钟教你撸一个nodejs爬虫系统 NodeJs+Request+Cheerio 采集数据 nodejs模拟登录-request模块 GitHub Wiki 页面的添加和设置 Kingfisher $ npm version patch $ git tag $ git push origin v0.0.2 $ npm install -g cnpm --registry=https://registry.npm.taobao.org https://johnnyting.github.io/posts/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90readmegitignore%E6%96%87%E4%BB%B6/ readme https://github.com/kefranabg/readme-md-generator https://github.com/github/gitignore/ http://www.gitignore.io/ \"engines\": { \"gitbook\": \">=2.4.3\" }, \"gitbook\": { \"properties\": { \"blogId\": { \"type\": \"string\", \"required\": true, \"description\": \"Openwrite blogId.\" }, \"name\": { \"type\": \"string\", \"required\": true, \"description\": \"Blog name.\" }, \"qrcode\": { \"type\": \"string\", \"required\": true, \"description\": \"Wechat qrcode.\" }, \"keyword\": { \"type\": \"string\", \"required\": true, \"description\": \"Wechat keyword.\" } } } INFO Install dependencies npm WARN deprecated core-js@1.2.7: core-js@ npm ERR! A complete log of this run can be found in: npm ERR! /Users/sunpo/.npm/_logs/2019-10-09T01_40_58_136Z-debug.log WARN Failed to install dependencies. Please run 'npm install' manually! sunpodeMacBook-Pro:hexo-plugin-readmore sunpo$ sudo chown -R 501:20 \"/Users/sunpo/.npm\" Password: sunpodeMacBook-Pro:hexo-plugin-readmore sunpo$ npm install npm notice created a lockfile as package-lock.json. You should commit this file. up to date in 1.429s found 0 vulnerabilities title: Hello World abbrlink: 16107 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Reference Hexo配置和部署 hexo——轻量、简易、高逼格的博客 5分钟搞定个人博客-hexo hexo史上最全搭建教程 为Hexo添加Gitalk评论插件 Gitment/Gitalk自动初始化 自动初始化 Gitalk 和 Gitment 评论 Hexo+NexT（六）：手把手教你编写一个Hexo过滤器插件 GitHub+Hexo搭建个人博客（四）Hexo高阶之第三方插件 搭建Hexo博客进阶篇--API和一些小部件（四） Hexo高级教程之插件开发 Hexo主题开发 32dc4ab0f6b98922dcada02d9b6cd8da4bcb1935 得到Go程序的汇编代码的方法 使用Hugo搭建静态站点 TOML简介 Hugo加入评论的功能 错误管理 资源管理与出错处理 defer 调用 确保调用在函数结束时发生 参与在defer语言时计算 defer列表为后进先出 何时使用 defer 调用 Open/Close Lock/Unlock PrintHeader/PrintFooter 错误处理二 如何实现统一的错误处理逻辑 panic 停止当前函数执行 一直向上返回,执行每一层的 defer 如果没有遇见recover,程序退出 recover 仅在 defer 调用中使用 获取 panic 的值 如果无法处理,可重新 panic error vs panic 意料之中的:使用 error,如: 文件打不开 意料之外的:使用 panic,如: 数组越界 Go 的错误机制 与其他主要的编程语言的差异: 没有异常机制 error 类型实现了 error 接口 可以通过 errors.New 来快速创建错误实例 type error interface{ Error() string } errors.New(\"n must be in the range []\") panic panic 用于不可恢复的错误 panic 退出前会执行defer指定的内容 panic vs os.Exit os.Exit 退出时不会调用 defer指定的函数 os.Exit 退出时不输出当前调用栈信息 当心,recover 称为恶魔 形成僵尸服务进程,导致 health check 失效 \"Let it Crash\" 往往是我们恢复不确定性错误的最好方式 https://golang.google.cn/ref/spec#Defer_statements A \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. defer Stmt = \"defer\" Expression . func TestFuncWithoutDefer(t *testing.T) { // 「雪之梦技术驿站」: 正常顺序 t.Log(\"「雪之梦技术驿站」: 正常顺序\") // 1 2 t.Log(1) t.Log(2) } func TestFuncWithDefer(t *testing.T) { // 「雪之梦技术驿站」: 正常顺序执行完毕后才执行 defer 代码 t.Log(\" 「雪之梦技术驿站」: 正常顺序执行完毕后才执行 defer 代码\") // 2 1 defer t.Log(1) t.Log(2) } func TestFuncWithMultipleDefer(t *testing.T) { // 「雪之梦技术驿站」: 猜测 defer 底层实现数据结构可能是栈,先进后出. t.Log(\" 「雪之梦技术驿站」: 猜测 defer 底层实现数据结构可能是栈,先进后出.\") // 3 2 1 defer t.Log(1) defer t.Log(2) t.Log(3) } func TestFuncWithMultipleDeferOrder(t *testing.T) { // 「雪之梦技术驿站」: defer 底层实现数据结构类似于栈结构,依次倒叙执行多个 defer 语句 t.Log(\" 「雪之梦技术驿站」: defer 底层实现数据结构类似于栈结构,依次倒叙执行多个 defer 语句\") // 2 3 1 defer t.Log(1) t.Log(2) defer t.Log(3) } func TestFuncWithMultipleDeferAndReturn(t *testing.T) { // 「雪之梦技术驿站」: defer 延迟函数会在包围函数正常return之前逆序执行. t.Log(\" 「雪之梦技术驿站」: defer 延迟函数会在包围函数正常return之前逆序执行.\") // 3 2 1 defer t.Log(1) defer t.Log(2) t.Log(3) return t.Log(4) } func TestFuncWithMultipleDeferAndPanic(t *testing.T) { // 「雪之梦技术驿站」: defer 延迟函数会在包围函数panic惊慌失措之前逆序执行. t.Log(\" 「雪之梦技术驿站」: defer 延迟函数会在包围函数panic惊慌失措之前逆序执行.\") // 3 2 1 defer t.Log(1) defer t.Log(2) t.Log(3) panic(\"「雪之梦技术驿站」: defer 延迟函数会在包围函数panic惊慌失措之前逆序执行.\") t.Log(4) } The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements. Each time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the \"defer\" statement is executed. 注意2：defer函数参数的计算时间点 defer函数的参数是在defer语句出现的位置做计算的，而不是在函数运行的时候做计算的，即所在函数结束的时候计算的。 package main import \"log\" func foo(n int) int { log.Println(\"n1=\", n) defer log.Println(\"n=\", n) n += 100 log.Println(\"n2=\", n) return n } func main() { var i int = 100 foo(i) } 其运行结果是： 2017/09/30 19:25:10 n1= 100 2017/09/30 19:25:10 n2= 200 2017/09/30 19:25:10 n= 100 可以看到defer函数的位置时n的值为100，尽管在函数foo结束的时候n的值已经是200了，但是defer语句本身所处的位置时刻，即foo函数入口时n为100，所以最终defer函数打印出来的n值为100。 注意3：如何在defer语句里面使用多条语句 前面我们提到defer后面只能是一条函数调用指令；而实际情况下经常会需要逻辑运行，会有分支，条件，而不是简单的一个log.Print指令；那怎么处理这种情况呢，我们可以把这些逻辑指令一起定义成一个函数，然后再调用这些函数就行了，命名函数或者匿名函数都可以，下面是一个匿名函数的例子： package main import \"log\" import _ \"time\" func foo(n int) int { log.Println(\"n1=\", n) defer func() { n += 100 log.Println(\"n=\", n) }() n += 100 log.Println(\"n2=\", n) return n } func main() { var i int = 100 foo(i) } 运行结果： 2017/09/30 19:30:58 n1= 100 2017/09/30 19:30:58 n2= 200 2017/09/30 19:30:58 n= 300 眼尖的同学会发现其中的问题；为什么n打印出来是300呢，不是明明说好defer函数的参数值在它出现时候计算，而不是在运行的时候计算的吗，n应该打印出200才对啊？ 同学，仔细看一下原文：defer函数的参数在defer语句出现的位置计算，不是在defer函数运行的时刻计算；人家明明说的很清楚，defer函数的参数，请问这里n是参数吗，不是哎，这里引用的是宿主函数的局部变量，而不是参数；所以它拿到的是运行时刻的值。 这就引发出下一个注意事项。 注意4：defer函数会影响宿主函数的返回值 package main import \"log\" func foo1(i int) int { i += 100 defer func() { i += 200 }() log.Printf(\"i=%d\", i) return *i } func foo2(i int) (r int) { i += 100 defer func() { r += 200 }() log.Printf(\"i=%d\", i) return i } func main() { var i, r int i,r = 0,0 r = foo1(&i) log.Printf(\"i=%d, r=%d\\n\", i, r) i,r = 0,0 r = foo2(&i) log.Printf(\"i=%d, r=%d\\n\", i, r) } 运行结果为： $ go build main.go && ./main 2017/09/30 20:01:00 i=100 2017/09/30 20:01:00 i=300, r=100 2017/09/30 20:01:00 i=100 2017/09/30 20:01:00 i=100, r=300 这个例子其实有一点拗口的。 foo1 return指令前(i==100, ret==0)，return指令后(i==100, ret=100)，然后调用defer函数后(i==300，r==100)，defer函数增加了i；main函数收到(i==300, r==100) foo2 return指令前(i==100, ret==0)，return指令后(i==100, ret=100)，然后调用defer函数后(i==100，r==300)，defer函数增加了ret；main函数收到(i==100, r==300) 因为如果defer后面的f.Close()没有延迟执行，那么文件描述符都关闭了，就不会读取到任何内容。 函数值和函数参数被求值，但函数不会立即调用 下面这个例子即将诠释上半段，它来自<>，稍作修改: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func trace(funcName string) func(){ start := time.Now() fmt.Printf(\"function %s enter\\n\",funcName) return func(){ log.Printf(\"function %s exit (elapsed %s)\",funcName,time.Since(start)) } } func foo(){ defer trace(\"foo()\")() time.Sleep(5time.Second) } func main(){ foo() foo() } / OUTPUT: function foo() enter function foo() exit (elapsed 5.0095471s) function foo() enter function foo() exit (elapsed 5.0005382s) */ 　　 为什么foo会输出enter然后等待五秒左右再输出exit? 因为正如我们说的， defer后面的函数值和参数会被求值但是实际函数调用却要等到最后 这里函数值就是trace()返回的匿名函数，函数参数当然就是字符串字面值\"foo()\"， 对trace(\"foo()\")的求值会输出function foo() enter， 实际函数调用trace(\"foo()\")()即输出function foo() exit(elapsed x.x)会推迟到return执行(如果return会更新返回值变量，则会在更新后才执行defer的函数)。 快速设置— 如果你知道该怎么操作，直接使用下面的地址 git@gitee.com:snowdreams1006/private-cloud-backup.git 我们强烈建议所有的git仓库都有一个README, LICENSE, .gitignore文件 Git入门？查看 帮助 , Visual Studio / TortoiseGit / Eclipse / Xcode 下如何连接本站, 如何导入仓库 简易的命令行入门教程: Git 全局设置: git config --global user.name \"snowdreams1006\" git config --global user.email \"snowdreams1006@163.com\" 创建 git 仓库: mkdir private-cloud-backup cd private-cloud-backup git init touch README.md git add README.md git commit -m \"first commit\" git remote add origin git@gitee.com:snowdreams1006/private-cloud-backup.git git push -u origin master 已有仓库? cd existing_git_repo git remote add origin git@gitee.com:snowdreams1006/private-cloud-backup.git git push -u origin master git remote --verbose git remote set-url --add origin git@gitee.com:snowdreams1006/snowdreams1006.git var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/todo/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-12 13:42:36 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://snowdreams1006.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://snowdreams1006.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/GLOSSARY.html 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! © snowdreams1006 all right reserved，powered by Gitbook文件修订时间: 2019-11-01 19:34:35 "}}